[
    {
        "Content": "```bash\nwget https://golang.google.cn/dl/go1.17.linux-amd64.tar.gz      #安装\ntar -zxvf go1.17.linux-amd64.tar.gz -C /usr/local/              #解压\n\nif [[ -f \".bashrc\" ]]; then\n    echo \"PATH=\\$PATH:/usr/local/go/bin\" \u003e\u003e ~/.bashrc            #将go所在目录添加到环境变量\n    source ~/.bashrc\nfi\nif [[ -f \".zshrc\" ]]; then\n    echo \"PATH=\\$PATH:/usr/local/go/bin\" \u003e\u003e ~/.zshrc             #将go所在目录添加到环境变量\n    source ~/.zshrc\nfi\n\n/usr/local/go/bin/go env -w GOPROXY=https://goproxy.cn,direct   #换国内源\n/usr/local/go/bin/go env -w GO111MODULE=\"auto\"                  #开启go module\n\ngo install github.com/uudashr/gopkgs/v2/cmd/gopkgs@latest       #实用的插件\ngo install github.com/ramya-rao-a/go-outline@latest             #实用的插件\ngo install github.com/cweill/gotests/gotests@latest             #实用的插件\ngo install github.com/fatih/gomodifytags@latest                 #实用的插件\ngo install github.com/josharian/impl@latest                     #实用的插件\ngo install github.com/haya14busa/goplay/cmd/goplay@latest       #实用的插件\ngo install github.com/go-delve/delve/cmd/dlv@latest             #实用的插件\ngo install github.com/go-delve/delve/cmd/dlv@latest             #实用的插件\ngo install honnef.co/go/tools/cmd/staticcheck@latest            #实用的插件\ngo install golang.org/x/tools/gopls@latest                      #实用的插件\n```\n",
        "Title": "go一键安装脚本(linux)",
        "CreateTime": 1630147094000,
        "FormatTime": "2021.08.28",
        "Categories": "Go",
        "Tags": [
            "golang",
            "linux"
        ],
        "EditorType": "markdown"
    },
    {
        "Content": "## 问题：\n希望在go代码中ctrl左键import的package查看定义，但却跳转到了浏览器的https://pkg.go.dev/xxxx/xxxx中\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210221194043668.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FwYWxlXzg=,size_16,color_FFFFFF,t_70)\n\n## 原因：\n- vscode会默认识别超链接，然后在ctrl左键点击超链接时进行跳转\n- go的package就是以超链接的形式引入的\n## 解决方法\n- 禁用vscode识别超链接的功能\n\n```json\n\t\"editor.links\": false,\n```\n\n",
        "Title": "vscode go关闭超链接跳转",
        "CreateTime": 1613907455000,
        "FormatTime": "2021.02.21",
        "Categories": "Go",
        "Tags": [
            ""
        ],
        "EditorType": "markdown"
    },
    {
        "Content": "问题背景:\n希望在post参数错误时返回自定义的提示信息，但http状态码始终返回400\n```go\nif err := c.BindJSON(\u0026xxx); err != nil {\n\tfmt.Println(\"解析参数失败, err: %+v\", err)\n\tc.JSON(http.StatusOK, \"参数错误\")\n\treturn\n}\n```\n原因: MustBindWith在参数错误时返回400\n\n```go\n// BindJSON is a shortcut for c.MustBindWith(obj, binding.JSON).\nfunc (c *Context) BindJSON(obj interface{}) error {\n    return c.MustBindWith(obj, binding.JSON)\n}\n\n// MustBindWith binds the passed struct pointer using the specified binding engine.\n// It will abort the request with HTTP 400 if any error occurs.\n// See the binding package.\nfunc (c *Context) MustBindWith(obj interface{}, b binding.Binding) error {\n    if err := c.ShouldBindWith(obj, b); err != nil {\n        c.AbortWithError(http.StatusBadRequest, err).SetType(ErrorTypeBind) // nolint: errcheck\n        return err\n    }\n    return nil\n}\n```\n解决方法 : 绑定结构体时使用ShouldBind系列\n",
        "Title": "Gin框架踩坑[参数错误时http状态码始终返回400]",
        "CreateTime": 1611134317000,
        "FormatTime": "2021.01.20",
        "Categories": "Go",
        "Tags": [
            ""
        ],
        "EditorType": "markdown"
    },
    {
        "Content": "这学期在学编译原理，上周刚学完词法分析，作业是手动构造DFA并完成词法分析。然而优秀的人当然要以高标准要求自己，于是花了两天实现了输入正则表达式构造NFA和NFA转DFA的算法。\n\n算法包括以下几个步骤：\n+ 正则表达式-\u003e后缀表达式\n+ 用后缀表达式构造NFA\n+ 用NFA构造DFA\n+ 最小化DFA(暂未完成)\n# 正则表达式-\u003e后缀表达式\n## 正则表达式的定义\n算法中实现的正则表达式仅包含$()|*$运算符。为了方便实现，显式地增加了连接运算符^， 如abc*d会被修改为a ^ b ^ c * ^d。$字符在式子中的含义是空串。\n预处理部分的代码:\n\n```c\nchar Lex::statusCode(char a)//非运算符返回本身，其他返回'a'\n{//inputSet是不包含运算符的字符集\n    if (inputSet.find(a) != inputSet.end())\n        return 'a';\n    return a;\n}\n\nvoid Lex::preprocess()\n{//charSet是字符集，包含运算符\n    assert(reg.size());\n    int l = 0;\n    for (const auto \u0026item : reg)\n    {\n        assert(charSet.find(item) != charSet.end());//判断是否所有字符都合法\n        if (item == '(') ++l;\n        else if (item == ')') --l;\n        assert(l \u003e= 0);//判断括号是否匹配\n    }\n    assert(l == 0);//判断括号是否匹配\n    //对于每两个相邻的字符，statusCode分别为a( aa )a *a *( )(时\n    //需要在中间加上^\n    for (int i = 0; i \u003c reg.size() - 1; ++i)\n    {\n        int a = statusCode(reg[i]), b = statusCode(reg[i + 1]);\n        if (a == 'a' \u0026\u0026 b == '(' || a == 'a' \u0026\u0026 b == 'a' || a == ')' \u0026\u0026 b == 'a' || a == '*' \u0026\u0026 b == 'a' ||\n            a == '*' \u0026\u0026 b == '(' || a == ')' \u0026\u0026 b == '(')\n            reg.insert(i + 1, \"^\");\n    }\n    std::cout \u003c\u003c reg \u003c\u003c '\\n';\n    reg = toSuffix(reg);//转换为后缀表达式\n    std::cout \u003c\u003c reg \u003c\u003c '\\n';\n}\n\n```\n\n### 运算符优先级\n从大到小: * ^ | (，右括号特殊处理(转后缀表达式时右括号不入栈，不需要优先级)\n确定优先级后即可将中缀形式的正则表达式转换为后缀形式。\n(a | b) * ^ a ^ b ^ b 将被转换为\na b | * a ^ b ^ b ^\n```c\nbool isOperator(char c)\n{//判断是不是运算符\n    switch (c)\n    {\n        case '*':\n        case '|':\n        case '^':\n            return true;\n        default:\n            return false;\n    }\n}\n\n\nint getPriority(int c)\n{//运算符的优先级\n    int level = 0; // 优先级\n    switch (c)\n    {\n        case '(':\n            level = 1;\n            break;\n        case '|':\n            level = 2;\n            break;\n        case '^':\n            level = 3;\n            break;\n        case '*':\n            level = 4;\n            break;\n        default:\n            break;\n    }\n    return level;\n}\n\nstring toSuffix(const string \u0026expr)\n{\n    stack\u003cchar\u003e op;\n    string suffix;\n    for (const auto \u0026c: expr)\n    {\n        if (isOperator(c))\n        {//是运算符\n            if (op.empty())//栈空，直接入栈\n                op.emplace(c);\n            else\n            {//优先级更大的运算符全部出栈\n                while (!op.empty())\n                {\n                    int t = op.top();\n                    if (getPriority(c) \u003c= getPriority(t))\n                    {\n                        op.pop();\n                        suffix.push_back(t);\n                    }\n                    else\n                        break;\n                }\n                op.emplace(c);\n            }\n        }\n        else\n        {\n            if (c == '(')//左括号直接入栈\n                op.emplace(c);\n            else if (c == ')')\n            {//遇到右括号，一直出栈，直到遇到左括号\n                while (op.top() != '(')\n                {\n                    suffix.push_back(op.top());\n                    op.pop();\n                }\n                op.pop();\n            }\n            else\n            \tsuffix.push_back(c);//操作数直接放入表达式中\n        }\n    }\n    while (!op.empty())\n    {//取出剩余的运算符\n        suffix.push_back(op.top());\n        op.pop();\n    }\n    return suffix;\n}\n```\n# 后缀表达式构造NFA\n## 定义NFA类\n数据成员: 开始状态、结束状态和图\n+ 参考龙书上的算法，这里构造出的NFA只会有一个开始状态和一个结束状态\n+ start和end其实没啥用(但还是写在这里了)，因为该算法构造出的NFA的开始状态一定是0，结束状态一定是最后一个状态\n+ 图中包含了NFA五元组中的**状态集合**和**转换函数**\n+ 图用vector\u003cunordered_map\u003cchar, vector\u003cint\u003e\u003e\u003e存储\n+ 字符集存储在之前提到的inputSet中\n\n```c\nstruct NFA\n    {\n        vector\u003cunordered_map\u003cchar, vector\u003cint\u003e\u003e\u003e G;\n        int start, end;\n\n        NFA()\n        {\n            G.resize(1);\n            start = end = 0;\n        }\n\n        size_t size() const\n        {\n            return G.size();\n        }\n\n        unordered_map\u003cchar, vector\u003cint\u003e\u003e \u0026operator[](int n)\n        {\n            assert(n \u003c G.size());\n            return G[n];\n        }\n\n        NFA \u0026operator+=(NFA b)\n        {//合并两个图\n            int offset = size();\n            for (int i = 0; i \u003c b.size(); ++i)\n            {\n                G.push_back(b[i]);\n                for (auto \u0026k: G.back())\n                    for (auto \u0026v: k.second)\n                        v += offset;\n            }\n            return *this;\n        }\n    };\n```\n需要注意的是operator+=。因为算法中需要连接两个图，所以重载operato+=来完成合并。因为两个图的节点编号都是从0开始的，所以b连接到a后面时，b中所有边指向的节点编号都要加上一个offset(a的size)\n## 构造NFA\n(以下图片截自龙书第二版)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20201001175823965.png#pic_center)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20201001175834620.png#pic_center)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20201001175847162.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FwYWxlXzg=,size_16,color_FFFFFF,t_70#pic_center)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20201001175854831.png#pic_center)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20201001175901855.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FwYWxlXzg=,size_16,color_FFFFFF,t_70#pic_center)\n按照上面的五张图的方式建图，即可完成NFA的构造\n//代码中$是空串\n```c\nvoid Lex::buildNFA()\n{\n    stack\u003cNFA\u003e stk;\n    for (auto \u0026c: reg)\n    {\n        if (!isOperator(c))//前两张图片\n        {\n            NFA a;\n            a.G.resize(2);\n            a.end = 1;\n            a[0][c] = {a.end};\n            stk.emplace(a);//每次新产生的子NFA都放入栈中\n        }\n        else\n        {//后三张图片\n            switch (c)\n            {\n                case '|':\n                {\n                    NFA tmp;\n                    NFA b = stk.top();\n                    stk.pop();\n                    NFA a = stk.top();\n                    stk.pop();\n                    size_t size1 = tmp.size();\n                    tmp += a;\n                    tmp[tmp.start]['$'].emplace_back(a.start + size1);\n\n                    size_t size2 = tmp.size();\n                    tmp += b;\n                    tmp[tmp.start]['$'].emplace_back(b.start + size2);\n                    tmp[a.end + size1]['$'] = {int(tmp.size())};\n                    tmp[b.end + size2]['$'] = {int(tmp.size())};\n                    tmp.end = tmp.size();\n                    tmp.G.emplace_back(unordered_map\u003cchar, vector\u003cint\u003e\u003e());\n                    stk.emplace(tmp);//每次新产生的子NFA都放入栈中\n                    break;\n                }\n                case '*':\n                {\n                    NFA tmp;\n                    NFA a = stk.top();\n                    stk.pop();\n                    size_t size1 = tmp.size();\n                    tmp += a;\n                    tmp[tmp.start]['$'].emplace_back(a.start + size1);\n                    tmp[a.end + size1]['$'].emplace_back(a.start + size1);\n                    size_t s = tmp.size();\n                    tmp[a.end + size1]['$'].emplace_back(s);\n                    tmp.end = s;\n                    tmp.G.emplace_back(unordered_map\u003cchar, vector\u003cint\u003e\u003e());\n                    tmp[tmp.start]['$'].emplace_back(s);\n                    stk.emplace(tmp);//每次新产生的子NFA都放入栈中\n                    break;\n                }\n                case '^':\n                {\n                    NFA b = stk.top();\n                    stk.pop();\n                    NFA a = stk.top();\n                    stk.pop();\n                    a.G.pop_back();\n                    size_t s = a.size();\n                    a += b;\n                    a.end = b.end + s;\n                    stk.emplace(a);//每次新产生的子NFA都放入栈中\n                    break;\n                }\n                default:\n                    assert(0);\n            }\n        }\n    }\n    nfa = stk.top();\n}\n```\n# 用NFA构造DFA\n## DFA类的定义\n\n```c\nstruct DFA\n{\n    map\u003cint, map\u003cchar, int\u003e\u003e G;//图\n    unordered_set\u003cint\u003e end;//结束状态集合\n    bool match(const string \u0026s,char (*type)(char c))\n    {\n        int now = 0;\n        for (auto \u0026i: s)\n        {\n            char c = type(i);\n            if (G[now].count(c))\n                now = G[now][c];\n            else\n                return false;\n        }\n        return end.count(now);\n    }\n};\nstruct DStat\n{\n    set\u003cint\u003e stats;\n    int id;\n\n    bool operator\u003c(const DStat \u0026d) const\n    {\n        return stats \u003c d.stats;\n    }\n\n    bool operator==(const DStat \u0026d) const\n    {\n        return stats == d.stats;\n    }\n};\n```\n\n## 子集构造法\n定义: \n$move(T, a)$: NFA中，一个状态集合T中通过一个字符a可以转移到的状态集合为\n$\\epsilon-closure(s)$: 由状态s通过任意数量空边能转移到的状态集合\n$\\epsilon-closure(T)$: 一个状态集合T中的所有状态通过任意数量的空边能转移到的状态集合为\n对于NFA中的一个状态集合T，它经过一个字符a能转移到的状态集合即为\n$$\\epsilon-closure(move(T, a))$$\n而初始状态下，NFA可以位于$\\epsilon-closure(start)$的所有状态\n下面是龙书中的伪代码和对应的我的实现:\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20201001181139124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FwYWxlXzg=,size_16,color_FFFFFF,t_70#pic_center)\n\n```c\nvoid Lex::buildDFA()\n{\n    vector\u003cDStat\u003e Dstats;\n    Dstats.emplace_back(e_closure(nfa.start));\n    set\u003cDStat\u003e vis;\n    vis.insert(Dstats[0]);\n    for (int i = 0; i \u003c Dstats.size(); ++i)\n    {\n        for (auto c: inputSet)\n        {\n            if (c == '$')\n                continue;\n            auto U = e_closure(move(Dstats[i], c));\n            if (U.stats.empty())\n                continue;\n            if (vis.find(U) == vis.end())\n            {\n                Dstats.emplace_back(U);\n                if (U.stats.find(nfa.end) != U.stats.end())\n                    dfa.end.insert(std::find(Dstats.begin(), Dstats.end(), U) - Dstats.begin());//U在DStat中的下标\n                vis.insert(U);\n            }\n            dfa.G[i][c] = std::find(Dstats.begin(), Dstats.end(), U) - Dstats.begin();//U在DStat中的下标\n        }\n    }\n    for (int i = 0; i \u003c Dstats.size(); ++i)\n    {\n        std::cout \u003c\u003c i \u003c\u003c \": {\";\n        for (auto \u0026j:Dstats[i].stats)\n            std::cout \u003c\u003c j \u003c\u003c ' ';\n        std::cout \u003c\u003c \"}\\n\";\n    }\n    for (auto \u0026i: dfa.G)\n        for (auto \u0026j: i.second)\n        {\n            std::cout \u003c\u003c i.first \u003c\u003c ' ' \u003c\u003c j.first \u003c\u003c ' ' \u003c\u003c j.second \u003c\u003c '\\n';\n        }\n}\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020100118114910.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FwYWxlXzg=,size_16,color_FFFFFF,t_70#pic_center)\n\n```c\nLex::DStat Lex::e_closure(int s)\n{\n    DStat stat;\n    stat.stats.insert(s);\n    stack\u003cint\u003e stk;\n    stk.emplace(s);\n    stat.stats.insert(s);\n    while (!stk.empty())\n    {\n        int i = stk.top();\n        stk.pop();\n        for (auto \u0026v: nfa[i]['$'])\n        {\n            if (stat.stats.find(v) != stat.stats.end()) continue;\n            stk.emplace(v);\n            stat.stats.insert(v);\n        }\n    }\n    return stat;\n}\n\nLex::DStat Lex::e_closure(Lex::DStat T)\n{//这里实现和伪代码不太一样，我直接对多个e_closure(s)取并了\n    DStat stat;\n    for (auto \u0026i: T.stats)\n    {\n        auto tmp = e_closure(i);\n        for (auto \u0026v: tmp.stats)\n            stat.stats.insert(v);\n    }\n    return stat;\n}\n\nLex::DStat Lex::move(const Lex::DStat \u0026T, char a)\n{\n    DStat stat;\n    for (auto \u0026i: T.stats)\n        if (nfa[i].find(a) != nfa[i].end())\n            for (auto \u0026v: nfa[i][a])\n            {\n                if (stat.stats.find(v) == stat.stats.end())\n                {\n                    stat.stats.insert(v);\n                }\n            }\n    return stat;\n}\n```\n至此就完成了DFA的构造\n\n为了检验代码的正确性，我用如下正则表达式构造了识别数字的DFA，并通过了leetcode65 有效数字\n\n  + ($|+|-)aa*($|.a*)($|e($|+|-)aa*)|($|+|-)a*(a|.aa*)($|e($|+|-)aa*)\n   ![在这里插入图片描述](https://img-blog.csdnimg.cn/2020100118242139.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FwYWxlXzg=,size_16,color_FFFFFF,t_70#pic_center)\n   从内存消耗没有击败100%这一点也能看出算法还有进一步优化的空间(DFA的最小化)\n   \n**博客中仅为部分代码。详细代码见[github](https://github.com/Apale7/CompilersPrinciple)中的Lex和utils**\n# 最小化DFA\n(下次一定写\n",
        "Title": "正则表达式-＞NFA-＞DFA(C++实现)",
        "CreateTime": 1601548083000,
        "FormatTime": "2020.10.01",
        "Categories": "编译原理",
        "Tags": [
            "正则表达式",
            "c++",
            "编译器"
        ],
        "EditorType": "markdown"
    },
    {
        "Content": "裸的马拉车算法。(当然回文自动机也行)\n\n```c\nclass Solution\n{\npublic:\n    string longestPalindrome(const string \u0026s)\n    {\n        auto p = manacher(s);\n        return s.substr(p.first - p.second \u003e\u003e 1, p.second - 1);\n    }\n\n    pair\u003cint, int\u003e manacher(const string \u0026s)\n    {\n        string a = \"$#\";\n        for (auto \u0026i: s)\n        {\n            a.push_back(i);\n            a.push_back('#');\n        }\n        vector\u003cint\u003e p(a.size(), 0);\n        int mx = 0, mid = 0, ansMid = 0, ansLen = 0;\n        for (int i = 1; i \u003c int(a.size()); ++i)\n        {\n            p[i] = mx \u003e i ? min(mx - i, p[2 * mid - i]) : 1;\n\n            while (a[i + p[i]] == a[i - p[i]]) ++p[i];\n            if (i + p[i] \u003e mx)\n            {\n                mx = i + p[i];\n                mid = i;\n            }\n            if (p[i] \u003e ansLen)\n            {\n                ansLen = p[i];\n                ansMid = i;\n            }\n        }\n        return {ansMid, ansLen};\n    }\n};\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200712162630327.png)\n",
        "Title": "LeetCode 5.最长回文子串",
        "CreateTime": 1594542399000,
        "FormatTime": "2020.07.12",
        "Categories": "Leetcode",
        "Tags": [
            ""
        ],
        "EditorType": "markdown"
    },
    {
        "Content": "累了……以后只放一份代码了。\n# 思路\n假设第一个数组的长度为$s1$，第二个数组的长度为$s2$\n在数组1中选一个位置$m1$，将数组分割为两部分，\n左半部分长度为$m1$，右半部分长度为$s1-m1$\n在数组2中也选一个位置$m2$进行分割，使得$m1+m2 == s1-m1+s2-m2$\n此时如果$m1$左侧的数小于等于$m2$右侧的数，且$m2$左侧的数小于等于$m1$右侧的数，则中位数就产生在两个分割处两侧的四个数中；否则就调整$m1$的位置，直到满足条件。\n因此二分$m1$，就可以在$O(logs1)$的时间内得到答案\n因为数组长度的奇偶处理起来很麻烦，所以可以借鉴马拉车算法中的增加分隔符的思想将数组长度翻倍。翻倍后长度一定是奇数，更方便处理。\n实际上不需要真正地添加分隔符，只要将二分的范围翻倍，取数组值的时候再除以二即可\n二分较小的数组可以提升性能。\n```python\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -\u003e float:\n        inf = 2000000000\n        if len(nums1) \u003e len(nums2):\n            nums1, nums2 = nums2, nums1\n        s1, s2 = len(nums1), len(nums2)\n        low, high = 0, 2 * len(nums1)\n        while low \u003c= high:\n            m1 = low + high \u003e\u003e 1\n            m2 = s1 + s2  - m1\n            l1 = nums1[m1 - 1 \u003e\u003e 1] if m1 else -inf\n            r1 = nums1[m1 \u003e\u003e 1] if m1 \u003c 2 * s1 else inf\n            l2 = nums2[m2 - 1 \u003e\u003e 1] if m2 else -inf\n            r2 = nums2[m2 \u003e\u003e 1] if m2 \u003c 2 * s2 else inf\n            if l1 \u003e r2:\n                high = m1 - 1\n            elif l2 \u003e r1:\n                low = m1 + 1\n            else:\n                break\n        return (max(l1, l2) + min(r1, r2)) / 2.0\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020070721000141.png)\n",
        "Title": "LeetCode 4. 寻找两个正序数组的中位数",
        "CreateTime": 1594126889000,
        "FormatTime": "2020.07.07",
        "Categories": "Leetcode",
        "Tags": [
            ""
        ],
        "EditorType": "markdown"
    },
    {
        "Content": "遍历字符串s，用数组num(哈希表也行)记录已出现的字符，用队列存储以当前字符为尾的无重复字符的最长子串。当当前字符已出现时，要将上次出现的位置之前的所有字符从队列中删去。遍历过程中队列的最大长度就是最终结果。\n#### C++\n```c\nclass Solution\n{\npublic:\n    int lengthOfLongestSubstring(string s)\n    {\n        auto num = vector\u003cchar\u003e(128, 0);\n        queue\u003cchar\u003e q;\n        int ans = 0;\n        for (auto \u0026i: s)\n        {\n            if (num[i])\n            {\n                while (num[i])\n                {\n                    --num[q.front()];\n                    q.pop();\n                }\n            }\n            q.push(i);\n            if (q.size() \u003e ans)\n                ans = q.size();\n            ++num[i];\n        }\n        return ans;\n    }\n};\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200706202834702.png)\n\n#### Python\n\n```python\nfrom queue import Queue\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -\u003e int:\n        st = set()\n        q = Queue()\n        ans = 0\n        for i in s:\n            while i in st:\n                st.remove(q.get())\n            q.put(i)\n            st.add(i)\n            ans = max(ans, q.qsize())\n        return ans\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200706203411603.png)\n实际上直接维护两个指针来模拟队列操作，而不显式使用队列，效率会更高(时间复杂度都是$O(N)$)。\n#### 修改后的Python\n\n```python\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -\u003e int:\n        st = set()\n        head = 0\n        tail = -1\n        ans = 0\n        for i in s:\n            while i in st:\n                st.remove(s[head])\n                head += 1\n            tail += 1\n            st.add(i)\n            ans = max(ans, tail - head + 1)\n        return ans\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200706204618261.png)\n确实快了很多\n",
        "Title": "LeetCode 3.无重复字符的最长子串",
        "CreateTime": 1594039630000,
        "FormatTime": "2020.07.06",
        "Categories": "Leetcode",
        "Tags": [
            ""
        ],
        "EditorType": "markdown"
    },
    {
        "Content": "直接模拟竖式加法即可(题目倒过来存放数字，可以说是极其友善了)。\n\n```c\nclass Solution\n{\npublic:\n    ListNode *addTwoNumbers(ListNode *l1, ListNode *l2)\n    {\n        auto head = new ListNode(0);//ans是带头结点的单链表\n        auto ans = head;\n        char carry = 0;\n        while (l1 != nullptr \u0026\u0026 l2 != nullptr)\n        {\n            l1-\u003eval += l2-\u003eval + carry;\n            carry = 0;\n            if (l1-\u003eval \u003e= 10)\n            {\n                carry = 1;\n                l1-\u003eval -= 10;\n            }\n            head-\u003enext = l1;\n            head = head-\u003enext;\n            l1 = l1-\u003enext;\n            l2 = l2-\u003enext;\n        }\n        while (l1 != nullptr)\n        {\n            l1-\u003eval += carry;\n            carry = 0;\n            if (l1-\u003eval \u003e= 10)\n            {\n                carry = 1;\n                l1-\u003eval -= 10;\n            }\n            else//一个小优化。不进位时直接将后续结点接上就可以结束了\n            {\n                head-\u003enext = l1;\n                break;\n            }\n            head-\u003enext = l1;\n            l1 = l1-\u003enext;\n            head = head-\u003enext;\n        }\n        while (l2 != nullptr)\n        {\n            l2-\u003eval += carry;\n            carry = 0;\n            if (l2-\u003eval \u003e= 10)\n            {\n                carry = 1;\n                l2-\u003eval -= 10;\n            }\n            else\n            {\n                head-\u003enext = l2;\n                break;\n            }                \n            head-\u003enext = l2;\n            l2 = l2-\u003enext;\n            head = head-\u003enext;\n        }\n        if (carry)\n            head-\u003enext = new ListNode(carry);\n        auto t = ans;\n        ans = ans-\u003enext;//跳过头结点\n        delete t;//释放内存\n        return ans;\n    }\n};\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200706200341762.png)\n```python\nclass Solution:\n    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -\u003e ListNode:\n        carry = 0\n        head = ListNode(0)\n        ans = head\n        while l1 and l2:\n            l1.val += carry + l2.val\n            carry = 0\n            if l1.val \u003e 9:\n                l1.val -= 10\n                carry = 1\n            head.next = l1\n            head = head.next\n            l1 = l1.next\n            l2 = l2.next\n        while l1:\n            l1.val += carry\n            carry = 0\n            if l1.val \u003e 9:\n                l1.val -= 10\n                carry = 1\n            else:\n                head.next = l1\n                break\n            head.next = l1\n            l1 = l1.next\n            head = head.next\n        while l2:\n            l2.val += carry\n            carry = 0\n            if l2.val \u003e 9:\n                l2.val -= 10\n                carry = 1\n            else:\n                head.next = l2\n                break\n            head.next = l2\n            l2 = l2.next\n            head = head.next\n        if carry:\n            head.next = ListNode(1)\n        return ans.next\n\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200706200258650.png)\npython写得还是矬，跑这么慢= =\n",
        "Title": "LeetCode 2.两数相加",
        "CreateTime": 1594037060000,
        "FormatTime": "2020.07.06",
        "Categories": "Leetcode",
        "Tags": [
            ""
        ],
        "EditorType": "markdown"
    },
    {
        "Content": "# LeetCode 1.两数之和\n\n两个想法：\n\n## 1、二分查找\n\n#### 记录每个数的下标，按值排序后遍历，二分查找判断是否存在$target-a$\n\n## C++代码\n\n```c\nclass Solution\n{\npublic:\n    vector\u003cint\u003e twoSum(vector\u003cint\u003e \u0026nums, int target)\n    {\n        vector\u003cpair\u003cint, int\u003e\u003e p(nums.size());\n        for (int i = 0; i \u003c nums.size(); ++i)\n        {\n            p[i].first = nums[i];\n            p[i].second = i;\n        }\n        sort(p.begin(), p.end());\n        for (auto a = p.begin(); a != p.end(); ++a)\n        {\n            auto t = make_pair(target - a-\u003efirst, 0);//second随便填，因为只关心first\n            auto b = lower_bound(p.begin(), p.end(), t, [](const pair\u003cint, int\u003e \u0026x, const pair\u003cint, int\u003e \u0026y)\n            {\n                return x.first \u003c y.first;\n            });//lambda表达式传入cmp函数自定义二分查找的规则(只比较first)。因为库函数lowerbound是用小于号进行判断的，所以传入一个自定义的小于规则\n            if (b != p.end() \u0026\u0026 a != b \u0026\u0026 a-\u003efirst + b-\u003efirst == target)\n            {//除了要判断有没有找到(b != p.end()), 还需要注意ab不能为同一个数\n                return vector\u003cint\u003e{a-\u003esecond, b-\u003esecond};\n            }\n        }\n        return vector\u003cint\u003e{-1, -1};\n    }\n};\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200706163947755.png)\n### Python代码\n\n```python\nclass Solution:\n    def binary_search(self, p, target):\n        l, r = 0, len(p) - 1\n        while l \u003c r:\n            m = l + r \u003e\u003e 1\n            if p[m][0] \u003e= target:\n                r = m\n            else:\n                l = m + 1\n        return l\n\n    def twoSum(self, nums: List[int], target: int) -\u003e List[int]:\n        p = [(v, i) for i, v in enumerate(nums)]\n        p.sort(key=lambda x: x[0])\n        for i, v in enumerate(p):\n            j = self.binary_search(p, target - v[0])\n            if i != j and v[0] + p[j][0] == target:\n                return [v[1], p[j][1]]\n        return [-1, -1]\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200706164010861.png)\n\n## 2、哈希表\n\n#### 只遍历一遍，用哈希表记录已经遍历过的数的值和下标。每遍历到一个新的数$x$，用哈希表查一下$target-x$是否存在\n\n```c\nclass Solution {\npublic:\n    vector\u003cint\u003e twoSum(vector\u003cint\u003e\u0026 nums, int target) {\n        unordered_map\u003cint, int\u003e vis;\n        for (int i = 0; i \u003c nums.size(); ++i)\n        {\n            if (vis.count(target - nums[i]))\n                return vector\u003cint\u003e{vis[target - nums[i]], i};\n            vis[nums[i]] = i;\n        }\n        return vector\u003cint\u003e{-1, -1};\n    }\n};\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200706164035286.png)\n```python\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -\u003e List[int]:\n        vis = {}\n        for i, v in enumerate(nums):\n            if target - v in vis:\n                return [vis[target - v], i]\n            vis[v] = i\n        return [-1, -1]\n```\n\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200706164056975.png)\n\n用哈希表省去了构造value, pos的pair和排序的过程，无论是代码长度还是效率都略优。\n\n",
        "Title": "LeetCode 1.两数之和",
        "CreateTime": 1594025083000,
        "FormatTime": "2020.07.06",
        "Categories": "Leetcode",
        "Tags": [
            ""
        ],
        "EditorType": "markdown"
    },
    {
        "Content": "## 总体思路\n\u003cstrong\u003eHTML中用一个canvas显示游戏画面和一个p标签显示当前分数\n通过JavaScript修改canvas\n\u003cstrong\u003e\n\n#### HTML部分\n非常简约的界面。\n```html\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003ctitle\u003epython\u003c/title\u003e\n    \u003clink href=\"python.css\" type=\"text/css\" rel=\"stylesheet\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cdiv id=\"mpContainer\"\u003e\n    \u003ccanvas id=\"map\" width=\"480\" height=\"480\"\u003e\u003c/canvas\u003e\n\u003c/div\u003e\n\u003cdiv id=\"scoreContainer\"\u003e\u003cstrong id=\"score\"\u003escore: 0\u003c/strong\u003e\u003c/div\u003e\n\u003cscript type=\"text/javascript\" src=\"init.js\"\u003e\u003c/script\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200106232116960.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FwYWxlXzg=,size_16,color_FFFFFF,t_70)\n#### JavaScript部分\n我是用TypeScript写的，下面的代码只放TypeScript\n##### 地图绘制\n使用DOM提供的绘制矩形的函数在canvas上涂色\n\n```js\nlet c: any = document.getElementById(\"map\");\nlet cxt: any = c.getContext(\"2d\");\ncxt.fillStyle = \"rgb(0,0,0)\";\ncxt.fillRect(x, y, siz, siz);\n```\n其中x，y是矩形左上角的坐标，矩形大小为siz*siz\n为了方便后面的使用， 我自己稍微又封装了一下，后面调用setColor直接修改坐标x, y处的颜色为color\n\n```js\nconst colorTable: string[] = [\"rgb(240,240,240)\", \"rgb(0,0,0)\", \n\"rgb(0,255,0)\", \"rgb(255,0,0)\", \"rgb(255,255,0)\"];\n\nenum Color {\n    white,\n    black,\n    green,\n    red,\n    yellow\n}\n\nfunction setColor(cxt: any, color: Color, x: number, y: number, siz: number, mp: Color[][]): void {\n    cxt.fillStyle = colorTable[color];\n    cxt.fillRect(x * siz, y * siz, siz, siz);\n    mp[y][x] = color;\n}\n```\n在我的设计中，一个siz(px)*siz(px)的区域为一格，所以x * siz, y * siz\nmp是一个二维数组，用于记录地图的信息，因为读取canvas上的像素值不太好写，干脆直接记录下来\n为了与网页背景色区分开，white的rgb值略为减小了一点点\n\n#### 初始化地图\nmp数组与canvas都进行初始化，蛇一开始的长度为3格，放置于地图正中，方向向右\n\n```js\nlet c: any = document.getElementById(\"map\");\nlet cxt: any = c.getContext(\"2d\");\nlet w = 24;\nlet h = 24;\nlet mp: Color[][] = [];\nfor (let i = 0; i \u003c h; i++) {\n    mp.push([]);\n    for (let j = 0; j \u003c w; j++) {\n        mp[i].push(Color.white);\n    }\n}\nsetColor(cxt, Color.white, 0, 0, w * size, mp);\nfor (let i = 0; i \u003c h; i++) {\n    if (i == 0 || i == h - 1)\n        for (let j = 0; j \u003c w; j++) {\n            setColor(cxt, Color.black, i, j, size, mp);\n        }\n    else {\n        setColor(cxt, Color.black, i, 0, size, mp);\n        setColor(cxt, Color.black, i, w - 1, size, mp);\n    }\n}\nsetColor(cxt, Color.green, int(w / 2 - 1), int(h / 2), size, mp);\nsetColor(cxt, Color.green, int(w / 2), int(h / 2), size, mp);\nsetColor(cxt, Color.green, int(w / 2 + 1), int(h / 2), size, mp);\ncreateFood(w, h, cxt, mp);\n```\n\n#### 蛇的控制\n蛇每次移动时，地图上只有两个格子可能会变(先不考虑食物)，即头和尾\n蛇每次往前走，产生新的蛇头，擦去上一次的蛇尾\n**特殊情况1**\n蛇头吃到食物，此时不擦去蛇尾\n**特殊情况2**\n新的蛇头与旧的蛇尾重合\n这种情况肯定是不会死的，因为旧的蛇尾会擦除，等价于空地\n但处理的时候很可能会会漏掉这一点，需留意\n\n显然用队列维护蛇的信息最为合适：\n队尾就是蛇头(每次push进新的蛇头)\n队首就是蛇尾(每次pop掉)\n\n仿照STL queue用TypeScript写的队列\n队列不细讲了，会用push和pop就行了\n```js\nclass queue\u003cT\u003e {\n    buf: Array\u003cT\u003e;\n    head: number;\n    tail: number;\n\n    constructor() {\n        this.buf = new Array\u003cT\u003e();\n        for (let i = 0; i \u003c 50; i++) {\n            this.buf.push(null);\n        }\n        this.head = 0;\n        this.tail = 0;\n    }\n\n    empty(): boolean {\n        return this.head == this.tail;\n    }\n\n    front(): T {\n        if (this.empty())\n            return undefined;\n        return this.buf[this.head];\n    }\n\n    back(): T {\n        if (this.empty())\n            return undefined;\n        return this.buf[(this.tail - 1 + this.buf.length) % this.buf.length];\n    }\n\n    push(x: T): void {\n        this.buf[this.tail] = x;\n        if ((this.tail + 1) % this.buf.length == this.head)\n            this.resize();\n        this.tail = (this.tail + 1) % this.buf.length;\n    }\n\n    pop(): T {\n        if (this.empty())\n            return null;\n        let n = this.head;\n        this.head = (this.head + 1) % this.buf.length;\n        return this.buf[n];\n    }\n\n    resize(): void {\n        let oldN = this.buf.length;\n        let n = Math.floor(this.buf.length / 2);\n        for (let i = 0; i \u003c n; i++) {\n            this.buf.push(null);\n        }\n        for (let i = oldN - 1; i \u003e= this.head; i--) {\n            this.buf[i + n] = this.buf[i];\n        }\n        this.head += n;\n    }\n}\n```\n蛇的每一个点只需要横纵坐标信息\n\n```js\nclass pair\u003cT, Y\u003e {\n    x: T;\n    y: Y;\n\n    constructor(x: T = null, y: Y = null) {\n        this.x = x;\n        this.y = y;\n    }\n}\n```\n表示方向的枚举类型\n\n```js\nenum Dir {\n    up,\n    down,\n    left,\n    right\n}\n```\n因为当接收到的命令与蛇当前运动方向完全相反时，什么都不做\n到时判断cmdDir^snakeDir是否为0即可\n\n**Snake类的设计**\n记录当前运动方向\n记录蛇中的每一个点(用上文实现的队列)\n地图的宽、高\n一个boolean变量记录是否吃到食物\n\n具体函数见注释\n\n```js\nclass Snake {\n    private w: number;\n    private h: number;\n    private snake: queue\u003cpair\u003cnumber, number\u003e\u003e;\n    private nowDir: Dir;\n    private big: boolean;\n    static d: pair\u003cnumber, number\u003e[] = [new pair\u003cnumber, number\u003e(0, -1), new pair\u003cnumber, number\u003e(0, 1), new pair\u003cnumber, number\u003e(-1, 0), new pair\u003cnumber, number\u003e(1, 0)];\n\n    constructor(w: number, h: number) {\n        this.w = w;\n        this.h = h;\n        this.snake = new queue\u003cpair\u003cnumber, number\u003e\u003e();\n        this.big = false;\n        this.nowDir = Dir.right;//默认一开始往右走\n        this.snake.push(new pair\u003cnumber, number\u003e(int(w / 2) - 1, int(h / 2)));//蛇初始的三个点\n        this.snake.push(new pair\u003cnumber, number\u003e(int(w / 2), int(h / 2)));\n        this.snake.push(new pair\u003cnumber, number\u003e(int(w / 2) + 1, int(h / 2)));\n    }\n\n    command(dir: Dir): void {//此函数接收控制信息\n        if ((dir ^ this.nowDir) == 1)//命令与蛇的方向相反\n            dir = this.nowDir;\n        let head = this.snake.back();//通过dir和旧的蛇头产生新的蛇头\n        this.snake.push(new pair\u003cnumber, number\u003e(head.x + Snake.d[dir].x, head.y + Snake.d[dir].y));\n        this.nowDir = dir;\n    }\n\n    setBig(flag: boolean): void {//蛇吃到食物时调用此函数\n        this.big = flag;\n    }\n\n    getHead(): pair\u003cnumber, number\u003e {//返回蛇头坐标供绘图\n        return this.snake.back();\n    }\n\n    getTail(): pair\u003cnumber, number\u003e {//返回蛇尾坐标供绘图\n        if (this.big) {//吃到了食物\n            this.big = false;\n            return new pair\u003cnumber, number\u003e(-1, -1);//返回一个不存在的坐标，因为此时不需要擦掉蛇尾\n        }\n        let t = this.snake.front();\n        this.snake.pop();//没吃到食物则pop掉\n        return t;\n    }\n}\n```\n#### 食物的生成\n逻辑很简单，随机xy坐标，判断是不是空地，是则涂红，不是则重新随机\n但很坑的地方就是JS本身的Math.Random不支持设置随机种子，每次生成的食物序列都是一样的\n于是手写了随机数生成器。\n\n```js\nlet seed = new Date().getTime();\n\nfunction rnd(): number {\n    seed = (seed * 9301 + 49297) % 233280;\n    return seed / (233280.0);\n}\n\nfunction rand(mod: number) {\n    return Math.floor(rnd() * mod);\n}\n```\n然后就可以愉快地随机生成食物了\n\n```js\nfunction createFood(w: number, h: number, cxt: any, mp: Color[][]): void {\n    let x = rand(w);\n    let y = rand(h);\n    while (mp[y][x] != Color.white) {\n        x = rand(w);\n        y = rand(h);\n        c = cxt.getImageData(x, y, 1, 1).data;\n    }\n    setColor(cxt, Color.red, x, y, size, mp);\n}\n```\n\n#### 蛇的移动\n首先需要接收键盘信息\ndir是一个全局变量\n```js\ndocument.onkeydown = function (event) {\n    let e: string = event.key;\n    switch (e) {\n        case \"ArrowLeft\":\n            dir = Dir.left;\n            break;\n        case \"ArrowRight\":\n            dir = Dir.right;\n            break;\n        case \"ArrowUp\":\n            dir = Dir.up;\n            break;\n        case \"ArrowDown\":\n            dir = Dir.down;\n            break;\n        default:\n    }\n    move();//接收信息后马上移动\n};\n```\n然后根据接收到的信息更新蛇的信息并绘图即可\n\n```js\nfunction move(): void {\n    snake.command(dir);\n    head = snake.getHead();\n    tail = snake.getTail();\n    if (head.x == tail.x \u0026\u0026 head.y == tail.y)//新头等于旧尾，直接return\n        return;\n    if (mp[head.y][head.x] == Color.green || mp[head.y][head.x] == Color.black) {\n        alert(\"Game Over!\");//撞墙或自己，游戏结束\n        clearInterval(id);\n        location.reload();\n        return;\n    }\n    if (mp[head.y][head.x] == Color.red) {\n        document.getElementById(\"score\").innerHTML = \"score: \" + ++score;//更新分数\n        createFood(w, h, cxt, mp);\n        snake.setBig(true);\n    }\n    setColor(cxt, Color.green, head.x, head.y, size, mp);//绘制新蛇头\n    if (tail.x == -1)//吃到食物则不擦除蛇尾\n        return;\n    setColor(cxt, Color.white, tail.x, tail.y, size, mp);//擦除旧蛇尾\n}\n```\n\nmove函数需要周期性执行，于是使用setInterval\n\n```js\nlet id = setInterval(move, 180);//每180ms执行一次move\n//记录id，游戏结束时关闭\n```\n可以注意到因为每次敲击键盘后我都执行了move函数，所以按得很快的时候蛇也会走得很快，而不是匀速运动\n如果不这样做，蛇可以匀速运动，但你不能做到快速响应每一次键盘命令。这个问题我还没有想到更好的解决方法。\n下面是完整的TS代码：\n\n```js\nfunction int(x: number): number {\n    return Math.floor(x);\n}\n\nclass queue\u003cT\u003e {\n    buf: Array\u003cT\u003e;\n    head: number;\n    tail: number;\n\n    constructor() {\n        this.buf = new Array\u003cT\u003e();\n        for (let i = 0; i \u003c 50; i++) {\n            this.buf.push(null);\n        }\n        this.head = 0;\n        this.tail = 0;\n    }\n\n    empty(): boolean {\n        return this.head == this.tail;\n    }\n\n    front(): T {\n        if (this.empty())\n            return undefined;\n        return this.buf[this.head];\n    }\n\n    back(): T {\n        if (this.empty())\n            return undefined;\n        return this.buf[(this.tail - 1 + this.buf.length) % this.buf.length];\n    }\n\n    push(x: T): void {\n        this.buf[this.tail] = x;\n        if ((this.tail + 1) % this.buf.length == this.head)\n            this.resize();\n        this.tail = (this.tail + 1) % this.buf.length;\n    }\n\n    pop(): T {\n        if (this.empty())\n            return null;\n        let n = this.head;\n        this.head = (this.head + 1) % this.buf.length;\n        return this.buf[n];\n    }\n\n    resize(): void {\n        let oldN = this.buf.length;\n        let n = Math.floor(this.buf.length / 2);\n        for (let i = 0; i \u003c n; i++) {\n            this.buf.push(null);\n        }\n        for (let i = oldN - 1; i \u003e= this.head; i--) {\n            this.buf[i + n] = this.buf[i];\n        }\n        this.head += n;\n    }\n}\n\nclass pair\u003cT, Y\u003e {\n    x: T;\n    y: Y;\n\n    constructor(x: T = null, y: Y = null) {\n        this.x = x;\n        this.y = y;\n    }\n}\n\nenum Dir {\n    up,\n    down,\n    left,\n    right\n}\n\nclass Snake {\n    private w: number;\n    private h: number;\n    private snake: queue\u003cpair\u003cnumber, number\u003e\u003e;\n    private nowDir: Dir;\n    private big: boolean;\n    static d: pair\u003cnumber, number\u003e[] = [new pair\u003cnumber, number\u003e(0, -1), new pair\u003cnumber, number\u003e(0, 1), new pair\u003cnumber, number\u003e(-1, 0), new pair\u003cnumber, number\u003e(1, 0)];\n\n    constructor(w: number, h: number) {\n        this.w = w;\n        this.h = h;\n        this.snake = new queue\u003cpair\u003cnumber, number\u003e\u003e();\n        this.big = false;\n        this.nowDir = Dir.right;\n        this.snake.push(new pair\u003cnumber, number\u003e(int(w / 2) - 1, int(h / 2)));\n        this.snake.push(new pair\u003cnumber, number\u003e(int(w / 2), int(h / 2)));\n        this.snake.push(new pair\u003cnumber, number\u003e(int(w / 2) + 1, int(h / 2)));\n    }\n\n    command(dir: Dir): void {\n        if ((dir ^ this.nowDir) == 1)\n            dir = this.nowDir;\n        let head = this.snake.back();\n        this.snake.push(new pair\u003cnumber, number\u003e(head.x + Snake.d[dir].x, head.y + Snake.d[dir].y));\n        this.nowDir = dir;\n    }\n\n    setBig(flag: boolean): void {\n        this.big = flag;\n    }\n\n    getHead(): pair\u003cnumber, number\u003e {\n        return this.snake.back();\n    }\n\n    getTail(): pair\u003cnumber, number\u003e {\n        if (this.big) {\n            this.big = false;\n            return new pair\u003cnumber, number\u003e(-1, -1);\n        }\n        let t = this.snake.front();\n        this.snake.pop();\n        return t;\n    }\n}\n\nconst colorTable: string[] = [\"rgb(240,240,240)\",\n    \"rgb(0,0,0)\", \"rgb(0,255,0)\", \"rgb(255,0,0)\", \"rgb(255,255,0)\"];\n\nenum Color {\n    white,\n    black,\n    green,\n    red,\n    yellow\n}\n\nconst size: number = 20;\n\nfunction setColor(cxt: any, color: Color, x: number, y: number, siz: number, mp: Color[][]): void {\n    cxt.fillStyle = colorTable[color];\n    cxt.fillRect(x * siz, y * siz, siz, siz);\n    mp[y][x] = color;\n}\n\nlet seed = new Date().getTime();\n\nfunction rnd(): number {\n    seed = (seed * 9301 + 49297) % 233280;\n    return seed / (233280.0);\n}\n\nfunction rand(mod: number) {\n    return Math.floor(rnd() * mod);\n}\n\nfunction createFood(w: number, h: number, cxt: any, mp: Color[][]): void {\n    let x = rand(w);\n    let y = rand(h);\n    while (mp[y][x] != Color.white) {\n        x = rand(w);\n        y = rand(h);\n        c = cxt.getImageData(x, y, 1, 1).data;\n    }\n    setColor(cxt, Color.red, x, y, size, mp);\n}\n\nlet c: any = document.getElementById(\"map\");\nlet cxt: any = c.getContext(\"2d\");\nlet w = 24;\nlet h = 24;\nlet mp: Color[][] = [];\nfor (let i = 0; i \u003c h; i++) {\n    mp.push([]);\n    for (let j = 0; j \u003c w; j++) {\n        mp[i].push(Color.white);\n    }\n}\nsetColor(cxt, Color.white, 0, 0, w * size, mp);\nfor (let i = 0; i \u003c h; i++) {\n    if (i == 0 || i == h - 1)\n        for (let j = 0; j \u003c w; j++) {\n            setColor(cxt, Color.black, i, j, size, mp);\n        }\n    else {\n        setColor(cxt, Color.black, i, 0, size, mp);\n        setColor(cxt, Color.black, i, w - 1, size, mp);\n    }\n}\nsetColor(cxt, Color.green, int(w / 2 - 1), int(h / 2), size, mp);\nsetColor(cxt, Color.green, int(w / 2), int(h / 2), size, mp);\nsetColor(cxt, Color.green, int(w / 2 + 1), int(h / 2), size, mp);\ncreateFood(w, h, cxt, mp);\nlet snake = new Snake(w, h);\nlet dir = Dir.right;\nlet head = new pair\u003cnumber, number\u003e();\nlet tail = new pair\u003cnumber, number\u003e();\ndocument.onkeydown = function (event) {\n    let e: string = event.key;\n    switch (e) {\n        case \"ArrowLeft\":\n            dir = Dir.left;\n            break;\n        case \"ArrowRight\":\n            dir = Dir.right;\n            break;\n        case \"ArrowUp\":\n            dir = Dir.up;\n            break;\n        case \"ArrowDown\":\n            dir = Dir.down;\n            break;\n        default:\n    }\n    move();\n};\nlet score = 0;\n\nfunction move(): void {\n    snake.command(dir);\n    head = snake.getHead();\n    tail = snake.getTail();\n    if (head.x == tail.x \u0026\u0026 head.y == tail.y)\n        return;\n    if (mp[head.y][head.x] == Color.green || mp[head.y][head.x] == Color.black) {\n        alert(\"Game Over!\");\n        clearInterval(id);\n        location.reload();\n        return;\n    }\n    if (mp[head.y][head.x] == Color.red) {\n        document.getElementById(\"score\").innerHTML = \"score: \" + ++score;\n        createFood(w, h, cxt, mp);\n        snake.setBig(true);\n    }\n    setColor(cxt, Color.green, head.x, head.y, size, mp);\n    if (tail.x == -1)\n        return;\n    setColor(cxt, Color.white, tail.x, tail.y, size, mp);\n}\n\nlet id = setInterval(move, 180);\n\n```\n也附一份编译后的js代码：\n\n```js\nfunction int(x) {\n    return Math.floor(x);\n}\nvar queue = /** @class */ (function () {\n    function queue() {\n        this.buf = new Array();\n        for (var i = 0; i \u003c 50; i++) {\n            this.buf.push(null);\n        }\n        this.head = 0;\n        this.tail = 0;\n    }\n    queue.prototype.empty = function () {\n        return this.head == this.tail;\n    };\n    queue.prototype.front = function () {\n        if (this.empty())\n            return undefined;\n        return this.buf[this.head];\n    };\n    queue.prototype.back = function () {\n        if (this.empty())\n            return undefined;\n        return this.buf[(this.tail - 1 + this.buf.length) % this.buf.length];\n    };\n    queue.prototype.push = function (x) {\n        this.buf[this.tail] = x;\n        if ((this.tail + 1) % this.buf.length == this.head)\n            this.resize();\n        this.tail = (this.tail + 1) % this.buf.length;\n    };\n    queue.prototype.pop = function () {\n        if (this.empty())\n            return null;\n        var n = this.head;\n        this.head = (this.head + 1) % this.buf.length;\n        return this.buf[n];\n    };\n    queue.prototype.resize = function () {\n        var oldN = this.buf.length;\n        var n = Math.floor(this.buf.length / 2);\n        for (var i = 0; i \u003c n; i++) {\n            this.buf.push(null);\n        }\n        for (var i = oldN - 1; i \u003e= this.head; i--) {\n            this.buf[i + n] = this.buf[i];\n        }\n        this.head += n;\n    };\n    return queue;\n}());\nvar pair = /** @class */ (function () {\n    function pair(x, y) {\n        if (x === void 0) { x = null; }\n        if (y === void 0) { y = null; }\n        this.x = x;\n        this.y = y;\n    }\n    return pair;\n}());\nvar Dir;\n(function (Dir) {\n    Dir[Dir[\"up\"] = 0] = \"up\";\n    Dir[Dir[\"down\"] = 1] = \"down\";\n    Dir[Dir[\"left\"] = 2] = \"left\";\n    Dir[Dir[\"right\"] = 3] = \"right\";\n})(Dir || (Dir = {}));\nvar Snake = /** @class */ (function () {\n    function Snake(w, h) {\n        this.w = w;\n        this.h = h;\n        this.snake = new queue();\n        this.big = false;\n        this.nowDir = Dir.right;\n        this.snake.push(new pair(int(w / 2) - 1, int(h / 2)));\n        this.snake.push(new pair(int(w / 2), int(h / 2)));\n        this.snake.push(new pair(int(w / 2) + 1, int(h / 2)));\n    }\n    Snake.prototype.command = function (dir) {\n        if ((dir ^ this.nowDir) == 1)\n            dir = this.nowDir;\n        var head = this.snake.back();\n        this.snake.push(new pair(head.x + Snake.d[dir].x, head.y + Snake.d[dir].y));\n        this.nowDir = dir;\n    };\n    Snake.prototype.setBig = function (flag) {\n        this.big = flag;\n    };\n    Snake.prototype.getHead = function () {\n        return this.snake.back();\n    };\n    Snake.prototype.getTail = function () {\n        if (this.big) {\n            this.big = false;\n            return new pair(-1, -1);\n        }\n        var t = this.snake.front();\n        this.snake.pop();\n        return t;\n    };\n    Snake.d = [new pair(0, -1), new pair(0, 1), new pair(-1, 0), new pair(1, 0)];\n    return Snake;\n}());\nvar colorTable = [\"rgb(240,240,240)\",\n    \"rgb(0,0,0)\", \"rgb(0,255,0)\", \"rgb(255,0,0)\", \"rgb(255,255,0)\"];\nvar Color;\n(function (Color) {\n    Color[Color[\"white\"] = 0] = \"white\";\n    Color[Color[\"black\"] = 1] = \"black\";\n    Color[Color[\"green\"] = 2] = \"green\";\n    Color[Color[\"red\"] = 3] = \"red\";\n    Color[Color[\"yellow\"] = 4] = \"yellow\";\n})(Color || (Color = {}));\nvar size = 20;\nfunction setColor(cxt, color, x, y, siz, mp) {\n    cxt.fillStyle = colorTable[color];\n    cxt.fillRect(x * siz, y * siz, siz, siz);\n    mp[y][x] = color;\n}\nvar seed = new Date().getTime();\nfunction rnd() {\n    seed = (seed * 9301 + 49297) % 233280;\n    return seed / (233280.0);\n}\nfunction rand(mod) {\n    return Math.floor(rnd() * mod);\n}\nfunction createFood(w, h, cxt, mp) {\n    var x = rand(w);\n    var y = rand(h);\n    while (mp[y][x] != Color.white) {\n        x = rand(w);\n        y = rand(h);\n        c = cxt.getImageData(x, y, 1, 1).data;\n    }\n    setColor(cxt, Color.red, x, y, size, mp);\n}\nvar c = document.getElementById(\"map\");\nvar cxt = c.getContext(\"2d\");\nvar w = 24;\nvar h = 24;\nvar mp = [];\nfor (var i = 0; i \u003c h; i++) {\n    mp.push([]);\n    for (var j = 0; j \u003c w; j++) {\n        mp[i].push(Color.white);\n    }\n}\nsetColor(cxt, Color.white, 0, 0, w * size, mp);\nfor (var i = 0; i \u003c h; i++) {\n    if (i == 0 || i == h - 1)\n        for (var j = 0; j \u003c w; j++) {\n            setColor(cxt, Color.black, i, j, size, mp);\n        }\n    else {\n        setColor(cxt, Color.black, i, 0, size, mp);\n        setColor(cxt, Color.black, i, w - 1, size, mp);\n    }\n}\nsetColor(cxt, Color.green, int(w / 2 - 1), int(h / 2), size, mp);\nsetColor(cxt, Color.green, int(w / 2), int(h / 2), size, mp);\nsetColor(cxt, Color.green, int(w / 2 + 1), int(h / 2), size, mp);\ncreateFood(w, h, cxt, mp);\nvar snake = new Snake(w, h);\nvar dir = Dir.right;\nvar head = new pair();\nvar tail = new pair();\ndocument.onkeydown = function (event) {\n    var e = event.key;\n    switch (e) {\n        case \"ArrowLeft\":\n            dir = Dir.left;\n            break;\n        case \"ArrowRight\":\n            dir = Dir.right;\n            break;\n        case \"ArrowUp\":\n            dir = Dir.up;\n            break;\n        case \"ArrowDown\":\n            dir = Dir.down;\n            break;\n        default:\n    }\n    move();\n};\nvar score = 0;\nfunction move() {\n    snake.command(dir);\n    head = snake.getHead();\n    tail = snake.getTail();\n    if (head.x == tail.x \u0026\u0026 head.y == tail.y)\n        return;\n    if (mp[head.y][head.x] == Color.green || mp[head.y][head.x] == Color.black) {\n        alert(\"Game Over!\");\n        clearInterval(id);\n        location.reload();\n        return;\n    }\n    if (mp[head.y][head.x] == Color.red) {\n        document.getElementById(\"score\").innerHTML = \"score: \" + ++score;\n        createFood(w, h, cxt, mp);\n        snake.setBig(true);\n    }\n    setColor(cxt, Color.green, head.x, head.y, size, mp);\n    if (tail.x == -1)\n        return;\n    setColor(cxt, Color.white, tail.x, tail.y, size, mp);\n}\nvar id = setInterval(move, 180);\n\n```\n以及css：\n\n```css\n#scoreContainer {\n    float: left;\n    text-align: left;\n}\n#mpContainer {\n    text-align: right;\n    width: 70%;\n    float: left;\n    margin: 0;\n}\n#score {\n    color: coral;\n    text-align: left;\n}\nbody {\n    text-align: left;\n}\n```\n\n\n",
        "Title": "TypeScript(JavaScript)实现贪吃蛇小游戏(超详细)",
        "CreateTime": 1578404910000,
        "FormatTime": "2020.01.07",
        "Categories": "杂",
        "Tags": [
            ""
        ],
        "EditorType": "markdown"
    },
    {
        "Content": "### 1、安装vscode\n略\n### 2、下载vscode中文插件\n左侧最下面商店按钮中搜索chinese，install\n重启vscode后界面变为中文\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20191127203716459.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FwYWxlXzg=,size_16,color_FFFFFF,t_70)\n### 3、安装LaTeX Workshop和LaTeX language support插件\n商店搜索LaTeX，第一个和第二个\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20191127203700526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FwYWxlXzg=,size_16,color_FFFFFF,t_70)\n装完重启vscode\n### 4、解压texlive.iso, 双击install-tl-advanced.bat安装\n[texlive.iso下载链接](https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/Images/)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20191127203746789.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FwYWxlXzg=,size_16,color_FFFFFF,t_70)\n大约40min后安装结束\n安装路径为X，将X/bin/win32加入环境变量\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20191127203849941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FwYWxlXzg=,size_16,color_FFFFFF,t_70)\n### 5、使用\n新建一个文件夹，新建文件，保存为xxx.tex\n编写后按右上角的预览图标预览\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20191127203924135.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FwYWxlXzg=,size_16,color_FFFFFF,t_70)\n测试代码\n\n```\n\\documentclass{article}\n\\begin{document}\nhello,world\n\\end{document}\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20191127203936937.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FwYWxlXzg=,size_16,color_FFFFFF,t_70)\n\n\n",
        "Title": "用VSCode写LaTeX",
        "CreateTime": 1574858501000,
        "FormatTime": "2019.11.27",
        "Categories": "杂",
        "Tags": [
            ""
        ],
        "EditorType": "markdown"
    },
    {
        "Content": "//2020.12.15更新\n发现了更更好用的自动补全插件(Tabnine)\n# 后面的操作都是花里胡哨的。做完1、2、5就行了。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20201215150622887.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FwYWxlXzg=,size_16,color_FFFFFF,t_70)直接安装Tabnine即可使用\n//2020.03.20更新\n~~发现了更好用的自动补全插件(clang)。\n先装个[LLVM](https://github.com/llvm/llvm-project/releases/tag/llvmorg-9.0.1)\n把LLVM/bin添加到环境变量\n安装vscode-clangd插件~~ \n\n### 1、商店中搜索C++，下载(如下图)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20191111112538543.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FwYWxlXzg=,size_16,color_FFFFFF,t_70)\n### 2、商店下载Code Runner插件 \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20191111112656381.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FwYWxlXzg=,size_16,color_FFFFFF,t_70)\nCode Runner插件通过终端编译运行代码，因此需要将g++所在的目录添加到环境变量中。\n不懂请搜索“mingw添加到环境变量”。一般DevCpp和Codeblocks的目录下有一个版本较老的mingw\ncmd下输入g++ -v检测是否添加成功\n### 3、新建一个文件夹\n在文件夹中创建c_cpp_properties.json，将以下代码写入\n\n```json\n{\n    \"configurations\": [\n        {\n            \"name\": \"Win32\",\n            \"includePath\": [\n                \"${workspaceFolder}/**\",\n                \"F:/Dev-Cpp/MinGW64/lib/gcc/x86_64-w64-mingw32/4.8.1/include\"\n            ],\n            \"defines\": [\n                \"_DEBUG\",\n                \"UNICODE\",\n                \"_UNICODE\"\n            ],\n            \"windowsSdkVersion\": \"10.0.17763.0\",\n            \"cStandard\": \"c11\",\n            \"cppStandard\": \"c++17\",\n            \"intelliSenseMode\": \"gcc-x64\"\n        }\n    ],\n    \"version\": 4\n}\n```\n关键点是includePath的第二行：写入你自己的mingw对应的目录\n到这一步已经可以通过右上角的小箭头编译运行C++了\n但C++11的语法还不能用，因为编译选项在Code Runner的配置文件中\n### 5、修改Code Runner配置文件\nCtrl + Shift + P打开settings.json\n输入code-runner，会补全出一大串东西\n将cpp的那行修改，加上c++14的编译选项-std=c++14：\n\n```json\n\"cpp\": \"clear cd $dir \u0026\u0026 g++ $fileName -std=c++14 -o $fileNameWithoutExt \u0026\u0026 $dir$fileNameWithoutExt\"\n```\n其中clear是为了在编译前清屏，看起来更清爽\n\n### 6、创建stdc++.h文件\n平时常用#include \u003cbits/stdc++.h\u003e，但现在并不能用(不知道为啥)\n解决方法就是在MinGW64\\lib\\gcc\\x86_64-w64-mingw32\\4.8.1\\include\\c++\\bits目录下创建stdc++.h文件\n将以下内容复制进去\n```c\n// C++ includes used for precompiling -*- C++ -*-\n\n// Copyright (C) 2003-2013 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// \u003chttp://www.gnu.org/licenses/\u003e.\n\n/** @file stdc++.h\n *  This is an implementation file for a precompiled header.\n */\n\n// 17.4.1.2 Headers\n\n// C\n#ifndef _GLIBCXX_NO_ASSERT\n#include \u003ccassert\u003e\n#endif\n#include \u003ccctype\u003e\n#include \u003ccerrno\u003e\n#include \u003ccfloat\u003e\n#include \u003cciso646\u003e\n#include \u003cclimits\u003e\n#include \u003cclocale\u003e\n#include \u003ccmath\u003e\n#include \u003ccsetjmp\u003e\n#include \u003ccsignal\u003e\n#include \u003ccstdarg\u003e\n#include \u003ccstddef\u003e\n#include \u003ccstdio\u003e\n#include \u003ccstdlib\u003e\n#include \u003ccstring\u003e\n#include \u003cctime\u003e\n\n#if __cplusplus \u003e= 201103L\n#include \u003cccomplex\u003e\n#include \u003ccfenv\u003e\n#include \u003ccinttypes\u003e\n#include \u003ccstdalign\u003e\n#include \u003ccstdbool\u003e\n#include \u003ccstdint\u003e\n#include \u003cctgmath\u003e\n#include \u003ccwchar\u003e\n#include \u003ccwctype\u003e\n#endif\n\n// C++\n#include \u003calgorithm\u003e\n#include \u003cbitset\u003e\n#include \u003ccomplex\u003e\n#include \u003cdeque\u003e\n#include \u003cexception\u003e\n#include \u003cfstream\u003e\n#include \u003cfunctional\u003e\n#include \u003ciomanip\u003e\n#include \u003cios\u003e\n#include \u003ciosfwd\u003e\n#include \u003ciostream\u003e\n#include \u003cistream\u003e\n#include \u003citerator\u003e\n#include \u003climits\u003e\n#include \u003clist\u003e\n#include \u003clocale\u003e\n#include \u003cmap\u003e\n#include \u003cmemory\u003e\n#include \u003cnew\u003e\n#include \u003cnumeric\u003e\n#include \u003costream\u003e\n#include \u003cqueue\u003e\n#include \u003cset\u003e\n#include \u003csstream\u003e\n#include \u003cstack\u003e\n#include \u003cstdexcept\u003e\n#include \u003cstreambuf\u003e\n#include \u003cstring\u003e\n#include \u003ctypeinfo\u003e\n#include \u003cutility\u003e\n#include \u003cvalarray\u003e\n#include \u003cvector\u003e\n\n#if __cplusplus \u003e= 201103L\n#include \u003carray\u003e\n#include \u003catomic\u003e\n#include \u003cchrono\u003e\n#include \u003ccondition_variable\u003e\n#include \u003cforward_list\u003e\n#include \u003cfuture\u003e\n#include \u003cinitializer_list\u003e\n#include \u003cmutex\u003e\n#include \u003crandom\u003e\n#include \u003cratio\u003e\n#include \u003cregex\u003e\n#include \u003cscoped_allocator\u003e\n#include \u003csystem_error\u003e\n#include \u003cthread\u003e\n#include \u003ctuple\u003e\n#include \u003ctype_traits\u003e\n#include \u003ctypeindex\u003e\n#include \u003cunordered_map\u003e\n#include \u003cunordered_set\u003e\n#endif\n\n```\n\n### 8、下载idea风格键盘映射\n用惯了jetbrains家IDE的话直接下载即可\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20191111114013198.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FwYWxlXzg=,size_16,color_FFFFFF,t_70)\n### 9、下载CLion主题\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20191111114043748.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FwYWxlXzg=,size_16,color_FFFFFF,t_70)\n完美\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20191111114354409.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FwYWxlXzg=,size_16,color_FFFFFF,t_70)\n",
        "Title": "VSCode 配置C++环境并调成CLion风格",
        "CreateTime": 1573442768000,
        "FormatTime": "2019.11.11",
        "Categories": "杂",
        "Tags": [
            ""
        ],
        "EditorType": "markdown"
    },
    {
        "Content": "这学期学数图，作业需要做界面，于是开始学习Qt。\n# QRgb\nQt中，QRgb是unsigned int的别名\nQt中用一个unsigned int存储像素值，格式为0xFFRRGGBB\n可以使用$qRgb(int r, int g, int b)$函数来方便地构造像素值\n\n```c\n\tqDebug() \u003c\u003c hex \u003c\u003cqRgb(0, 0, 0) \u003c\u003c '\\n';\n```\n输出为0xff000000\n# QImage\nQImage类有三种修改像素值的方法\n## 0、setPixel()\n函数声明：void setPixel(int i, int j, qRgb rgb)\n直接填入行列像素值即可\n但用此函数修改大量像素值的效率必然是极低的\n## 1、scanLine()\n函数声明： unsigned char *scanLine(int i)\ni为行号，从0开始\n返回值为第i行第一个字节的地址\n实际使用时可以把返回值强制类型转换为$qRgb*$，通过qRgb函数进行赋值\n## 2、bits()\n直接返回图像第一个字节的地址\n用法与scanLine类似\n一开始考虑到字节对齐，我是这样写的\n\n```c\n\tQImage img(fileName);\n\tint r = 30, ox = 50, oy = 50;\n\tQRgb *pixs = (QRgb*)img.bits();\n\tint W = (img.width() + 3) / 4 * 4;\n\tpixs[i * W + j] = qRgb(0, 0, 0);\n```\n但输出的图像上的像素位置不对，把W改为img.width()后位置正确\n我的猜测:QImage中的像素是按行存储的，并没有存储字节对齐的部分。\n",
        "Title": "Qt5 QImage像素操作",
        "CreateTime": 1570259278000,
        "FormatTime": "2019.10.05",
        "Categories": "数字图像处理,Qt",
        "Tags": [
            ""
        ],
        "EditorType": "markdown"
    },
    {
        "Content": "类的格式按照bmp的文件头、信息头、调色板和数据域写好即可\n因为图片是按字节读的，所以要强制让编译器不对结构体进行字节对齐，否则会出错\n因为bmp格式规定存储时每行的像素数要补齐至4的整数倍，所以读入和写出时要加一些对应的操作\n——————————————————————————————————————————————\n2019.9.6更新\n增加了边缘检测、均值滤波和中值滤波\n详情见注释\n```c\n#include \u003cbits/stdc++.h\u003e\n\n#pragma GCC optimize(3)\nusing namespace std;\n\ntypedef unsigned short w;\ntypedef unsigned int dw;\n\nclass bmp\n{\n#pragma pack(1)//取消编译器的字节对齐\n    struct FileHead\n    {\n        w type;\n        dw size;\n        w reserved1, reserved2;\n        dw offset;\n    } fileHead{};\n\n#pragma pack(1)\n    struct InfoHead\n    {\n        dw size, width, height;\n        w planes; //图像的位面数\n        w bitNum; //每个像素的位数\n        dw compression; //压缩类型\n        dw imgSize; //单位为字节\n        dw xPelsPerMeter, yPelsPerMeter;\n        dw colorNum; //使用的色彩数\n        dw colorImportantNum; //重要的颜色数\n    } infoHead{};\n\n#pragma pack(1)\n    struct Palette\n    {\n        w b, g, r, reversed;\n    } palette{};\n    struct Sum;\n#pragma pack(1)\n\n    struct Pixel\n    {\n        unsigned char b, g, r;//24位位图按照BGR的顺序存放， 32位BGRA\n//        friend ostream \u0026operator\u003c\u003c(ostream \u0026out, const Pixel a)\n//        {\n//            return out \u003c\u003c '[' \u003c\u003c (unsigned) a.b \u003c\u003c ' ' \u003c\u003c (unsigned) a.g \u003c\u003c ' ' \u003c\u003c (unsigned) a.r \u003c\u003c ']';\n//        }\n        Pixel(unsigned char b = 0, unsigned char g = 0, unsigned char r = 0) : b(b), g(g), r(r)\n        {}\n\n        Pixel \u0026operator=(const Sum \u0026a)\n        {\n            b = (unsigned char) a.b;\n            g = (unsigned char) a.g;\n            r = (unsigned char) a.r;\n        }\n\n        bool operator\u003c(const Pixel \u0026a) const\n        {\n            if (b == a.b)\n            {\n                if (g == a.g)\n                    return r \u003c a.r;\n                return g \u003c a.g;\n            }\n            return b \u003c a.b;\n        }\n    };\n\n    struct Sum  //用来维护二维前缀和的结构体\n    {           // 因为pixel的rgb都是1字节，求和会溢出，所以另开一个\n        int b, g, r;\n\n        Sum(int b = 0, int g = 0, int r = 0) : b(b), g(g), r(r)\n        {}\n\n        template\u003ctypename T\u003e\n        //既可以+=Sum， 也可以+=Pixel\n        Sum \u0026operator+=(const T \u0026a)\n        {\n            b += a.b;\n            g += a.g;\n            r += a.r;\n            return *this;\n        }\n\n        Sum operator+(const Sum \u0026a)\n        {\n            return {b + a.b, g + a.g, r + a.r};\n        }\n\n        Sum operator-(const Sum \u0026a)\n        {\n            return {b - a.b, g - a.g, r - a.r};\n        }\n\n        template\u003ctypename T\u003e\n        Sum \u0026operator-=(const T \u0026a)\n        {\n            b -= a.b;\n            g -= a.g;\n            r -= a.r;\n            return *this;\n        }\n\n        Sum \u0026operator/=(const int k)\n        {\n            b /= k;\n            g /= k;\n            r /= k;\n        }\n    };\n\n    inline int pos(int i, int j)\n    {\n        return i * realWidth + j;\n    }\n\n    ifstream in;\n    ofstream out;\n    int realWidth{};\npublic:\n    bmp() = default;\n\n    ~bmp()\n    {\n        delete[] img;\n    }\n\n    unsigned int n{};\n    Pixel *img = nullptr;\n\n    bool open(const string \u0026file)\n    {\n        in.open(file, ios::in | ios::binary);\n        if (!in)\n            return 0 \u0026 puts(\"无法打开文件\");\n        return true;\n    }\n\n    void read()\n    {\n        if (!in)\n        {\n            puts(\"未打开文件\");\n            return;\n        }\n        in.read((char *) \u0026fileHead, sizeof(fileHead));\n        in.read((char *) \u0026infoHead, sizeof(infoHead));\n        realWidth = ((infoHead.width - 1) / 4) * 4 + 4;\n        n = infoHead.height * realWidth;\n        img = new Pixel[infoHead.height * realWidth];\n        in.read((char *) img, sizeof(Pixel) * n);\n        in.close();\n    }\n\n    Pixel \u0026operator[](int id)\n    {\n        return img[id];\n    }\n\n    const InfoHead \u0026getInfoHead() const\n    {\n        return infoHead;\n    }\n\n    const FileHead \u0026getFileHead() const\n    {\n        return fileHead;\n    }\n\n    void write(const string \u0026file)\n    {\n        out.open(file, ios::out | ios::binary);\n        out.write((char *) \u0026fileHead, sizeof(fileHead));\n        out.write((char *) \u0026infoHead, sizeof(infoHead));\n        out.write((char *) img, sizeof(Pixel) * n);\n        out.close();\n    }\n\n    void toGrayImg()\n    {\n        unsigned char val;\n        for (int i = 0; i \u003c n; ++i)\n        {\n            val = 0.587 * img[i].g + 0.299 * img[i].r + 0.114 * img[i].b;\n            img[i] = Pixel(val, val, val);//rgb都设为一样就是灰度图了\n        }\n    }\n\n    void meanFiltering(int k)//k是半径, 如k取2, 求均值的范围为3 * 3\n    {\n        --k;\n        //均值滤波， 对每个大小为(2 * k + 1) * (2 * k + 1)的子矩阵求和再平均，把中心的值改为均值。\n        Sum *dp = new Sum[realWidth * infoHead.height];//这里用了二维前缀和来加速\n#define summ(x1, y1, x2, y2) (dp[pos(x2, y2)]+(x1 \u0026\u0026 y1 ? dp[pos(x1-1, y1-1)] : 0)-(x1 ? dp[pos(x1-1, y2)] : 0)-(y1 ? dp[pos(x2, y1-1)] : 0))\n        for (int i = 0; i \u003c infoHead.height; ++i)//预处理二维前缀和\n        {\n            for (int j = 0; j \u003c infoHead.width; ++j)\n            {\n                dp[pos(i, j)] += img[pos(i, j)];\n                if (i)\n                    dp[pos(i, j)] += dp[pos(i - 1, j)];\n                if (j)\n                    dp[pos(i, j)] += dp[pos(i, j - 1)];\n                if (i \u0026\u0026 j)\n                    dp[pos(i, j)] -= dp[pos(i - 1, j - 1)];\n            }\n        }\n        Sum val;\n        for (int i = 0; i \u003c infoHead.height; ++i)\n        {\n            for (int j = 0; j \u003c infoHead.width; ++j)\n            {\n                if (i \u003c k || j \u003c k || i + k \u003e infoHead.height - 1 || j + k \u003e infoHead.width - 1) continue;\n                val = summ(i - k, j - k, i + k, j + k);\n                val /= (k * 2 + 1) * (k * 2 + 1);\n                img[pos(i, j)] = Pixel((unsigned char) val.b, (unsigned char) val.g, (unsigned char) val.r);\n            }\n        }\n        delete[] dp;\n    }\n\n    Pixel getMedian(int x, int y, int k)\n    {\n        vector\u003cPixel\u003e a;\n        a.clear();\n        for (int i = x - k; i \u003c= x + k; ++i)\n            for (int j = y - k; j \u003c= y + k; ++j)\n                a.push_back(img[pos(i, j)]);\n//        nth_element(a.begin(), a.begin() + ((2 * k + 1) * (2 * k + 1)) / 2, a.end());\n        sort(a.begin(), a.end());\n        return a[((2 * k + 1) * (2 * k + 1)) / 2];\n    }\n\n    void solve()//增加噪声，用于检验中值滤波和均值滤波\n    {\n        for (int i = 0; i \u003c infoHead.height; ++i)\n        {\n            for (int j = 0; j \u003c infoHead.width; ++j)\n            {\n                if (rand() \u003c 1000)\n                    img[pos(i, j)] = Pixel(255, 255, 255);\n            }\n        }\n    }\n\n    void medianFiltering(int k)//k是半径\n    {//中值滤波，用子矩阵的中位数替换中心的值\n        Pixel *IMG = new Pixel[infoHead.height * ((infoHead.width - 1) / 4 * 4 + 4)];\n        --k;\n        for (int i = k; i + k \u003c infoHead.height; ++i)\n        {\n            for (int j = k; j + k \u003c infoHead.width; ++j)\n            {\n                IMG[pos(i, j)] = getMedian(i, j, k);\n            }\n        }\n        for (int i = k; i + k \u003c infoHead.height; ++i)\n        {\n            for (int j = k; j + k \u003c infoHead.width; ++j)\n            {\n                img[pos(i, j)] = IMG[pos(i, j)];\n            }\n        }\n        delete[]IMG;\n    }\n\n    void toEdge()//边缘检测\n    {//采用梯度下降法，对x方向和y方向分别求差分，每个像素处保存一个向量(x, y)， 向量的模小于阈值的像素涂黑，其余涂白\n        int *difR = new int[realWidth * infoHead.height], *difC = new int[realWidth * infoHead.height];\n        for (int i = 1; i \u003c infoHead.height; ++i)\n        {\n            for (int j = 0; j \u003c infoHead.width; ++j)\n            {\n                difR[pos(i, j)] = img[pos(i, j)].b - img[pos(i - 1, j)].b;\n            }\n        }\n\n        for (int i = 0; i \u003c infoHead.height; ++i)\n        {\n            for (int j = 1; j \u003c infoHead.width; ++j)\n            {\n                difC[pos(i, j)] = img[pos(i, j)].b - img[pos(i, j - 1)].b;\n            }\n        }\n\n        for (int i = 0; i \u003c n; ++i)\n        {\n            if (sqrt(difR[i] * difR[i] + difC[i] * difC[i]) \u003c 6)\n                img[i] = Pixel(255, 255, 255);\n            else\n                img[i] = Pixel(0, 0, 0);\n        }\n        delete[] difC;\n        delete[] difR;\n    }\n};\n\n\nint main()\n{\n    bmp pic;\n    pic.open(\"test.bmp\");\n    pic.read();\n//    printf(\"%u %u\\n\", pic.getInfoHead().imgSize, pic.getInfoHead().width);\n//    pic.toGrayImg();\n//    pic.solve();\n//    pic.write(\"g01.bmp\");\n    pic.toEdge();\n\n//    pic.meanFiltering(2);\n    pic.medianFiltering(2);\n    pic.write(\"test.bmp\");\n    return 0;\n}\n```\n原图\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190906233954832.bmp?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FwYWxlXzg=,size_16,color_FFFFFF,t_70)\n直接边缘检测的效果\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190906234034669.bmp?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FwYWxlXzg=,size_16,color_FFFFFF,t_70)\n中值滤波后的效果\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190907005648898.bmp?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FwYWxlXzg=,size_16,color_FFFFFF,t_70)\n",
        "Title": "C++读取bmp格式图片",
        "CreateTime": 1567699162000,
        "FormatTime": "2019.09.06",
        "Categories": "数字图像处理",
        "Tags": [
            ""
        ],
        "EditorType": "markdown"
    },
    {
        "Content": "存个板子\n\n```c\ntypedef long long ll;\n\nstruct base\n{\n    ll a[63];\n    vector\u003cll\u003e p;\n    bool flag;//标记答案集合中是否有0\n    base()\n    {\n        fill(a, a + 63, 0ll);\n        flag = false;\n    }\n\n    void init()\n    {\n        fill(a, a + 63, 0ll);\n        p.clear();\n        flag = false;\n    }\n\n    bool insert(ll val)\n    {\n        ll t = 1ll \u003c\u003c 62;\n        for (int i = 62; ~i; --i)\n        {\n            if (val \u0026 t)\n            {\n                if (!a[i])\n                {\n                    a[i] = val;\n                    return true;\n                }\n                val ^= a[i];\n            }\n            t \u003e\u003e= 1;\n        }\n        flag = true;//能到这里说明能异或出0\n        return false;\n    }\n\n    ll query_max()\n    {\n        ll ans = 0;\n        for (int i = 62; ~i; --i)\n            if ((ans ^ a[i]) \u003e ans)\n                ans ^= a[i];\n        return ans;\n    }\n\n    ll query_min()\n    {\n        for (int i = 0; i \u003c= 62; ++i)\n        {\n            if (a[i])\n                return a[i];\n        }\n        return 0;\n    }\n\n    void rebuild()\n    {\n        ll t;\n        for (int i = 62; ~i; --i)\n        {\n            if (!a[i]) continue;\n            t = 1ll \u003c\u003c i - 1;\n            for (int j = i - 1; ~j; --j, t \u003e\u003e= 1)\n                if (a[i] \u0026 t)\n                    a[i] ^= a[j];\n        }\n\n        for (int i = 0; i \u003c= 62; ++i)\n            if (a[i])\n                p.push_back(a[i]);\n    }\n\n    ll kth(ll k)\n    {\n        if (flag) --k;//答案集合中有0\n        ll ans = 0;\n        if (k \u003e= (1ll \u003c\u003c p.size()))\n            return -1;\n        ll t = 1ll \u003c\u003c 62;\n        for (int i = 62; ~i; --i, t \u003e\u003e= 1)\n            if (k \u0026 t)\n                ans ^= p[i];\n        return ans;\n    }\n\n    inline ll \u0026operator[](int i)\n    {\n        return a[i];\n    }\n\n    base operator+(base \u0026b) const\n    {\n        base ans = *this;\n        for (int i = 0; i \u003c= 62; ++i)\n            if (b[i])\n                ans.insert(b[i]);\n        return ans;\n    }\n};\n```\n\n",
        "Title": "线性基模板",
        "CreateTime": 1564245862000,
        "FormatTime": "2019.07.28",
        "Categories": "数论",
        "Tags": [
            ""
        ],
        "EditorType": "markdown"
    },
    {
        "Content": "之前打题的时候想从一个map中取出值最大的元素\n然后顺手就写了\n\n```c\n    auto mx = max_element(mp.begin(), mp.end());\n```\n然后怎么调都调不出来样例=_=\n\n后来冷静分析了一下\n$map\u003cT1, T2\u003e$中的每个元素都是$pair\u003cT1, T2\u003e$，\n所以$max\\_element$调用的应该是$pair\u003cT1, T2\u003e$的小于号\n即先比较$first$， 再比较$second$\n看了下源码果然如此\n(在stl_pair.h中)\n```c\ntemplate\u003cclass _T1, class _T2\u003e\n    inline _GLIBCXX_CONSTEXPR bool\n    operator\u003c(const pair\u003c_T1, _T2\u003e\u0026 __x, const pair\u003c_T1, _T2\u003e\u0026 __y)\n    { \n    \treturn __x.first \u003c __y.first\n\t     || (!(__y.first \u003c __x.first) \u0026\u0026 __x.second \u003c __y.second); \n\t}\n```\n所以想取出值最大的元素，需要给$max\\_element$传入一个$cmp函数$\n\n```c\n    auto mx = max_element(mp.begin(), mp.end(), [](const pair\u003cint, int\u003e \u0026x, const pair\u003cint, int\u003e \u0026y){\n        return x.second \u003c y.second;\n    });\n```\n传入的$cmp$定义的是$operator\u003c$，注意别写反\n",
        "Title": "C++map(unordered_map) 的小于号",
        "CreateTime": 1562672553000,
        "FormatTime": "2019.07.09",
        "Categories": "C++语法",
        "Tags": [
            ""
        ],
        "EditorType": "markdown"
    },
    {
        "Content": "被问了一天哈夫曼树=_=\n于是迫不得已敲了一个...\n\n首先是读字符，统计文章中n种字符每种出现的次数，然后降序排序。\n然后把出现次数作为权值，建立n个叶子结点。把所有叶子结点插入小根堆中，每次取出两个，用二者权值之和构造新的节点，作为这二者的父亲节点，最后一个点作为根，记录下来。\n虽然树是自底向上建的，但实际使用的时候只用从根往下跑，所以不必记录父节点。\n树建完跑dfs就能得到所有叶子结点的huffman编码(左0右1)，跑到根的时候直接哈希表记录该字符对应的编码，对文章编码时直接调用哈希表即可。\n解码时把01串放到huffman树上跑，跑到根就输出对应字符，并把当前位置重置为root。\n\n```c\n#include \u003cqueue\u003e\n#include \u003ccstdio\u003e\n#include \u003ccstring\u003e\n#include \u003cstring\u003e\n#include \u003calgorithm\u003e\n#include \u003cunordered_map\u003e\n\nusing namespace std;\n\nvoid read(char text[])//读取文件信息,结果保存在text中\n{\n    FILE *fp = fopen(\"test.txt\", \"r\");\n    memset(text, 0, sizeof(text));\n    char ch;\n    int len = 0;\n    fscanf(fp, \"%c\", \u0026ch);\n    while (!feof(fp))\n    {\n        text[len++] = ch;\n        fscanf(fp, \"%c\", \u0026ch);\n    }\n    fclose(fp);\n}\n\ntypedef struct\n{\n    char c;//字符\n    int cnt;//出现次数\n    string code;\n} ch;\n\nbool cmp(ch a, ch b)\n{\n    return a.cnt \u003e b.cnt;//排序规则\n}\n\nch c[300];\n\nint count(char text[])//统计词频并输出\n{\n    int len = strlen(text);\n\n    for (int i = 0; i \u003c 300; ++i)\n        c[i].c = char(i);\n\n    for (int i = 0; i \u003c len; ++i)\n        c[text[i]].cnt++;\n    sort(c, c + 300, cmp);//按出现次数降序排序\n\n    for (int i = 0; i \u003c 300; ++i)\n    {\n        if (c[i].cnt == 0)\n            return i;//返回出现次数大于0的词的数量(即种数)\n        printf(\"%c: %d\\n\", c[i].c, c[i].cnt);\n    }\n}\n\nstruct node\n{\n    int w, id;\n    int lson, rson;\n\n    node()\n    {\n        lson = rson = 0;\n    }\n\n    bool operator\u003c(const node b) const\n    {\n        return w \u003e b.w;\n    }\n};\n\nint buildHuffmanTree(int n, node huffNode[])\n{\n    int id = 0;//下一个未使用过的huffNode数组元素的下标\n    priority_queue\u003cnode\u003e que;\n    for (int i = 0; i \u003c n; ++i)//下标为0~n-1的huffNode是叶子\n    {\n        huffNode[id].w = c[i].cnt;\n        huffNode[id].id = i;\n        que.push(huffNode[id]);\n        ++id;\n    }\n    node a, b;\n    int root;\n    while (true)\n    {\n        a = que.top();\n        que.pop();\n        b = que.top();//取出权值最小的两个点\n        que.pop();\n        huffNode[id].lson = a.id;\n        huffNode[id].rson = b.id;\n        huffNode[id].w = huffNode[a.id].w + huffNode[b.id].w;\n        huffNode[id].id = id;\n        if (que.empty())//当前点为根\n        {\n            root = id;\n            break;\n        }\n        que.push(huffNode[id]);\n        ++id;\n    }\n    return root;\n}\n\nunordered_map\u003cchar, string\u003e mp;//建立字符到编码的映射关系\n\nvoid dfs(int now, node huffmanNode[], string code)\n{\n    if (!huffmanNode[now].lson \u0026\u0026 !huffmanNode[now].rson)//没孩子节点，即叶子\n    {\n        mp[c[huffmanNode[now].id].c] = code;\n        return;\n    }\n    dfs(huffmanNode[now].lson, huffmanNode, code + \"0\");\n    dfs(huffmanNode[now].rson, huffmanNode, code + \"1\");\n}\n\nvoid print()\n{\n    for (int i = 0; i \u003c 300; ++i)\n    {\n        if (!c[i].cnt)\n            break;\n        printf(\"%c的出现次数为%d, huffman编码为: %s\\n\", c[i].c, c[i].cnt, mp[c[i].c].c_str());\n    }\n}\n\nvoid decode(char code[], node huffNode[], int root, int n)\n{\n    int len = strlen(code);\n    int now = root;\n    for (int i = 0; i \u003c len; ++i)\n    {\n\n        if (code[i] == '0')\n            now = huffNode[now].lson;\n        else\n            now = huffNode[now].rson;\n        if (huffNode[now].id \u003c n)\n        {\n            printf(\"%c\", c[huffNode[now].id].c);\n            now = root;\n        }\n    }\n}\n\nint main()\n{\n    char text[10000];\n    read(text);\n    int n = count(text);\n    node *huffNode = new node[2 * n + 1];\n    int root = buildHuffmanTree(n, huffNode);\n    string code = \"\";\n    dfs(root, huffNode, code);//dfs huffman树，获取字符的编码\n    print();//输出字符的编码\n    int len = strlen(text);\n    char *encode = new char[50000];\n    memset(encode, 0, sizeof(encode));\n    for (int i = 0; i \u003c len; ++i)\n        strcat(encode, mp[text[i]].c_str());\n    printf(\"%s\\n\", encode);\n    puts(\"\");\n    printf(\"%s\\n\", text);\n    decode(encode, huffNode, root, n);\n    return 0;\n}\n```\n\n",
        "Title": "哈夫曼树的构造、编码和解码",
        "CreateTime": 1559392430000,
        "FormatTime": "2019.06.01",
        "Categories": "数据结构",
        "Tags": [
            ""
        ],
        "EditorType": "markdown"
    },
    {
        "Content": "#### 题意\n查询$[L, R]$中连续出现次数最多的数出现的次数，如$[1,1,2,2,2,2,3,3,3]$中连续出现次数最多的是2，次数为4\n#### 思路\n这题显然可以直接线段树区间合并。\n用线段树维护区间的前缀中的答案(答案指**区间中连续出现次数最多的数出现的次数**)、后缀中的答案。\n设$m = L + R \u003e\u003e 1$，则$ans[L,R]$是以下三者中最大的那个：\n1. $ans[L,m]$\n2. $ans[m+1,R]$\n3. 跨越了$m$的部分。这一部分可以由右区间前缀的答案和左区间后缀的答案合并得到\n代码：\n\n```c\n#include \u003cbits/stdc++.h\u003e\n\nusing namespace std;\nconst int maxn = 100005;\nint n, a[maxn], len[maxn \u003c\u003c 2], pre[maxn \u003c\u003c 2], suf[maxn \u003c\u003c 2];\n#define ls l,m,rt\u003c\u003c1\n#define rs m+1,r,rt\u003c\u003c1|1\n\ninline void pushUp(int l, int r, int rt) {\n    pre[rt] = pre[rt \u003c\u003c 1];\n    suf[rt] = suf[rt \u003c\u003c 1 | 1];\n    len[rt] = max(len[rt \u003c\u003c 1], len[rt \u003c\u003c 1 | 1]);\n    int m = l + r \u003e\u003e 1;\n    if (a[m] == a[m + 1]) {\n        if (pre[rt] == m - l + 1)\n            pre[rt] += pre[rt \u003c\u003c 1 | 1];\n        if (suf[rt] == r - m)\n            suf[rt] += suf[rt \u003c\u003c 1];\n        len[rt] = max(len[rt], suf[rt \u003c\u003c 1] + pre[rt \u003c\u003c 1 | 1]);\n    }\n};\n\nvoid build(int l = 1, int r = n, int rt = 1) {\n    if (l == r) {\n        len[rt] = pre[rt] = suf[rt] = 1;\n        return;\n    }\n    int m = l + r \u003e\u003e 1;\n    build(ls);\n    build(rs);\n    pushUp(l, r, rt);\n}\n\nint query(int L, int R, int l = 1, int r = n, int rt = 1) {\n    if (L \u003c= l \u0026\u0026 r \u003c= R) {\n        return len[rt];\n    }\n    int m = l + r \u003e\u003e 1;\n    if (L \u003e m)\n        return query(L, R, rs);\n    else if (R \u003c= m)\n        return query(L, R, ls);\n    else {\n        int ans = max(query(L, R, rs), query(L, R, ls));\n        if (a[m] == a[m + 1])\n            ans = max(ans, min(pre[rt \u003c\u003c 1 | 1], R - m) + min(suf[rt \u003c\u003c 1], m - L + 1));\n        return ans;\n    }\n}\n\nint main() {\n    int T, m, c;\n    scanf(\"%d\", \u0026T);\n    for (int ca = 1; ca \u003c= T; ++ca) {\n        scanf(\"%d%d%d\", \u0026n, \u0026c, \u0026m);\n        for (int i = 1; i \u003c= n; ++i) {\n            scanf(\"%d\", a + i);\n        }\n        build();\n        int l, r;\n        printf(\"Case %d:\\n\", ca);\n        for (int i = 1; i \u003c= m; ++i) {\n            scanf(\"%d%d\", \u0026l, \u0026r);\n            printf(\"%d\\n\", query(l, r));\n        }\n    }\n    return 0;\n}\n```\n\n然鹅因为这题是刷分块莫队专题时遇到的。\n所以晚点补一份分块。\n\n",
        "Title": "LightOJ 1339\tStrongest Community",
        "CreateTime": 1558194708000,
        "FormatTime": "2019.05.18",
        "Categories": "数据结构",
        "Tags": [
            ""
        ],
        "EditorType": "markdown"
    },
    {
        "Content": "省赛打得跟屎一样=_=，队友有思路了然鹅我们都不会写莫队，调不出来。回来恶补一波莫队。\n\n### 不带修改莫队\n通过对离线询问的一个玄学排序，使得左右指针移动的次数都相对的少，减少转移的次数\n排序：左端点**不同块**的询问，按左端点所属块号升序排； 左端点**同块**的询问，按右端点升序排\n奇偶性优化：对于左端点**同块**的询问，若左端点块号为奇数，按右端点升序排；为偶数则按右端点降序排。 可以减少右端点移动的次数。\n\n题意：查询区间[l, r]中差小于等于k的$a_i$和$a_j$的对数\n解法：用权值树状数组维护莫队当前$[l, r]$中的各数的数量，莫队增加一个数x时，x贡献的答案为query(x - k, x + k)，删除时同理\n放一个回来写的省赛c代码，因为不能补，不能保证没bug。\n(5.19更新)\n今天在hdu开重现了，wa了几发。树状数组开小了，因为最多可能一共有3n个点。乘个3能过。\n```c\n#include \u003cbits/stdc++.h\u003e\n\n#define query(x, y) (sum(y) - sum(x-1))\nusing namespace std;\nint n, m, k, a[30000], len, ans[30000];\nvector\u003cint\u003e b;\n\nstruct node {\n    int l, r, id;\n\n    bool operator\u003c(const node \u0026a) const {\n        if (l / len == a.l / len)\n            return (l / len) \u0026 1 ? r \u003c a.r : r \u003e a.r;\n        return l / len \u003c a.l / len;\n    }\n} q[30000];\n\nstruct {\n    int l, m, r;\n} id[30000];\n\nint c[30000];\n\nvoid add(int p, int val) {\n    for (int i = p; i \u003c= n; i += i \u0026 -i) {\n        c[i] += val;\n    }\n}\n\nint sum(int p) {\n    int ans = 0;\n    for (int i = p; i; i -= i \u0026 -i) {\n        ans += c[i];\n    }\n    return ans;\n}\n\nint main() {\n    scanf(\"%d%d%d\", \u0026n, \u0026m, \u0026k);\n    len = sqrt(n);\n    for (int i = 1; i \u003c= n; ++i) {\n        scanf(\"%d\", a + i);\n        b.push_back(a[i]);\n        b.push_back(a[i] + k);\n        b.push_back(a[i] - k);\n    }\n    sort(b.begin(), b.end());\n    b.erase(unique(b.begin(), b.end()), b.end());\n    for (int i = 1; i \u003c= n; ++i) {\n        id[i].m = lower_bound(b.begin(), b.end(), a[i]) - b.begin() + 1;\n        id[i].l = lower_bound(b.begin(), b.end(), a[i] - k) - b.begin() + 1;\n        id[i].r = lower_bound(b.begin(), b.end(), a[i] + k) - b.begin() + 1;\n    }\n    for (int i = 1; i \u003c= m; ++i) {\n        scanf(\"%d%d\", \u0026q[i].l, \u0026q[i].r);\n        q[i].id = i;\n    }\n    sort(q + 1, q + m + 1);\n    int l = 1, r = 0, now = 0;\n    n = b.size();\n    for (int i = 1; i \u003c= m; ++i) {\n        while (l \u003e q[i].l) {\n            --l;\n            now += query(id[l].l, id[l].r);\n            add(id[l].m, 1);\n        }\n        while (r \u003c q[i].r) {\n            ++r;\n            now += query(id[r].l, id[r].r);\n            add(id[r].m, 1);\n        }\n        while (l \u003c q[i].l) {\n            add(id[l].m, -1);\n            now -= query(id[l].l, id[l].r);\n            ++l;\n        }\n        while (r \u003e q[i].r) {\n            add(id[r].m, -1);\n            now -= query(id[r].l, id[r].r);\n            --r;\n        }\n        ans[q[i].id] = now;\n    }\n    for (int i = 1; i \u003c= m; ++i) {\n        printf(\"%d\\n\", ans[i]);\n    }\n    return 0;\n}\n```\n### 带修改莫队\n有修改的时候块大小要开成$n^{2/3}$才能使时间复杂度达到最优($O(n^{5/3})$)\n在前面的基础上加上一维时间，并把询问和修改分别记录。\n对于两个询问，若左端点块号和右端点都相同，则按时间升序排序\n在莫队的四个while处理好区间后，再用两个while把当前时间调整到询问的时间。\n对于一个修改，在time增加时处理到它时应把a[i]改为val， 那么在time减少又遇到它时，显然应该把当前的a[i]改回原来的a[i]\n所以处理修改时直接swap(a[i], val)，把原来的值存到修改里面，详情见代码\n\nBZOJ2120数颜色\n```c\n#include \u003cbits/stdc++.h\u003e\n\n#define query(x, y) (sum(y) - sum(x-1))\nusing namespace std;\nconst int maxn = 50005;\nint n, m, a[maxn], len, ans[maxn];\n\nstruct node {\n    int l, r, t, id;\n\n    node() { t = 0; }\n\n    bool operator\u003c(const node \u0026a) const {\n        if (l / len != a.l / len)\n            return l / len \u003c a.l / len;\n        if (r != a.r)\n            return (l / len) \u0026 1 ? r \u003c a.r : r \u003e a.r;\n        return t \u003c a.t;\n    }\n} q[maxn];\n\nstruct {\n    int pos, val;//修改的位置和值\n} c[maxn];\nint cnt[1000005];\n\nint main() {\n    scanf(\"%d%d\", \u0026n, \u0026m);\n    len = (int) pow(n, 2.0 / 3) + 1;\n    for (int i = 1; i \u003c= n; ++i) {\n        scanf(\"%d\", a + i);\n    }\n    char op[5];\n    int l, r, qnum = 0, cnum = 0;\n    for (int i = 1; i \u003c= m; ++i) {\n        scanf(\"%s\", op);\n        if (op[0] == 'Q') {\n            ++qnum;\n            scanf(\"%d%d\", \u0026q[qnum].l, \u0026q[qnum].r);\n            q[qnum].id = qnum;\n            q[qnum].t = cnum;\n        }\n        else {\n            ++cnum;\n            scanf(\"%d%d\", \u0026c[cnum].pos, \u0026c[cnum].val);\n        }\n    }\n    sort(q + 1, q + qnum + 1);\n    l = 1, r = 0;\n    int now = 0, time = 0;\n    for (int i = 1; i \u003c= m; ++i) {\n        while (l \u003e q[i].l) {\n            if (++cnt[a[--l]] == 1)\n                ++now;\n        }\n        while (r \u003c q[i].r) {\n            if (++cnt[a[++r]] == 1)\n                ++now;\n        }\n        while (l \u003c q[i].l) {\n            if (--cnt[a[l++]] == 0)\n                --now;\n        }\n        while (r \u003e q[i].r) {\n            if (--cnt[a[r--]] == 0)\n                --now;\n        }\n        while (time \u003c q[i].t) {\n            ++time;\n            if (l \u003c= c[time].pos \u0026\u0026 c[time].pos \u003c= r) {\n                if (--cnt[a[c[time].pos]] == 0)\n                    --now;\n                if (++cnt[c[time].val] == 1)\n                    ++now;\n            }\n            swap(c[time].val, a[c[time].pos]);\n        }\n        while (time \u003e q[i].t) {\n            if (l \u003c= c[time].pos \u0026\u0026 c[time].pos \u003c= r) {\n                if (--cnt[a[c[time].pos]] == 0)\n                    --now;\n                if (++cnt[c[time].val] == 1)\n                    ++now;\n            }\n            swap(c[time].val, a[c[time].pos]);\n            --time;\n        }\n        ans[q[i].id] = now;\n    }\n    for (int i = 1; i \u003c= qnum; ++i) {\n        printf(\"%d\\n\", ans[i]);\n    }\n    return 0;\n}\n```\n### 树上莫队\n对于子树询问，dfs序把树拍平乱搞就行了\n链上的询问还没学，好像是欧拉序？这个之后补\n\n放一个子树询问的代码。\nCodeForces - 375D Tree and Queries\n询问子树中数量大于等于k的颜色的数量\n\n```c\n#include \u003cbits/stdc++.h\u003e\n\nusing namespace std;\n\nconst int maxn = 100005;\nvector\u003cint\u003e G[maxn];\nint color[maxn], cnt, L[maxn], R[maxn], ans[maxn], c[maxn], a[maxn], ANS[maxn];\n\nvoid dfs(int u, int fa) {\n    L[u] = ++cnt;\n    c[cnt] = color[u];\n    for (int \u0026v:G[u]) {\n        if (v == fa) continue;\n        dfs(v, u);\n    }\n    R[u] = cnt;\n}\n\nint len;\n\nstruct node {\n    int l, r, k, id;\n\n    bool operator\u003c(const node \u0026b) const {\n        if (l / len != b.l / len)\n            return l / len \u003c b.l / len;\n        return l / len \u0026 1 ? r \u003c b.r : r \u003e b.r;\n    }\n} q[maxn];\n\nint num[maxn];\n\nint main() {\n    int n, m, u, v, k;\n    cin \u003e\u003e n \u003e\u003e m;\n    len = sqrt(n);\n    for (int i = 1; i \u003c= n; ++i) {\n        cin \u003e\u003e color[i];\n    }\n    for (int i = 0; i \u003c n - 1; ++i) {\n        cin \u003e\u003e u \u003e\u003e v;\n        G[u].emplace_back(v);\n        G[v].emplace_back(u);\n    }\n    dfs(1, 1);\n    for (int i = 1; i \u003c= m; ++i) {\n        cin \u003e\u003e v \u003e\u003e q[i].k;\n        q[i].l = L[v];\n        q[i].r = R[v];\n        q[i].id = i;\n    }\n    sort(q + 1, q + m + 1);\n    int l = 1, r = 0;\n    for (int i = 1; i \u003c= m; ++i) {\n        while (l \u003e q[i].l) {\n            ANS[++num[c[--l]]]++;\n        }\n        while (r \u003c q[i].r) {\n            ANS[++num[c[++r]]]++;\n\n        }\n        while (l \u003c q[i].l) {\n            ANS[num[c[l++]]--]--;\n\n        }\n        while (r \u003e q[i].r) {\n            ANS[num[c[r--]]--]--;\n        }\n        ans[q[i].id] = ANS[q[i].k];\n    }\n    for (int i = 1; i \u003c= m; ++i) {\n        cout \u003c\u003c ans[i] \u003c\u003c '\\n';\n    }\n    return 0;\n}\n```\n也可以树上启发式合并\n\n```c\n#include \u003cbits/stdc++.h\u003e\n\nusing namespace std;\nconst int maxn = 100005;\nint n, m, color[maxn], ans[maxn];\nvector\u003cint\u003e G[maxn];\n\nint siz[maxn], son[maxn];\n\nvoid dfs1(int u, int fa)\n{\n    siz[u] = 1;\n    for (int \u0026v:G[u])\n    {\n        if (v == fa) continue;\n        dfs1(v, u);\n        siz[u] += siz[v];\n        if (siz[v] \u003e siz[son[u]])\n            son[u] = v;\n    }\n}\n\nstruct query\n{\n    int k, id;\n};\nvector\u003cquery\u003e q[maxn];\nint cntColor[maxn], num[maxn];\n\nbool vis[maxn];\n\nvoid solve(int u, int fa, int val)\n{\n    if (val == -1)\n        --num[cntColor[color[u]]--];\n    else\n        ++num[++cntColor[color[u]]];\n    for (int \u0026v:G[u])\n        if (v != fa \u0026\u0026 !vis[v])\n            solve(v, u, val);\n}\n\nvoid dfs2(int u, int fa, bool flag)\n{\n    for (int \u0026v:G[u])\n    {\n        if (v == fa || v == son[u]) continue;\n        dfs2(v, u, true);\n    }\n    if (son[u])\n    {\n        dfs2(son[u], u, false);\n        vis[son[u]] = true;\n    }\n    solve(u, fa, 1);\n    for (auto i:q[u])\n        ans[i.id] = num[i.k];\n    if (son[u])\n        vis[son[u]] = false;\n    if (flag)\n        solve(u, fa, -1);//消去轻儿子的贡献\n}\n\nint main()\n{\n    cin \u003e\u003e n \u003e\u003e m;\n    for (int i = 1; i \u003c= n; ++i)\n        cin \u003e\u003e color[i];\n    int u, v;\n    for (int i = 1; i \u003c n; ++i)\n    {\n        cin \u003e\u003e u \u003e\u003e v;\n        G[u].emplace_back(v);\n        G[v].emplace_back(u);\n    }\n    int k;\n    for (int i = 1; i \u003c= m; ++i)\n    {\n        cin \u003e\u003e u \u003e\u003e k;\n        q[u].push_back({k, i});\n    }\n    dfs1(1,1);\n    dfs2(1,1, true);\n    for (int i = 1; i \u003c= m; ++i)\n        cout \u003c\u003c ans[i] \u003c\u003c '\\n';\n    return 0;\n}\n```\n\n",
        "Title": "莫队总结",
        "CreateTime": 1558074802000,
        "FormatTime": "2019.05.17",
        "Categories": "杂",
        "Tags": [
            ""
        ],
        "EditorType": "markdown"
    },
    {
        "Content": "[题目链接](http://codeforces.com/problemset/problem/580/E)\n#### 题意\n一个1e5的字符串a， 1e5次操作\n$op\\  l\\ r\\  c$(下标从1开始)\n$op$ == 1：把$[l, r]$的所有字符改成c\n$op$ == 2：询问$[l, r]$是否存在长度为c的循环节\n#### 解法\n首先有一个结论， **若$[l, r-c]$与$[l+c, r]$相同，则长度为$c$的循环节存在**\n为了节约字符串比较的时间，显然要把字符串的每个字符哈希为\n$$h[i] = a[i] * base^{n-i-1}\\ \\ (i从0开始)$$\n的形式\n每个子串的哈希值就是\n$$\\sum_{i=l}^{r} h[i]$$\n这个sigma显然要用线段树或树状数组维护\n\n这题树状数组怎么区间更新我想不到(流下了不学无术的泪水o(╥﹏╥)o)\n讲讲线段树怎么写。\n(该mod的地方自行脑补，不写出来了)\n##### 线段树部分\n上面提到了，要维护的是区间的哈希值之和$\\sum_{i=l}^{r} h[i]$\n如果是单点更新，那其实是很好写的，每个叶子结点都可以直接存$h[i]$，更新的时候先把c处理成对应的$h[i]$，直接维护区间和即可(这种情况其实用树状数组写起来更舒服，例如[这题](https://blog.csdn.net/Apale_8/article/details/89322353))\n然而区间更新的时候，上面那种写法就不适用了(~~太菜了想不到~~ )\n现在要解决的问题是：有一个序列$a[]$，l$ogN$求出\n$$\\sum_{i=l}^r base^{i-1}*a[i]$$\n可以这样维护：\n预处理出$base^i$的值$p[i]$，$base^i$的前缀和$pp[i]$\n对于叶子结点， 保存$a[i]$\n###### pushUp\n$sum[rt] = sum[rt \u003c\u003c 1] * p[r - m] + sum[rt \u003c\u003c 1 | 1]$\n可以这样理解：把左右子树的和累加的时候，右子树的和是正确的，但左子树的和要整体在base进制下左移$r-m$位，就好像把123和45拼在一起变成12345时，就是123 * $10^2$ + 45\nquery时也是一样的左右合并\n\n###### update\nupdate很好理解， $[l, r]$的值都被修改为c时，这一段的区间和显然是$c * pp[r-l]$\n然后再打上lazy标记：lazy[rt] = val;\npushdown同理\n###### 代码\n(这题test75卡ull自然溢出.....)\n```c\n#include \u003cbits/stdc++.h\u003e\n\nusing namespace std;\ntypedef long long ull;\ntypedef pair\u003cull, ull\u003e puu;\nconst int base = 31;\nconst int maxn = 100005;\nconst int mod = 1e9 + 9;\nchar a[maxn];\null pp[maxn], p[maxn];\n#define ls l, m, rt \u003c\u003c 1\n#define rs m+1, r, rt \u003c\u003c 1 | 1\null sum[maxn \u003c\u003c 2];\nint lazy[maxn \u003c\u003c 2];\n\nvoid build(int l, int r, int rt) {\n    lazy[rt] = 0;\n    if (l == r) {\n        sum[rt] = ull(a[l]);\n        return;\n    }\n    int m = l + r \u003e\u003e 1;\n    build(ls);\n    build(rs);\n    sum[rt] = (sum[rt \u003c\u003c 1] * p[r - m] % mod + sum[rt \u003c\u003c 1 | 1]) % mod;\n};\n\ninline void pushDown(int l, int r, int rt) {\n    if (lazy[rt]) {\n        int m = l + r \u003e\u003e 1;\n        lazy[rt \u003c\u003c 1] = lazy[rt \u003c\u003c 1 | 1] = lazy[rt];\n        sum[rt \u003c\u003c 1] = pp[m - l] * lazy[rt] % mod;\n        sum[rt \u003c\u003c 1 | 1] = pp[r - m - 1] * lazy[rt] % mod;\n        lazy[rt] = 0;\n    }\n}\n\nvoid update(int L, int R, int val, int l, int r, int rt) {\n    if (L \u003c= l \u0026\u0026 r \u003c= R) {\n        sum[rt] = pp[r - l] * val % mod;\n        lazy[rt] = val;\n        return;\n    }\n    int m = l + r \u003e\u003e 1;\n    pushDown(l, r, rt);\n    if (L \u003c= m)\n        update(L, R, val, ls);\n    if (R \u003e m)\n        update(L, R, val, rs);\n    sum[rt] = (sum[rt \u003c\u003c 1] * p[r - m] % mod + sum[rt \u003c\u003c 1 | 1]) % mod;\n}\n\null query(int L, int R, int l, int r, int rt) {\n    if (L == l \u0026\u0026 r == R)\n        return sum[rt];\n    int m = l + r \u003e\u003e 1;\n    pushDown(l, r, rt);\n    ull ans = 0;\n    if (R \u003c= m)\n        return query(L, R, ls);\n    else if (L \u003e m)\n        return query(L, R, rs);\n    else {\n        ans = (query(L, m, ls) * p[R - m] % mod + query(m + 1, R, rs)) % mod;\n        return ans;\n    }\n}\n\nint n, m, k;\n\nint main() {\n    cin \u003e\u003e n \u003e\u003e m \u003e\u003e k;\n    m += k;\n    p[0] = pp[0] = 1;\n    for (int i = 1; i \u003c= n; ++i) {\n        p[i] = p[i - 1] * base % mod;\n        pp[i] = (p[i - 1] * base % mod + pp[i - 1]) % mod;\n    }\n    cin \u003e\u003e a;\n    build(0, n - 1, 1);\n    int op, l, r, c;\n    ull h1, h2;\n    while (m--) {\n        cin \u003e\u003e op \u003e\u003e l \u003e\u003e r \u003e\u003e c;\n        --l, --r;\n        if (op == 1) {\n            update(l, r, c + '0', 0, n - 1, 1);\n        }\n        else {\n            if (r - l + 1 \u003c= c) {\n                cout \u003c\u003c \"YES\\n\";\n                continue;\n            }\n            h1 = query(l, r - c, 0, n - 1, 1);\n            h2 = query(l + c, r, 0, n - 1, 1);\n            if (h1 == h2)\n                cout \u003c\u003c \"YES\\n\";\n            else\n                cout \u003c\u003c \"NO\\n\";\n        }\n    }\n    return 0;\n}\n```\n\n",
        "Title": "Kefa and Watch CodeForces - 580E",
        "CreateTime": 1555599850000,
        "FormatTime": "2019.04.18",
        "Categories": "字符串",
        "Tags": [
            ""
        ],
        "EditorType": "markdown"
    },
    {
        "Content": "存一个ST表板子\n可用于维护静态区间最值和gcd\n以后的代码左花括号不会另起一行。\n(让两个队友舒服点o(╥﹏╥)o)\n```c\nint dp[maxn][30];\nvoid init() {\n\tfor (int j=1; j\u003c=20; ++j)\n\t\tfor (int i=1; i + (1 \u003c\u003c j) - 1 \u003c= n; ++i)\n\t\t\tdp[i][j] = __gcd(dp[i][j-1], dp[i+(1 \u003c\u003c (j-1))][j-1]);\n}\n\nint query(int l, int r) {\n\tint k = log2(r - l + 1);\n\treturn __gcd(dp[l][k], dp[r - (1 \u003c\u003c k) + 1][k]);\n}\n```\n\n",
        "Title": "ST表板子",
        "CreateTime": 1555509696000,
        "FormatTime": "2019.04.17",
        "Categories": "数据结构",
        "Tags": [
            ""
        ],
        "EditorType": "markdown"
    },
    {
        "Content": "[题目链接](https://vjudge.net/problem/URAL-1989)\n### 题意\n输入一个1e5的串a，1e5次询问\n每次询问：\npalindrome？ l r 询问$[l ,r]$的子串是否是回文串\nchange x c 把a[x]改成c\n下标从1开始\n\n### 解法\n显然， 若一个串与它反转后的串相同，这个串就是回文串(~~废话~~ )\n这里要用到多项式哈希， 将原串和反转后的串的每个字符哈希，用树状数组维护\n\n### 字符串哈希\n把字符串的第$i$个字符哈希:$h[i] = a[i] * base^i$\n用$\\sum_{i=l}^{r}{h[i]}$来表示$[l, r]$子串的哈希值\n显然$\\sum$可以用树状数组 $or$ 线段树快速维护\n因为一个子串在原串和反转串中的位置不同，\n设在原串中的位置为$[l, r]$，\n则在反转串中的位置为$[len-r+1, len - l + 1]$(下标从1开始)\n要先把靠左边的子串的哈希值乘上$base^{|r - (len - l + 1)|}$，对齐后再进行比较\n\n代码：\n\n```c\n#include \u003cbits/stdc++.h\u003e\n\nusing namespace std;\n\nconst int base = 31;\nconst int maxn = 100005;\ntypedef unsigned long long ull;\n\n\nchar a[maxn], op[20];\nint q, n;\null p[maxn];\null sum[2][maxn];\n\ninline int lowbit(int x) {\n    return x \u0026 -x;\n}\n\nvoid add(int p, ull val, bool flag) {\n    for (int i = p; i \u003c= n; i += lowbit(i)) {\n        sum[flag][i] += val;\n    }\n}\n\null getSum(int p, bool flag) {\n    ull ans = 0;\n    for (int i = p; i \u003e 0; i -= lowbit(i)) {\n        ans += sum[flag][i];\n    }\n    return ans;\n}\n\nint main() {\n    scanf(\"%s\", a + 1);\n    n = strlen(a + 1);\n    p[0] = 1;\n    for (int i = 1; i \u003c= n; ++i) {\n        p[i] = p[i - 1] * base;\n    }\n    for (int i = 1; i \u003c= n; ++i) {\n        add(i, a[i] * p[i - 1], 0);\n    }\n    for (int i = 1; i \u003c= n; ++i) {\n        add(i, a[n - i + 1] * p[i - 1], 1);\n    }\n    scanf(\"%d\", \u0026q);\n    int x, y;\n    ull s1, s2;\n    while (q--) {\n        scanf(\"%s\", op);\n        if (op[0] == 'p') {\n            scanf(\"%d%d\", \u0026x, \u0026y);\n            s1 = getSum(y, 0) - getSum(x - 1, 0);\n            s2 = getSum(n - x + 1, 1) - getSum(n - y, 1);\n            if (y \u003c n - x + 1)\n                s1 *= p[n - x + 1 - y];\n            else\n                s2 *= p[y - (n - x + 1)];\n            if (s1 == s2)\n                printf(\"Yes\\n\");\n            else\n                printf(\"No\\n\");\n        }\n        else {\n            scanf(\"%d%s\", \u0026x, op);\n            add(x, (op[0] - a[x]) * p[x - 1], 0);\n            add(n - x + 1, (op[0] - a[x]) * p[n - x], 1);\n            a[x] = op[0];\n        }\n    }\n}\n```\n\n",
        "Title": "URAL - 1989 Subpalindromes（字符串哈希+ 树状数组 or 线段树）",
        "CreateTime": 1555337800000,
        "FormatTime": "2019.04.15",
        "Categories": "字符串",
        "Tags": [
            ""
        ],
        "EditorType": "markdown"
    },
    {
        "Content": "存一个树状数组区间更新的板子\n```c\nll c1[maxn];//c1维护差分数组的前缀和\nll c2[maxn], a[maxn];//c2维护c1 * (pos - 1)的前缀和\n//a[i]的前缀和[1, p]可以由c1[1,2,...,p] * p - c2[1,2,...,p]表示\nint n;\ninline int lowbit(int x)\n{\n    return x \u0026 (-x);\n}\n\nvoid add(int p, int val)\n{\n    for (int i = p; i \u003c= n; i += lowbit(i))\n    {\n        c1[i] += val;\n        c2[i] += 1ll * val * (p - 1);\n    }\n}\n\ninline void update(int l, int r, int w)\n{\n    add(l, w);\n    add(r + 1, -w);\n}\n\nll getSum(int p)\n{\n    ll ans = 0;\n    for (int i = p; i \u003e 0; i -= lowbit(i))\n        ans += 1ll * p * c1[i] - c2[i];\n    return ans;\n}\n```\n\n",
        "Title": "树状数组区间更新板子",
        "CreateTime": 1555259029000,
        "FormatTime": "2019.04.15",
        "Categories": "数据结构",
        "Tags": [
            ""
        ],
        "EditorType": "markdown"
    },
    {
        "Content": "# 什么是字符串哈希\n字符串哈希，即**把字符串转化为一个$base$进制的数字**\n# 哈希的过程\n把字符串a看做一个base进制的数字， 则a的每个前缀的哈希值为\n$hash[i]$  $=$  $(hash[i-1] * base + a[i]) \\% mod$\n其中，$base$和$mod$一般取质数，可以减小冲突\n把$hash$数组定义为无符号类型，可以不模，使其自然溢出\n然鹅单哈希容易被卡，最好使用**双哈希**\n# 双哈希\n取不同的base和mod，做两次哈希，得到两组值：$hash1[], hash2[]$\n此时原串的哈希值为一个$pair$\n实测双哈希不会慢太多，可放心使用。\n# 字符串哈希的用处\n观察每个前缀串的哈希值可得：\n$hash[l, r] = hash[r] - has[l-1]*base^{r-l+1}$（当hash不为无符号数时，减法后取模需$\\%mod + mod) \\% mod$）\n于是可以$O(1)$求得任意子串的哈希值。\n简单的说，字符串哈希可以**在字符串匹配的过程中，把两个字符串的比较转化为两个数字的比较，在时间上消掉一个$n$**\n## 例题\n[题目链接](https://vjudge.net/problem/POJ-2774)\n题意：两个串的最长公共子串\n(听说后缀自动机能$O(n)$求。晚点再补两份后缀数组$\\\u0026\\\u0026$后缀自动机的代码。)\n### 解法：\n预处理出a和b每个前缀的哈希值\n因为最长公共子串的性质，存在长度为$m$的最长公共子串，就一定存在长度为$m-1$的最长公共子串。\n所以可以二分答案\ncheck的时候，把a长度为m的所有子串的哈希值排序，对b的每个长度为m的哈希值，在有序序列中二分查找，能找到则check函数返回1。\n时间复杂度：check里面一次排序$nlogn$， 二分答案$logn$，一共$nlog^2n$。\n看到一种更好的做法 ，把check中排序+二分的操作换成哈希，可以再消掉一个$log$...\n这里放一个双哈希的$nlog^2n$的代码。\n\n```c\n#include \u003ccstdio\u003e\n#include \u003ccstring\u003e\n#include \u003ciostream\u003e\n#include \u003calgorithm\u003e\n#include \u003cvector\u003e\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair\u003cull, ull\u003e puu;\nconst int base1 = 31;\nconst int base2 = 196613;\n\npuu has1[100005], has2[100005];\null p1[100005], p2[100005];\n\nvoid Hash(const string \u0026a, puu has[])\n{\n    has[0] = {a[0], a[0]};\n    int len = a.size();\n    for (int i = 1; i \u003c len; ++i)\n    {\n        has[i].first = has[i - 1].first * base1 + a[i];\n        has[i].second = has[i - 1].second * base2 + a[i];\n    }\n}\n\npuu sub(int l, int r, puu has[])\n{\n    if (!l)\n        return has[r];\n    puu ans;\n    ans.first = has[r].first - has[l - 1].first * p1[r - l + 1];\n    ans.second = has[r].second - has[l - 1].second * p2[r - l + 1];\n    return ans;\n}\n\null lena, lenb;\nvector\u003cpuu\u003e h;\n\nbool ok(int n, int lena, int lenb)\n{\n    h.clear();\n    for (int i = n - 1; i \u003c lena; ++i)\n\t\th.push_back(sub(i-n+1, i, has1));\n    sort(h.begin(), h.end());\n    puu t;\n    for (int i = n - 1; i \u003c lenb; ++i)\n    {\n        t = sub(i - n + 1, i, has2);\n        if (binary_search(h.begin(), h.end(), t))\n            return 1;\n    }\n    return 0;\n}\n\nstring a, b;\n\nint main()\n{\n    cin \u003e\u003e a \u003e\u003e b;\n    Hash(a, has1);\n    Hash(b, has2);\n    p1[0] = p2[0] = 1;\n    for (int i = 1; i \u003c= 100005; ++i)\n    {\n        p1[i] = base1 * p1[i - 1];\n        p2[i] = base2 * p2[i - 1];\n    }\n    int l = 1, r = min(a.size(), b.size()), m;\n    while (l \u003c= r)\n    {\n        m = l + r \u003e\u003e 1;\n        if (ok(m, a.size(), b.size()))\n            l = m + 1;\n        else\n            r = m - 1;\n    }\n    cout \u003c\u003c r;\n    return 0;\n}\n```\n\n",
        "Title": "大力出奇迹——字符串哈希",
        "CreateTime": 1555237232000,
        "FormatTime": "2019.04.14",
        "Categories": "字符串",
        "Tags": [
            ""
        ],
        "EditorType": "markdown"
    },
    {
        "Content": "直接上平衡树乱搞。\n也可以离散化后线段树维护子树大小和区间和(平衡树不用离散化)\n用的是Treap。\n```c\n#include \u003ccstdio\u003e\n#include \u003calgorithm\u003e\n#include \u003ccstdlib\u003e\n\nusing namespace std;\n\ntypedef long long ll;\nconst ll maxn = 200005;\nconst ll mod = 1000000007;\nll ch[maxn][2], val[maxn], pri[maxn];\nll tot, rt;\nll siz[maxn], num[maxn], sum[maxn];\n#define ls ch[now][0]\n#define rs ch[now][1]\n\ninline void pushUp(ll now)\n{\n    siz[now] = siz[ls] + siz[rs] + num[now];\n    sum[now] = ((sum[ls] + sum[rs]) % mod + (val[now] * num[now]) % mod) % mod;\n}\n\nvoid rotate(ll \u0026x, ll dir)\n{\n    ll son = ch[x][dir];\n    ch[x][dir] = ch[son][dir ^ 1];\n    ch[son][dir ^ 1] = x;\n    pushUp(x);\n    pushUp(x = son);\n}\n\ninline void newNode(ll v, ll cnt, ll \u0026now)\n{\n    now = ++tot;\n    ls = rs = 0;\n    num[now] = siz[now] = cnt;\n    val[now] = v;\n    pri[now] = rand();\n}\n\nvoid insert(ll v, ll cnt, ll \u0026now)\n{\n    if (!now)\n    {\n        newNode(v, cnt, now);\n        sum[now] = v * cnt % mod;\n        return;\n    }\n    if (val[now] == v)\n    {\n        num[now] += cnt;\n        siz[now] += cnt;\n        sum[now] = (sum[now] + cnt * v % mod) % mod;\n        return;\n    }\n    if (v \u003c val[now])\n    {\n        insert(v, cnt, ls);\n        if (pri[ls] \u003c pri[now])\n            rotate(now, 0);\n    }\n    else\n    {\n        insert(v, cnt, rs);\n        if (pri[rs] \u003c pri[now])\n            rotate(now, 1);\n    }\n    pushUp(now);\n}\n\nll query(ll k, ll now)\n{\n    if (!k)\n        return 0;\n    if (siz[ls] \u003c k \u0026\u0026 siz[ls] + num[now] \u003e= k)\n        return (sum[ls] + ((k - siz[ls]) * val[now]) % mod) % mod;\n    else if (k \u003c= siz[ls])\n        return query(k, ls) % mod;\n    else\n        return ((sum[now] - sum[rs]) % mod + query(k - siz[ls] - num[now], rs)) % mod;\n}\n\nll Q;\n\nint main()\n{\n    scanf(\"%I64d\", \u0026Q);\n    ll op;\n    ll a, b;\n    while (Q--)\n    {\n        scanf(\"%I64d%I64d%I64d\", \u0026op, \u0026a, \u0026b);\n        if (op == 1)\n            insert(b, a, rt);\n        else\n            printf(\"%I64d\\n\", ((query(b, rt) - query(a - 1, rt)) % mod + mod) % mod);\n    }\n}\n```\n\n",
        "Title": "2019广工校赛 D-免费送气球 (HDU6464)",
        "CreateTime": 1552825288000,
        "FormatTime": "2019.03.17",
        "Categories": "数据结构",
        "Tags": [
            ""
        ],
        "EditorType": "markdown"
    },
    {
        "Content": "题目链接:http://codeforces.com/contest/1092/problem/F\n\n题意：给出一棵有n个节点的树， 每个节点有一个正整数权值$a[i]$，每条边的长度为1，让你找一个点$v$，使得$\\sum_{i=1}^{n}{a[i] * dis(i,v)}$的值最大($dis(i,v)是i到v的距离$)\n\n思路：昨天晚上十二点多敲的时候真的呆，以为是类似求树的重心那样，找最大子树最大的那个点(树的重心是最大子树最小)。敲完试了下两个样例都过了，一交，wa on test3，巨尴尬=_=。\n树重心只考虑了路径距离之和最小，没考虑到点的权值。今早想出来的解法是：先随便选一个基点v，求出$\\sum_{i=1}^{n}{a[i] * dis(i,v)}$，然后从这个点开始往子树$dfs$。\n如果**把基点往子树移动**，显然**子树部分的所有点都少算了一次**，**除子树外的所有点则多算了一次**。只要预处理出子树的点权之和，就可以$O(1)$转移。做一遍$O(n)$的$dfs$即可得出答案。\n\n代码:\n\n```c\n#include \u003ciostream\u003e\n#include \u003ccstdio\u003e\n#include \u003calgorithm\u003e\n#include \u003ccstring\u003e\n#include \u003cvector\u003e\n\nusing namespace std;\nconst int maxn = 200000 + 10;\nint n, a[maxn];\nvector\u003cint\u003e G[maxn];\n\nint dis[maxn];\nlong long sum[maxn];\n\nvoid dfs1(int u, int fa)\n{\n    dis[u] = dis[fa] + 1;\n    sum[u] = a[u];\n    for (auto v:G[u])\n    {\n        if (v == fa) continue;\n        dfs1(v, u);\n        sum[u] += sum[v];\n    }\n}\n\nlong long ans, tot;\n\nvoid dfs2(int u, int fa, long long s)\n{\n    s = s - sum[u] + tot - sum[u];\n    ans = max(s, ans);\n    for (auto v:G[u])\n    {\n        if (v == fa) continue;\n        dfs2(v, u, s);\n    }\n}\n\nint main()\n{\n    scanf(\"%d\", \u0026n);\n    int u, v;\n    tot = 0;\n    for (int i = 1; i \u003c= n; ++i)\n    {\n        scanf(\"%d\", \u0026a[i]);\n        tot += a[i];\n    }\n    for (int i = 0; i \u003c n - 1; ++i)\n    {\n        scanf(\"%d%d\", \u0026u, \u0026v);\n        G[u].emplace_back(v);\n        G[v].emplace_back(u);\n    }\n    dis[0] = -1;\n    dfs1(1, 0);\n    long long t = 0;\n    for (int i = 1; i \u003c= n; ++i)\n        t += 1ll * a[i] * dis[i];//t是以1为基点的答案\n    ans = t;\n    for (auto v:G[1])\n        dfs2(v, 1, t);\n    printf(\"%lld\\n\", ans);\n    return 0;\n}\n```\n\n",
        "Title": "Codeforces1092C Tree with Maximum Cost",
        "CreateTime": 1545190152000,
        "FormatTime": "2018.12.19",
        "Categories": "树上算法",
        "Tags": [
            ""
        ],
        "EditorType": "markdown"
    },
    {
        "Content": "题目链接:http://codeforces.com/contest/1092/problem/F\n\n题意：给出一棵有n个节点的树， 每个节点有一个正整数权值$a[i]$，每条边的长度为1，让你找一个点$v$，使得$\\sum_{i=1}^{n}{a[i] * dis(i,v)}$的值最大($dis(i,v)是i到v的距离$)\n\n思路：昨天晚上十二点多敲的时候真的呆，以为是类似求树的重心那样，找最大子树最大的那个点(树的重心是最大子树最小)。敲完试了下两个样例都过了，一交，wa on test3，巨尴尬=_=。\n树重心只考虑了路径距离之和最小，没考虑到点的权值。今早想出来的解法是：先随便选一个基点v，求出$\\sum_{i=1}^{n}{a[i] * dis(i,v)}$，然后从这个点开始往子树$dfs$。\n如果**把基点往子树移动**，显然**子树部分的所有点都少算了一次**，**除子树外的所有点则多算了一次**。只要预处理出子树的点权之和，就可以$O(1)$转移。做一遍$O(n)$的$dfs$即可得出答案。\n\n代码:\n\n```c\n#include \u003ciostream\u003e\n#include \u003ccstdio\u003e\n#include \u003calgorithm\u003e\n#include \u003ccstring\u003e\n#include \u003cvector\u003e\n\nusing namespace std;\nconst int maxn = 200000 + 10;\nint n, a[maxn];\nvector\u003cint\u003e G[maxn];\n\nint dis[maxn];\nlong long sum[maxn];\n\nvoid dfs1(int u, int fa)\n{\n    dis[u] = dis[fa] + 1;\n    sum[u] = a[u];\n    for (auto v:G[u])\n    {\n        if (v == fa) continue;\n        dfs1(v, u);\n        sum[u] += sum[v];\n    }\n}\n\nlong long ans, tot;\n\nvoid dfs2(int u, int fa, long long s)\n{\n    s = s - sum[u] + tot - sum[u];\n    ans = max(s, ans);\n    for (auto v:G[u])\n    {\n        if (v == fa) continue;\n        dfs2(v, u, s);\n    }\n}\n\nint main()\n{\n    scanf(\"%d\", \u0026n);\n    int u, v;\n    tot = 0;\n    for (int i = 1; i \u003c= n; ++i)\n    {\n        scanf(\"%d\", \u0026a[i]);\n        tot += a[i];\n    }\n    for (int i = 0; i \u003c n - 1; ++i)\n    {\n        scanf(\"%d%d\", \u0026u, \u0026v);\n        G[u].emplace_back(v);\n        G[v].emplace_back(u);\n    }\n    dis[0] = -1;\n    dfs1(1, 0);\n    long long t = 0;\n    for (int i = 1; i \u003c= n; ++i)\n        t += 1ll * a[i] * dis[i];//t是以1为基点的答案\n    ans = t;\n    for (auto v:G[1])\n        dfs2(v, 1, t);\n    printf(\"%lld\\n\", ans);\n    return 0;\n}\n```\n\n",
        "Title": "Codeforces1092C Tree with Maximum Cost",
        "CreateTime": 1545190152000,
        "FormatTime": "2018.12.19",
        "Categories": "树上算法",
        "Tags": [
            ""
        ],
        "EditorType": "markdown"
    },
    {
        "Content": "vj的题目链接：https://cn.vjudge.net/problem/HDU-4027\n\n题目大意：对一个n个数的序列进行两种操作：1、将某个区间的每个数开方。2、查询某个区间中所有数的和\n\n解题思路：区间修改、查询的问题显然是用线段树来来维护了。这题是不能用延迟标记来完成区间修改的，因为先求和再开方与先每个数开方再求和的结果是不同的。于是对于一次区间更新的操作，只能将每个点单点更新，但这样的时间复杂度无法接受。只要加一个剪枝即可：将区间和等于区间大小(即区间内的每个数都为1)的区间忽略掉。因为显然这样的区间每个数开方后的值不会变。\n\n代码：\n\n```c\n#include \u003ciostream\u003e\n#include \u003ccstring\u003e\n#include \u003ccstdio\u003e\n#include \u003ccmath\u003e\n#include \u003calgorithm\u003e\n\nusing namespace std;\n#define ls l,m,rt\u003c\u003c1\n#define rs m+1,r,rt\u003c\u003c1|1\nconst int maxn = 100005;\nlong long t[maxn \u003c\u003c 2], lazy[maxn \u003c\u003c 2];\n\nvoid build(int l, int r, int rt)\n{\n    lazy[rt] = 0;\n    if (l == r)\n    {\n        scanf(\"%lld\", \u0026t[rt]);\n        return;\n    }\n    int m = l + r \u003e\u003e 1;\n    build(ls);\n    build(rs);\n    t[rt] = t[rt \u003c\u003c 1] + t[rt \u003c\u003c 1 | 1];\n}\n\nvoid update(int L, int R, int l, int r, int rt)\n{\n    if (l == r)\n    {\n        t[rt] = sqrt(t[rt]);\n        return;\n    }\n    if (L \u003c= l \u0026\u0026 r \u003c= R \u0026\u0026 t[rt] == r - l + 1)\n        return;\n    int m = l + r \u003e\u003e 1;\n    if (L \u003c= m)\n        update(L, R, ls);\n    if (R \u003e m)\n        update(L, R, rs);\n    t[rt] = t[rt \u003c\u003c 1] + t[rt \u003c\u003c 1 | 1];\n}\n\nlong long query(int L, int R, int l, int r, int rt)\n{\n    if (L \u003c= l \u0026\u0026 r \u003c= R)\n        return t[rt];\n    int m = l + r \u003e\u003e 1;\n    long long ans = 0;\n    if (L \u003c= m)\n        ans += query(L, R, ls);\n    if (R \u003e m)\n        ans += query(L, R, rs);\n    return ans;\n}\n\nint main()\n{\n    int T, N, Q, l, r, op, ca = 1;\n\n    while (scanf(\"%d\", \u0026N) != EOF)\n    {\n        build(1, N, 1);\n        scanf(\"%d\", \u0026Q);\n        printf(\"Case #%d:\\n\", ca++);\n        while (Q--)\n        {\n            scanf(\"%d%d%d\", \u0026op, \u0026l, \u0026r);\n            if (l \u003e r)\n                swap(l, r);\n            if (!op)\n                update(l, r, 1, N, 1);\n            else\n                printf(\"%lld\\n\", query(l, r, 1, N, 1));\n        }\n        putchar('\\n');\n    }\n\n    return 0;\n}\n```\n\n\n",
        "Title": "HDU4027 (线段树简单题)",
        "CreateTime": 1544713994000,
        "FormatTime": "2018.12.13",
        "Categories": "数据结构",
        "Tags": [
            ""
        ],
        "EditorType": "markdown"
    },
    {
        "Content": "```\nstruct AC_Automaton\n{\n    static const int sigmaSize = 26;\n    int next[maxn][sigmaSize];\n    int fail[maxn];\n    int end[maxn];\n    int siz, rt;\n\n    void init()\n    {\n        siz = 0;\n        rt = newNode();\n    }\n\n    int newNode()\n    {\n        memset(next[siz], -1, 4 * sigmaSize);\n        fail[siz] = -1;\n        end[siz] = 0;\n        return siz++;\n    }\n\n    void insert(char s[], int id)\n    {\n        int p = rt, c;\n        for (int i = 0; s[i]; ++i)\n        {\n            c = s[i] - 'A';\n            if (next[p][c] == -1)\n                next[p][c] = newNode();\n            p = next[p][c];\n        }\n        end[p] = id;\n    }\n\n    void getFail()\n    {\n        queue\u003cint\u003e q;\n        for (int i = 0; i \u003c sigmaSize; ++i)\n        {\n            if (~next[rt][i])\n            {\n                fail[next[rt][i]] = rt;\n                q.push(next[rt][i]);\n            }\n            else\n                next[rt][i] = rt;\n        }\n        int p;\n        while (!q.empty())\n        {\n            p = q.front();\n            q.pop();\n            for (int i = 0; i \u003c sigmaSize; ++i)\n            {\n                int \u0026v = next[p][i];\n                if (~v)\n                {\n                    fail[v] = next[fail[p]][i];\n                    q.push(v);\n                }\n                else\n                    v = next[fail[p]][i];\n            }\n        }\n    }\n\n    void query(char s[],int ans[])\n    {\n        int p = rt, ret = 0;\n        for (int i = 0; s[i]; ++i)\n        {\n            if (!isupper(s[i]))\n                s[i] = 'Z' + 1;\n            p = next[p][s[i] - 'A'];\n            for (int j = p; end[j]; j = fail[j])\n            {\n                ++ans[end[j]];\n            }\n        }\n    }\n} ac;\n```\n\n",
        "Title": "ac自动机[模板]",
        "CreateTime": 1543404019000,
        "FormatTime": "2018.11.28",
        "Categories": "字符串",
        "Tags": [
            ""
        ],
        "EditorType": "markdown"
    },
    {
        "Content": "Valera had an undirected connected graph without self-loops and multiple edges consisting of n vertices. The graph had an interesting property: there were at most k edges adjacent to each of its vertices. For convenience, we will assume that the graph vertices were indexed by integers from 1 to n.\n\nOne day Valera counted the shortest distances from one of the graph vertices to all other ones and wrote them out in array d. Thus, element d[i] of the array shows the shortest distance from the vertex Valera chose to vertex number i.\n\nThen something irreparable terrible happened. Valera lost the initial graph. However, he still has the array d. Help him restore the lost graph.\n\nInput\nThe first line contains two space-separated integers n and k (1 ≤ k \u003c n ≤ 105). Number n shows the number of vertices in the original graph. Number k shows that at most k edges were adjacent to each vertex in the original graph.\n\nThe second line contains space-separated integers d[1], d[2], ..., d[n] (0 ≤ d[i] \u003c n). Number d[i] shows the shortest distance from the vertex Valera chose to the vertex number i.\n\nOutput\nIf Valera made a mistake in his notes and the required graph doesn't exist, print in the first line number -1. Otherwise, in the first line print integer m (0 ≤ m ≤ 106) — the number of edges in the found graph.\n\nIn each of the next m lines print two space-separated integers ai and bi (1 ≤ ai, bi ≤ n; ai ≠ bi), denoting the edge that connects vertices with numbers ai and bi. The graph shouldn't contain self-loops and multiple edges. If there are multiple possible answers, print any of them.\n\nExamples\nInput\n3 2\n0 1 1\nOutput\n3\n1 2\n1 3\n3 2\nInput\n4 2\n2 0 1 3\nOutput\n3\n1 3\n1 4\n2 3\nInput\n3 1\n0 0 0\nOutput\n-1\n\n题意：有一幅$n$个点的无向无环图(那不就是树吗=_=)，边权全为$1$，现在只知道其中一个点到其他每个点的最短距离(与自己的距离是$0$)和每个点的最大度数$k$，请判断这样的图是否存在。存在则输出边数和每一条边，否则输出$-1$。\n\n思路：把距离按升序排序，然后当做是一棵k叉树，一层一层连边。如果第$i$层所有的点的度数都到$k$了而第$i+1$层还有剩余的点，就输出$-1$\n数据好坑啊，居然有一个点卡的是输入的距离没有$0$要输出$-1$\n\n```\n#include \u003ccstdio\u003e\n#include \u003calgorithm\u003e\n#include \u003cvector\u003e\n#include \u003cqueue\u003e\n\nusing namespace std;\n\nconst int maxn = 100005;\nint n, k;\nint degree[maxn];\nvector\u003cpair\u003cint,int\u003e \u003e G;\nstruct node\n{\n    int val, id;\n\n    bool operator\u003c(const node \u0026a) const\n    {\n        return val \u003c a.val;\n    }\n} d[maxn];\n\nint main()\n{\n    bool flag = 0;\n    scanf(\"%d%d\", \u0026n, \u0026k);\n    for (int i = 1; i \u003c= n; ++i)\n    {\n        scanf(\"%d\", \u0026d[i].val);\n        d[i].id = i;\n    }\n\n    sort(d + 1, d + n + 1);\n\n    if ((!d[1].val \u0026\u0026 !d[2].val) || d[1].val)//0的数量不为1时直接输出-1\n    {\n        printf(\"-1\\n\");\n        return 0;\n    }\n    int fa = 1;\n    for (int i = 2; i \u003c= n; ++i)\n    {\n        while (d[i].val \u003e d[fa].val + 1)\n            ++fa;\n        if (degree[d[fa].id] == k)\n            ++fa;\n        if (d[i].val != d[fa].val + 1)\n        {\n            flag = 1;\n            break;\n        }\n        G.emplace_back(make_pair(d[fa].id,d[i].id));\n        ++degree[d[fa].id];\n        ++degree[d[i].id];\n    }\n    if (flag)\n        printf(\"-1\\n\");\n    else\n    {\n        printf(\"%d\\n\",(int)G.size());\n        for (auto i:G)\n            printf(\"%d %d\\n\",i.first,i.second);\n    }\n    return 0;\n}\n```\n\n",
        "Title": "CodeForces - 404C Restore Graph",
        "CreateTime": 1542598187000,
        "FormatTime": "2018.11.19",
        "Categories": "ACM水题",
        "Tags": [
            ""
        ],
        "EditorType": "markdown"
    },
    {
        "Content": "题意：一棵$n$个节点的树，每个节点有一个价值(存在负数)。两个人一人选一棵子树，问 在两棵子树没有公共节点的情况下 两人能取到的价值之和的最大值。\n\n思路：设$dp[u]$是在以$u$为根的树选一棵子树能取到的最大价值。$dp[u]$要么是整棵树的权值之和$sum[u]$，要么是$dp[v]$中的最大值($v$是$u$的孩子)。而答案显然是某一个节点的价值最大的子树与价值次大的子树的价值之和。$dp$ $sum$两个数组一边$dfs$一边维护即可\n\n```\n#include \u003ciostream\u003e\n#include \u003cvector\u003e\n#include \u003calgorithm\u003e\n\nusing namespace std;\nconst int maxn = 2e5 + 5;\nint w[maxn];\nconst long long inf = 1e18;\nvector\u003cint\u003e G[maxn];\nlong long ans;\nlong long dp[maxn], sum[maxn];\n\nvoid dfs(int u, int fa)\n{\n    sum[u] = w[u];\n    for (int v:G[u])\n    {\n        if (v == fa) continue;\n        dfs(v, u);\n        sum[u] += sum[v];\n        if (dp[u] \u003e -inf)\n            ans = max(ans, dp[u] + dp[v]);\n        dp[u] = max(dp[u], dp[v]);\n    }\n    dp[u] = max(dp[u], sum[u]);\n}\n\nint main()\n{\n    ans = -inf;\n    int n, u, v;\n    cin \u003e\u003e n;\n    for (int i = 1; i \u003c= n; ++i)\n        cin \u003e\u003e w[i];\n    for (int i = 1; i \u003c= n; ++i)\n        dp[i] = -inf;\n    for (int i = 0; i \u003c n - 1; ++i)\n    {\n        cin \u003e\u003e u \u003e\u003e v;\n        G[u].emplace_back(v);\n        G[v].emplace_back(u);\n    }\n    dfs(1, 0);\n    int num = 0;\n    for (int i = 2; i \u003c= n; ++i)\n        if (G[i].size() == 1)\n            ++num;\n    if (num \u003c 2)//叶子少于两个的话，不可能有答案。\n        cout \u003c\u003c \"Impossible\" \u003c\u003c endl;\n    else\n        cout \u003c\u003c ans \u003c\u003c endl;\n    return 0;\n}\n```\n\n",
        "Title": "codeforce743D - Chloe and pleasant prizes",
        "CreateTime": 1541515840000,
        "FormatTime": "2018.11.06",
        "Categories": "树上算法",
        "Tags": [
            ""
        ],
        "EditorType": "markdown"
    },
    {
        "Content": "\n**给定一棵n个节点的树和n-1条边的权值，求每两点间的权值的总和。$(n \\leq 1e5)$**\n\n - 暴力做法\n 求出每两个点的$lca (O(nlogn)$预处理，$O(logn)$查询)，预处理路径前缀和后$O(1)$求得\n $n^2$数量级的点对,时间复杂度$O(n^2logn)$，TLE了。\n \n - 正解:统计每条边被经过的次数，乘以权值，求和\n \n 1.每条边连接了两个联通块$a b$，一个有$k$个点，一个有$n-k$个点。\n 2.因为要求的是任意两点的距离和，故每条边在$a$中的每一个点与$b$中的每一个点的路径上出现，即出现了$k*(n-k)$次，再乘以权值即可。\n 3.做一遍预处理，对每个节点求出子树大小，即可在$O(n)$的时间内求出每两点的权值总和\n\n\n主要代码：\n```c++\nint siz[maxn];\nvoid dfs(int u, int fa)\n{\n    siz[u] = 1;\n    for (auto v:G[u])\n    {\n        if (v != fa)\n        {\n            dfs(v, u);\n            siz[u] += siz[v];\n        }\n    }\n}\n\nfor (int i = 1; i \u003c= n; ++i)\n        ans += 1ll * siz[i] * (n - siz[i]) * w[i];\n```\n\n",
        "Title": "求树上每两点的距离之和",
        "CreateTime": 1541411754000,
        "FormatTime": "2018.11.05",
        "Categories": "树上算法",
        "Tags": [
            "正则表达式",
            "c++",
            "编译器"
        ],
        "EditorType": "markdown"
    },
    {
        "Content": "大家节日快乐！！！\n",
        "Title": "节日快乐",
        "CreateTime": 1540371828000,
        "FormatTime": "2018.10.24",
        "Categories": "杂",
        "Tags": [
            ""
        ],
        "EditorType": "markdown"
    },
    {
        "Content": "VJ的链接:https://cn.vjudge.net/problem/Gym-101908L\n题目大意:\n一棵$n$个点的树上，查询$a$ ~ $b$，$c$ ~ $d$两段路径公共的点的个数。\n\n解题思路:\n读完题就感觉是树链剖分的裸题呀...\n把每个点的值初始化为$0$，对于每次询问，把$a$ ~ $b$这条路径的值$+1$，查询$c$ ~ $d$的区间和，再把$a$ ~ $b$这条路径的值$-1$改回来。$c$ ~ $d$的区间和就是交点数量。\n\n代码:\n(就是树链剖分维护点权的板子，改了下main就过了...)\n\n```\n#include \u003ccstdio\u003e\n#include \u003ccstring\u003e\n#include \u003calgorithm\u003e\nusing namespace std;\nconst int maxn = 100000+10;\nint w[maxn];\nint N, Q;\nstruct\n{\n    int to,next;    \n}e[maxn\u003c\u003c1];\n\nint head[maxn],edgeNum;\nvoid add(int u,int v)\n{\n    e[edgeNum].next = head[u];\n    e[edgeNum].to = v;\n    head[u] = edgeNum++;\n}\n\n/*-------------------------树剖------------------------------*/\nint deep[maxn],fa[maxn],siz[maxn],son[maxn];\nvoid dfs1(int u,int pre,int d)\n{\n    deep[u] = d;\n    fa[u] = pre;\n    siz[u] = 1;\n    son[u] = 0;\n    for(int i=head[u];~i;i=e[i].next)\n    {\n        int v = e[i].to;\n        if(v!=pre)\n        {\n            dfs1(v,u,d+1);\n            siz[u] += siz[v];\n            if(siz[v]\u003esiz[son[u]])\n                son[u] = v;\n        }\n    }\n}\n\nint top[maxn],id[maxn],rk[maxn],cnt;\nint \u0026n = cnt;\nvoid dfs2(int u,int t)\n{\n    top[u] = t;\n    id[u] = ++cnt;\n    rk[cnt] = u;\n    if(!son[u]) return;\n\n    dfs2(son[u],t);\n\n    for(int i=head[u];~i;i=e[i].next)\n    {\n        int v = e[i].to;\n        if(v!=son[u]\u0026\u0026v!=fa[u])\n            dfs2(v,v);\n    }\n}\n/*-------------------------树剖------------------------------*/\n\n/*-------------------------线段树------------------------------*/\n#define lson l,m,rt\u003c\u003c1\n#define rson m+1,r,rt\u003c\u003c1|1\nint sum[maxn\u003c\u003c2],lazy[maxn\u003c\u003c2];\nvoid pushup(int rt)\n{\n    sum[rt] = (sum[rt\u003c\u003c1] + sum[rt\u003c\u003c1|1]);\n}\n\nvoid build(int l,int r,int rt)\n{\n    if(l==r)\n    {\n        sum[rt] = w[rk[l]];\n        return ;\n    }\n    int m = l+r\u003e\u003e1;\n    build(lson);\n    build(rson);\n    pushup(rt);\n}\n\nvoid pushdown(int rt,int l,int r)\n{\n    if(lazy[rt])\n    {\n        lazy[rt\u003c\u003c1] = (lazy[rt\u003c\u003c1] + lazy[rt]);\n        lazy[rt\u003c\u003c1|1] = (lazy[rt\u003c\u003c1|1] + lazy[rt]);\n        sum[rt\u003c\u003c1] += (lazy[rt] * l);\n        sum[rt\u003c\u003c1|1] += (lazy[rt] * r);\n        lazy[rt] = 0;\n    }\n}\n\nvoid update(int L,int R,int val,int l,int r,int rt)\n{\n    if(L\u003c=l\u0026\u0026r\u003c=R)\n    {\n        sum[rt] = (sum[rt] + (val) * ((r-l+1)));\n        lazy[rt] += val;\n        return ;\n    }\n    int m = l + r \u003e\u003e 1;\n    pushdown(rt,m-l+1,r-m);\n    if(L\u003c=m)\n        update(L,R,val,lson);\n    if(R\u003em)\n        update(L,R,val,rson);\n    pushup(rt);\n}\n\nint query(int L,int R,int l,int r,int rt)\n{\n    if(L\u003c=l\u0026\u0026r\u003c=R)\n        return sum[rt];\n    int m = l + r \u003e\u003e 1,ans = 0;\n    pushdown(rt,m-l+1,r-m);\n    if(L\u003c=m)\n        ans = (ans + query(L,R,lson));\n    if(R\u003em)\n        ans = (ans + query(L,R,rson));\n    return ans;\n}\n/*-------------------------线段树------------------------------*/\n\n/*-----------------------树剖加线段树--------------------------*/\nvoid update(int x,int y,int z)\n{\n    while(top[x]!=top[y])\n    {\n        if(deep[top[x]]\u003cdeep[top[y]])\n            swap(x,y);\n        update(id[top[x]],id[x],z,1,n,1);\n        x = fa[top[x]];\n    }\n    if(deep[x]\u003edeep[y])\n        swap(x,y);\n    update(id[x],id[y],z,1,n,1);\n}\n\nint query(int x,int y)\n{\n    int ans = 0;\n    while(top[x] != top[y])\n    {\n        if(deep[top[x]] \u003c deep[top[y]])\n            swap(x,y);\n        ans = (ans + query(id[top[x]],id[x],1,n,1));\n        x = fa[top[x]];\n    }\n    if(deep[x]\u003edeep[y])\n        swap(x,y);\n    ans = (ans + query(id[x],id[y],1,n,1));\n    return ans;\n}\n/*-----------------------树剖加线段树--------------------------*/\n\nvoid init()\n{\n    memset(head,-1,4*N+4);\n    cnt = edgeNum = 0;\n}\n\nint u, v, x1, y1, x2, y2;\nint main()\n{   \n   \tscanf(\"%d%d\",\u0026N,\u0026Q);\n   \tinit();\n   \tfor(int i=1;i\u003cN;++i)\n\t{\n\t\tw[i] = 0;\n\t\tscanf(\"%d%d\",\u0026u,\u0026v);\n\t\tadd(u,v);\n\t\tadd(v,u);\n\t}\n\tdfs1(1,0,0);\n\tdfs2(1,1);\n\tbuild(1,n,1);\n\twhile(Q--)\n\t{\n\t\tscanf(\"%d%d%d%d\",\u0026x1,\u0026y1,\u0026x2,\u0026y2);\n\t\tupdate(x1,y1,1);\n\t\tprintf(\"%d\\n\",query(x2,y2));\n\t\tupdate(x1,y1,-1);\n\t}\n    return 0;\n}\n```\n\n",
        "Title": "Gym - 101908L 树链剖分裸题",
        "CreateTime": 1539856183000,
        "FormatTime": "2018.10.18",
        "Categories": "数据结构,树上算法",
        "Tags": [
            ""
        ],
        "EditorType": "markdown"
    },
    {
        "Content": "这学期当助教，得在PTA出题目。用这份模板通过ac代码生成数据。\n\n```\n#include \u003ciostream\u003e\n#include \u003ccstdio\u003e\n#include \u003ccstring\u003e\nusing namespace std;\n\nchar n[16];\nint ans;\nint main()\n{\n\t#ifdef LOCAL\n\tfreopen(\"F:\\\\data\\\\题目\\\\data.txt\",\"r\",stdin);//用data.txt存放所有的输入数据 \n\tchar in[] = \"F:\\\\data\\\\题目\\\\0.in\";//数据的输入 \n\tchar out[] = \"F:\\\\data\\\\提米\\\\0.out\";//数据的输出 \n\tint I = strlen(in) - 4;//用来修改字符串 \n\tint O = strlen(out) - 5;\n\t#endif\n\twhile(cin \u003e\u003e n)\n\t{\n\t\t#ifdef LOCAL\n\t\tfreopen(in,\"w\",stdout);//重定向样例的输入数据 \n\t\tcout \u003c\u003c n \u003c\u003c endl; \n\t\tfclose(stdout);\n\t\tin[I]++;//改字符串，下次输出到新的文件中 \n\t\t#endif\n\t\tans = 0;\n\t\tint len = strlen(n);\n\t\tfor(int i=0;i\u003clen;++i)\n\t\t{\n\t\t\tans *= 2;\n\t\t\tans += n[i] - '0';\n\t\t}\n\t\t#ifdef LOCAL\n\t\tfreopen(out,\"w\",stdout);//重定向样例的输出数据 \n\t\tcout \u003c\u003c ans \u003c\u003c endl;\n\t\tfclose(stdout);\n\t\tout[O]++;//改字符串，下次输出到新的文件中 \n\t\t#endif\n\t}\n\treturn 0;\n}\n```\n比较简陋，只能出十组数据。\n\n",
        "Title": "PTA出题生成数据的模板",
        "CreateTime": 1539773224000,
        "FormatTime": "2018.10.17",
        "Categories": "杂",
        "Tags": [
            ""
        ],
        "EditorType": "markdown"
    },
    {
        "Content": "二分查找可以在有序的支持随机访问的容器中快速查找某个元素的信息\n时间复杂度: $O(logN)$\n\n原始版本:\n递归实现:\n\n```\nint binarySearch(int a[],int val,int l,int r)\n{\n    if(l \u003e r) return -1;\n    \n    int m = l + r \u003e\u003e 1;\n    if (val == a[m])\n        return m;\n    else if (val \u003c a[m])\n        return binarySearch(a,val,l,m-1);\n    else\n        return binarySearch(a,val,m+1,r);\n}\n```\n\n非递归实现:\n\n```\nint binarySearch(int a[],int val,int l,int r)\n{\n    int m, ret = -1;\n    while(l \u003c= r)\n    {\n        m = l + r \u003e\u003e 1;\n        if (val == a[m])\n        {\n            ret = m;\n            break;\n        }\n        else if(val \u003c a[m]) \n            r = m - 1;\n        else \n            l = m + 1;\n    }\n    return ret;\n}\n```\nC++ STL中提供了三种二分查找函数\n1、**binary_search(f1,f2,val)**\n\u0026ensp;\u0026ensp;\u0026ensp;\u0026ensp;返回区间$[f1,f2)$中是否存在val，存在则返回$true$，否则返回$false$。\n\n2、****lower_bound(f1,f2,val)****\n\u0026ensp;\u0026ensp;返回区间$[f1,f2)$中第一个大于等于$val$的元素的下标\n丑陋的实现：\n```\nint my_lower_bound(int a[],int val,int l,int r)\n{\n    int m;\n    while(l \u003c r)\n    {\n        m = l + r \u003e\u003e 1;\n        if(val \u003c= a[m])\n            r = m;\n        else\n            l = m + 1;\n    }\n    return l;\n}\n```\n\n3、****upper_bound(f1,f2,val)****\n\u0026ensp;\u0026ensp;返回区间$[f1,f2)$中第一个大于$val$的元素的下标\n丑陋的实现：\n```\nint my_upper_bound(int a[],int val,int l,int r)\n{\n    int m;\n    while(l \u003c r)\n    {\n        m = l + r \u003e\u003e 1;\n        if(val \u003c a[m])\n            r = m;\n        else\n            l = m + 1;\n    }\n    return l;\n}\n```\n\n需要注意的是传入的区间都是**左闭右开**的\n",
        "Title": "对二分法思想的体会",
        "CreateTime": 1539495025000,
        "FormatTime": "2018.10.14",
        "Categories": "算法作业",
        "Tags": [
            ""
        ],
        "EditorType": "markdown"
    },
    {
        "Content": "前几天网络赛的一个题，找了下规律发现是要输出$2^{n-1}$，$1$ $\\leq$ $n$ $\\leq$ $10^{200}$，答案对1000000007取模，直接快速幂肯定超时。\n百度了下，于是学到了费马小定理： 假如p是质数，且gcd(a,p)=1，那么 $a^{p-1}$ $\\equiv$ 1(mod p)\n证明见[百度百科](https://baike.baidu.com/item/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86/4776158?fr=aladdin)\n于是$a^{n}$ % 1000000007 $\\equiv$ $a^{r}$ % $1000000007$，其中 $r$ $=$ $n$ % $1000000006$\n只需要在输入的时候用字符串存一个大数，遍历一次进行取模，就可以在int范围内跑快速幂了\n\n",
        "Title": "快速幂 N很大的时候",
        "CreateTime": 1537192124000,
        "FormatTime": "2018.09.17",
        "Categories": "数论",
        "Tags": [
            ""
        ],
        "EditorType": "markdown"
    },
    {
        "Content": "题目链接：https://nanti.jisuanke.com/t/31714\n题意 ：一棵树，n个点，初值均为0，有四个操作:\n1 u v x 把u v路径上所有点乘以x\n2 u v x 把u v路径上所有点加上x\n3 u v    把u v路径上所有点的值按位取反\n4 u v    查询u v路径上所有点的和\n答案 % $2^{64}$后输出\n\n分析：\n除了3，1 2 4就是裸轻重链剖分 + 线段树维护区间和\n赛后看了别人的题解才知道怎么处理3。取反就等价于$*$$-1$再$-1$\n$2^{64}$也不用模的，用unsigned long long直接自然溢出就好了...\n\npushdown的时候要想清楚乘和加的先后，\n每次初始化一定要根据n来。 全初始化T成智障...\n\n```\n#include \u003ccstdio\u003e\n#include \u003cvector\u003e\n#include \u003calgorithm\u003e\n#include \u003ccstring\u003e\n\nusing namespace std;\nconst int maxn = (int)1e5 + 5;\ntypedef unsigned long long ull;\nconst ull inf = (1 \u003c\u003c 64) - 1;\nint N,fa[maxn],M;\nvector\u003cint\u003e G[maxn];\n\nint deep[maxn], son[maxn], siz[maxn];\nvoid dfs1(int u)\n{\n    siz[u] = 1;\n    son[u] = 0;\n    deep[u] = deep[fa[u]] + 1;\n    for (int v:G[u])\n    {\n        dfs1(v);\n        siz[u] += siz[v];\n        if (siz[v] \u003e siz[son[u]])\n            son[u] = v;\n    }\n}\n\nint top[maxn],id[maxn],cnt;\nvoid dfs2(int u,int t)\n{\n    top[u] = t;\n    id[u] = ++cnt;\n    if (son[u])\n        dfs2(son[u],t);\n\n    for (int v:G[u])\n    {\n        if (v != son[u] \u0026\u0026 v != fa[u])\n            dfs2(v,v);\n    }\n}\n\n#define ls l,m,rt\u003c\u003c1\n#define rs m+1,r,rt\u003c\u003c1|1\null sum[maxn\u003c\u003c2],add[maxn\u003c\u003c2],mult[maxn\u003c\u003c2],rev[maxn\u003c\u003c2];\n\nvoid pushdown(int rt,int l,int r)\n{\n    add[rt\u003c\u003c1] *= mult[rt],   add[rt\u003c\u003c1] += add[rt];\n    add[rt\u003c\u003c1|1] *= mult[rt], add[rt\u003c\u003c1|1] += add[rt];\n    mult[rt\u003c\u003c1] *= mult[rt];\n    mult[rt\u003c\u003c1|1] *= mult[rt];\n\n    sum[rt\u003c\u003c1] *= mult[rt], sum[rt\u003c\u003c1] += add[rt] * l;\n    sum[rt\u003c\u003c1|1] *= mult[rt], sum[rt\u003c\u003c1|1] += add[rt] * r;\n\n    add[rt] = 0;\n    mult[rt] = 1;\n}\n\nvoid update(int L,int R,ull v,int l,int r,int rt,int op)\n{\n    if(L \u003c= l \u0026\u0026 r \u003c= R)\n    {\n        if(op == 1)\n            sum[rt] *= v, mult[rt] *= v, add[rt] *= v;\n        else if(op == 2)\n            sum[rt] += (ull)(r-l+1)*v, add[rt] += v;\n        else if(op == 3)\n        {\n            sum[rt] *= inf, sum[rt] += (r-l+1)*inf;\n            add[rt] *= inf, add[rt] += inf;\n            mult[rt] *= inf;\n        }\n        return ;\n    }\n    int m = l + r \u003e\u003e 1;\n    pushdown(rt,m-l+1,r-m);\n    if (L \u003c= m)\n        update(L,R,v,ls,op);\n    if(R \u003e m)\n        update(L,R,v,rs,op);\n    sum[rt] = sum[rt\u003c\u003c1] + sum[rt\u003c\u003c1|1];\n}\n\null query(int L,int R,int l,int r,int rt)\n{\n    if(L \u003c= l \u0026\u0026 r \u003c= R)\n        return sum[rt];\n    int m = l + r \u003e\u003e 1;\n    pushdown(rt,m-l+1,r-m);\n    ull ans = 0;\n    if (L \u003c= m)\n        ans += query(L,R,ls);\n    if(R \u003e m)\n        ans += query(L,R,rs);\n    return ans;\n}\n\nvoid upd(int u,int v,int op,ull val = 0)\n{\n    while(top[u] != top[v])\n    {\n        if(deep[top[u]] \u003c deep[top[v]])\n            swap(u,v);\n        update(id[top[u]],id[u],val,1,cnt,1,op);\n        u = fa[top[u]];\n    }\n    if(deep[u] \u003e deep[v])\n        swap(u,v);\n    update(id[u],id[v],val,1,cnt,1,op);\n}\n\null que(int u,int v)\n{\n    ull ans = 0;\n    while(top[u] != top[v])\n    {\n        if(deep[top[u]] \u003c deep[top[v]])\n            swap(u,v);\n        ans += query(id[top[u]],id[u],1,cnt,1);\n        u = fa[top[u]];\n    }\n    if(deep[u] \u003e deep[v])\n        swap(u,v);\n    ans += query(id[u],id[v],1,cnt,1);\n    return ans;\n}\n\nvoid build(int l,int r,int rt)\n{\n    sum[rt] = add[rt] = 0;\n    mult[rt] = 1;\n    if(l == r)\n        return ;\n    int m = l + r \u003e\u003e 1;\n    build(ls);\n    build(rs);\n}\n\nvoid init()\n{\n    cnt = 0;\n}\n\nint main()\n{\n    int op,l,r;\n    ull val;\n    while (scanf(\"%d\",\u0026N) != EOF)\n    {\n        init();\n        for (int i = 2; i \u003c= N; ++i)\n        {\n            scanf(\"%d\",\u0026fa[i]);\n            G[fa[i]].emplace_back(i);\n        }\n\n        scanf(\"%d\",\u0026M);\n        dfs1(1);\n        dfs2(1,1);\n        build(1,cnt,1);\n        while (M--)\n        {\n            scanf(\"%d%d%d\",\u0026op,\u0026l,\u0026r);\n            if(op != 4)\n            {\n                if(op != 3)\n                    scanf(\"%llu\",\u0026val);\n                upd(l,r,op,val);\n            }\n            else\n                printf(\"%llu\\n\",que(l,r));\n        }\n        for(int i=1;i\u003c=N;++i)\n            G[i].clear();\n    }\n    return 0;\n}\n\n```\n\n",
        "Title": "Jiu Yuan Wants to Ea 2018icpc焦作网络预选赛E",
        "CreateTime": 1537170788000,
        "FormatTime": "2018.09.17",
        "Categories": "数据结构,树上算法",
        "Tags": [
            ""
        ],
        "EditorType": "markdown"
    },
    {
        "Content": "题目链接:https://nanti.jisuanke.com/t/31462\n\n题意:\n在一个N*M的空地上，建墙造一个迷宫，使得迷宫的耗费最小，且迷宫中的任意两点之间只有一条路，题目保证每组数据的迷宫唯一。\n输入迷宫中两个点的坐标，输出两点间的距离\n\n思路:任意两点间只有一条路，显然是一棵树。在地图上建最大生成树，就可以使得墙的耗费最小。两点间距离就是在树上跑LCA\n\n```\n#include \u003ccstdio\u003e\n#include \u003cqueue\u003e\n#include \u003cvector\u003e\n#include \u003ccstring\u003e\n#include \u003calgorithm\u003e\n\nusing namespace std;\n\nconst int maxn = (int)3e5 + 5;\nint N,M,Q;\n#define getpos(i,j) (i-1)*M + j\n\nstruct Edge\n{\n    int u,v,w;\n    Edge(int _u=0,int _v=0,int _w=0)\n    {\n        u = _u;\n        v = _v;\n        w = _w;\n    }\n    bool operator\u003c(const Edge a) const\n    {\n        return w \u003e a.w;\n    }\n};\n\nvector\u003cEdge\u003e e;\nvector\u003cint\u003e G[maxn];\nint f[maxn];\nint Find(int x)\n{\n    return x == f[x] ? x : f[x] = Find(f[x]);\n}\n\nint deep[maxn],in[maxn],out[maxn],cnt,anc[maxn][21],dis;\nvoid dfs(int u,int fa)\n{\n    in[u] = ++cnt;\n    deep[u] = deep[fa] + 1;\n    anc[u][0] = fa;\n    for (int i = 1; i \u003c= 20; ++i)\n    {\n        anc[u][i] = anc[anc[u][i-1]][i-1];\n        if(!anc[u][i])\n            break;\n    }\n    for(auto v:G[u])\n    {\n        if(v!=fa)\n            dfs(v,u);\n    }\n    out[u] = cnt;\n}\n\nint lca(int a,int b)\n{\n    if(deep[a]\u003edeep[b])\n        swap(a,b);\n    if(in[a] \u003c= in[b] \u0026\u0026 out[b] \u003c= out[a])\n        return a;\n    for(int i=20;~i;--i)\n        if(deep[a] \u003c deep[b] \u0026\u0026 deep[a] \u003c= deep[anc[b][i]])\n            b = anc[b][i];\n    for(int i=20;~i;--i)\n        if(anc[a][i]!=anc[b][i])\n            a = anc[a][i], b = anc[b][i];\n    return anc[a][0];\n}\n\nvoid init()\n{\n    cnt = 0;\n    for (int i = 1; i \u003c maxn; ++i)\n    {\n        f[i] = i;\n    }\n    deep[0] = 0;\n\n}\n\nint main()\n{\n    init();\n    int u, v, w;\n    char dir[2];\n    scanf(\"%d%d\",\u0026N,\u0026M);\n    for(int i = 1;i \u003c= N; ++i)\n    {\n        for (int j = 1; j \u003c= M ; ++j)\n        {\n            u = getpos(i,j);\n            for (int k = 0; k \u003c 2; ++k)\n            {\n                scanf(\"%s%d\",dir,\u0026w);\n                if (dir[0] == 'D')\n                    v = getpos(i+1,j);\n                else if (dir[0] == 'R')\n                    v = getpos(i,j+1);\n                else\n                    continue;\n                e.emplace_back(Edge(u,v,w));\n            }\n        }\n    }\n    sort(e.begin(),e.end());\n    int x, y;\n    for (auto i:e)\n    {\n        x = Find(i.u);\n        y = Find(i.v);\n        if(x!=y)\n        {\n            G[i.v].emplace_back(i.u);\n            G[i.u].emplace_back(i.v);\n            f[x] = y;\n        }\n    }\n    dfs(getpos(1,1),0);\n    scanf(\"%d\",\u0026Q);\n    int x1, y1, x2, y2, L;\n    while(Q--)\n    {\n        scanf(\"%d%d%d%d\",\u0026x1,\u0026y1,\u0026x2,\u0026y2);\n        u = getpos(x1,y1), v = getpos(x2,y2);\n        L = lca(u,v);\n        printf(\"%d\\n\",deep[u] + deep[v] - 2*deep[L]);\n    }\n    return 0;\n}\n```",
        "Title": "ACM-ICPC 2018 徐州赛区网络预赛 J - Maze Designer",
        "CreateTime": 1536843620000,
        "FormatTime": "2018.09.13",
        "Categories": "图算法,树上算法",
        "Tags": [
            ""
        ],
        "EditorType": "markdown"
    },
    {
        "Content": "聪聪和可可是兄弟俩，他们俩经常为了一些琐事打起来，例如家中只剩下最后一根冰棍而两人都想吃、两个人都想玩儿电脑（可是他们家只有一台电脑）……遇到这种问题，一般情况下石头剪刀布就好了，可是他们已经玩儿腻了这种低智商的游戏。他们的爸爸快被他们的争吵烦死了，所以他发明了一个新游戏：由爸爸在纸上画n个“点”，并用n-1条“边”把这n个“点”恰好连通（其实这就是一棵树）。并且每条“边”上都有一个数。接下来由聪聪和可可分别随即选一个点（当然他们选点时是看不到这棵树的），如果两个点之间所有边上数的和加起来恰好是3的倍数，则判聪聪赢，否则可可赢。聪聪非常爱思考问题，在每次游戏后都会仔细研究这棵树，希望知道对于这张图自己的获胜概率是多少。现请你帮忙求出这个值以验证聪聪的答案是否正确。\n\nInput\n输入的第1行包含1个正整数n。后面n-1行，每行3个整数x、y、w，表示x号点和y号点之间有一条边，上面的数是w。\n\nOutput\n以即约分数形式输出这个概率（即“a/b”的形式，其中a和b必须互质。如果概率为1，输出“1/1”）。\n\nSample Input\n5\n1 2 1\n1 3 2\n1 4 1\n2 5 3\nSample Output\n13/25\n【样例说明】\n13组点对分别是(1,1) (2,2) (2,3) (2,5) (3,2) (3,3) (3,4) (3,5) (4,3) (4,4) (5,2) (5,3) (5,5)。\n\n【数据规模】\n对于100%的数据，n\u003c=20000。\n\n线性结构在分治时一般选择二分，因为这样可以使得分出来子结构中最大的那个最小，划分的次数少，递归的深度小\n同样的，对树进行分治时，也要尽可能让分出来的最大的子树小，这样递归的深度才小\n树的重心: 以一个点为根，若这个点的最大子树最小，则这个点是树的重心\n\n树重心的求法:\n先假设一个重心，让它的最大子树大小为inf\ndfs整棵树，对每个点，记录它最大子树的大小，如果它的最大子树大小比重心的最大子树要小，更新重心\n因为树本身是无向的，但dfs是随便找一个点 当根，有向地搜的，所以父亲结点那边也是一棵子树。\n\n```\nint root,f[maxn],vis[maxn],siz[maxn],sum;//f[u]表示以u为根的最大子树的大小\nvoid getroot(int u,int fa)\n{\n    siz[u] = 1, f[u] = 0;\n    for(int i=head[u];~i;i=e[i].next)\n    {\n        int v = e[i].to;\n        if(v==fa || vis[v]) continue;\n        getroot(v,u);\n        siz[u] += siz[v];\n        f[u] = max(f[u],siz[v]);//找子树大小的最大值\n    }\n    f[u] = max(f[u],sum - siz[u]);//把父亲看作是连在上方的子树,getroot前把sum初始化为整棵树的大小\n    if(f[u] \u003c f[root])\n        root = u;\n}\n```\n找完重心就以重心为根dfs处理子树信息\n\n处理树中路径信息时，有两种情况: 经过根节点(跨子树) 和 不经过根节点(在一棵子树中)\n处理的时候是无论经过与否一并统计的。可以发现，不经过根节点的路径在某个子树中一定是经过那个子树的根的\n也就是说这部分的信息计了两次。把子树的信息算一遍减掉得到的就是正确答案了。\n\n```\nint t[3];\nvoid getdis(int u,int dis,int fa)//把u为根的子树的信息全处理出来\n{\n    ++t[dis];\n    for(int i=head[u];~i;i=e[i].next)\n    {\n        int v = e[i].to;\n        if(v!=fa\u0026\u0026!vis[v])\n            getdis(v,(dis + e[i].w)%3,u);\n    }\n}\n\nint calc(int u,int dis)\n{\n    t[0] = t[1] = t[2] = 0;\n    getdis(u,dis%3,0);\n    return t[0]*t[0] + 2*t[1]*t[2];\n    //t[0]记录的是子树中到u的距离为3的倍数的点，这些点两两间的路径显然距离也是3\n    //t[1]的点到t[2]的点的路径距离是3的倍数，正反两个方向*2\n}\n\nint ans;\nvoid solve(int u)//先加上u的贡献，再减去u的子树v的贡献\n{\n    ans += calc(u,0);\n    vis[u] = 1;//相当于删除u这个点\n    for(int i=head[u];~i;i=e[i].next)\n    {\n        int v = e[i].to;\n        if(vis[v]) continue;\n        ans -= calc(v,e[i].w);\n        root = 0, sum = siz[v];\n        f[root] = 0x7fffffff;\n        getroot(v,0);\n        solve(root);\n    }\n}\n```\n为什么减去的部分一开始是e[i].w呢, 因为getdis算出来的是子树中每个点到根的距离,而不经过根的路径每次计算必然都算多了根和根的儿子这一路径\n\n完整代码\n```\n#include\u003ccstdio\u003e\n#include\u003calgorithm\u003e\n#include\u003ccstring\u003e\nusing namespace std;\n\nconst int maxn = 2e4 + 5;\nint N;\nstruct Edge\n{\n    int to, next, w;\n}e[maxn\u003c\u003c1];\n\nint edgenum,head[maxn];\nvoid add(int u,int v,int w)\n{\n    e[edgenum].to = v;\n    e[edgenum].next = head[u];\n    e[edgenum].w = w;\n    head[u] = edgenum++;\n}\n\nint root,f[maxn],vis[maxn],siz[maxn],sum;//f[u]表示以u为根的最大子树的大小\nvoid getroot(int u,int fa)\n{\n    siz[u] = 1, f[u] = 0;\n    for(int i=head[u];~i;i=e[i].next)\n    {\n        int v = e[i].to;\n        if(v==fa || vis[v]) continue;\n        getroot(v,u);\n        siz[u] += siz[v];\n        f[u] = max(f[u],siz[v]);//找子树大小的最大值\n    }\n    f[u] = max(f[u],sum - siz[u]);//把父亲看作是连在上方的子树\n    if(f[u] \u003c f[root])\n        root = u;\n}\n\nint t[3];\nvoid getdis(int u,int dis,int fa)//把u为根的子树的信息全处理出来\n{\n    ++t[dis];\n    for(int i=head[u];~i;i=e[i].next)\n    {\n        int v = e[i].to;\n        if(v!=fa\u0026\u0026!vis[v])\n            getdis(v,(dis + e[i].w)%3,u);\n    }\n}\n\nint calc(int u,int dis)\n{\n    t[0] = t[1] = t[2] = 0;\n    getdis(u,dis%3,0);\n    return t[0]*t[0] + 2*t[1]*t[2];\n    //t[0]记录的是子树中到u的距离为3的倍数的点，这些点两两间的路径显然距离也是3\n    //t[1]的点到t[2]的点的路径距离是3的倍数，正反两个方向*2\n}\n\nint ans;\nvoid solve(int u)//先加上u的贡献，再减去u的子树v的贡献\n{\n    ans += calc(u,0);\n    vis[u] = 1;//相当于删除u这个点\n    for(int i=head[u];~i;i=e[i].next)\n    {\n        int v = e[i].to;\n        if(vis[v]) continue;\n        ans -= calc(v,e[i].w);\n        root = 0, sum = siz[v];\n        f[root] = 0x7fffffff;\n        getroot(v,0);\n        solve(root);\n    }\n}\n\nvoid init(int N)\n{\n    ans = root = 0;\n    sum = N;\n    f[0] = 0x7fffffff;\n    ++N;\n    memset(head,-1,4*N);\n    memset(vis,0,4*N);\n}\n\nint gcd(int a,int b)\n{\n\treturn b==0 ? a : gcd(b,a%b);\n}\n\nint main()\n{\n    int u,v,w,a;\n    scanf(\"%d\",\u0026N);\n    init(N);\n    for(int i=0;i\u003cN-1;++i)\n    {\n        scanf(\"%d%d%d\",\u0026u,\u0026v,\u0026w);\n        add(u,v,w%3);\n        add(v,u,w%3);\n    }\n    getroot(1,0);//随便找一个点把无根树拉成有根树，第一个参数填什么都行(只要\u003c=N,填1最稳)\n    //跑完getroot之后root就是树的重心了\n\n    solve(root);\n    a = gcd(N*N,ans);\n    printf(\"%d/%d\\n\",ans/a,N*N/a);\n\treturn 0;\n}\n```",
        "Title": "树的点分治 bzoj2152",
        "CreateTime": 1536304992000,
        "FormatTime": "2018.09.07",
        "Categories": "树上算法",
        "Tags": [
            ""
        ],
        "EditorType": "markdown"
    },
    {
        "Content": "Splay，中文名伸展树，是由tarjan大神发明的... orz\n本质上就是BST加上splay操作——把结点x旋转到指定结点的下面。\n每次查询完都把查到的数旋转到根，就可以让所有查找的时间效率为均摊O(logN) (不知道为啥...大佬说是就是吧orz)\n\n因为Splay可以通过伸展操作随意改变树的结构，只要把排名L-1的结点伸展到根，把排名R+1的结点伸展到根的右孩子，R+1结点的左子树就包含了区间[L,R]中所有的点，所以Splay做区间操作非常方便。\n\n缺点大概就是大得惊人的常数吧。\n\nSplay的定义:\n\n```\nint ch[maxn][2], fa[maxn], val[maxn], siz[maxn], lazy[maxn];\nint tot,root;\n#define ls ch[now][0]\n#define rs ch[now][1]\n```\n跟Treap的定义基本一样的，少个优先级，多个fa数组记录该结点的父亲。lazy是题目要用的翻转标记。\n宏是用来偷懒的~\n\n为什么Treap不要fa，Splay要？\n因为Splay操作要用到父亲的父亲，不记录fa不会写。\n\n旋转rotate:\n跟所有平衡树的旋转都是一样的。get函数用来判断该结点是它父亲的哪个儿子。因为要维护区间，有些地方要pushup(把x旋转到y的上面之后，y的子树大小要重新计算)\n贴张丑图以供想象\n![这里写图片描述](https://img-blog.csdn.net/20180906195141548?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FwYWxlXzg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n```\nbool get(int x)//返回x是它父亲的哪个儿子\n{\n    return x == ch[fa[x]][1];\n}\n\nvoid connect(int son,int f,int dir)\n{\n    fa[son] = f;\n    ch[f][dir] = son;\n}\n\nint y,z,yson,zson,xson;\nvoid Rotate(int x)//把x旋转到fa[x]的位置,用get来判断要左旋还是右旋\n{\n    y = fa[x];\n    z = fa[y];\n    yson = get(x), zson = get(y);//记录x和y是他们父亲的哪个儿子\n    xson = ch[x][yson^1];\n    connect(x,z,zson);\n    connect(y,x,yson^1);\n    connect(xson,y,yson);\n    pushup(y);\n}\n```\n\n伸展splay——把x旋转到to的下面，成为to的儿子\n三种情况:\n1.fa[fa[x]] == to\t\t\t\n往上旋一次即可\n2.get(x) == get(fa[x])\n设y是x的父亲，z是y的父亲，这种情况下，xyz是共线的（自行脑补）\ntarjan大佬说这种情况要先把y旋上去，再把x旋上去\n3.其他情况\nx往上旋两次\n\n```\nvoid splay(int x,int to)//把x旋转到to的下面\n{\n    pushdown(x);//旋转后会改变结点关系，先下推标记！\n    while(fa[x] != to)\n    {\n        if(fa[fa[x]] == to)\n            Rotate(x);\n        else if(get(x)==get(fa[x]))\n            Rotate(fa[x]), Rotate(x);\n        else\n            Rotate(x), Rotate(x);\n    }\n    pushup(x);//旋转后会子树大小会变，更新\n    if(to == 0)//x移到根了，更新根\n        root = x;\n}\n```\n建树build:\n跟线段树差不多，多传一个参数f用来维护fa数组\n```\nvoid build(int l,int r,int \u0026now,int f)\n{\n    if(l\u003er) return ;\n    int m = l + r \u003e\u003e 1;\n    newnode(m,now,f);\n    build(l,m-1,ls,now);\n    build(m+1,r,rs,now);\n    pushup(now);\n}\n```\n\n更新update(本题的更新是翻转)\n首先把 L-1 splay到root，把 R+1 splay到root下面\nbuild前要插入两个虚结点0和N+1，不然splay操作会越界\n\n```\n    newnode(0,root,0);\n    newnode(N+1,ch[root][1],root);\n    build(1,N,ch[ch[root][1]][0],ch[root][1]);\n```\n\n但splay函数是把下标为x的结点旋转到下标的to的结点下面，这里的结点编号跟要维护的区间的下标是不一致的\n区间就是BST的中序序列，写个find函数把区间下标对应的结点编号求出来\n\n```\nint findk(int k,int now)//找区间中第k个数字的下标(0是第一个)\n{\n    pushdown(now);//往下找之前要pushdown(可能左右子树需要翻转)\n    if(k == siz[ls]+1) return now;\n    else if(k \u003c= siz[ls]) return findk(k,ls);\n    else return findk(k-siz[ls]-1,rs);\n}\n```\n上面也提到了，0是区间中的第一个数字，所以要splay的是L和R+2\n\n```\nvoid update(int L,int R)\n{\n    int \u0026now = root;//为了用上面那个宏弄了个引用...(一开始没写引用狂T o(╥﹏╥)o)\n    splay(findk(L,root),0);\n    splay(findk(R+2,root),root);\n    lazy[ch[rs][0]] ^= 1;\n    pushup(rs);\n    pushup(root);\n}\n```\n\n完整代码\n\n```\n#include\u003ccstdio\u003e\n#include\u003calgorithm\u003e\nusing namespace std;\n\nconst int maxn = 1e5 + 5;\nint ch[maxn][2], fa[maxn], val[maxn], siz[maxn], lazy[maxn];\nint tot,root;\n#define ls ch[now][0]\n#define rs ch[now][1]\nint N,M;\nvoid newnode(int v,int \u0026x,int f)\n{\n    x = ++tot;\n    ch[x][0] = ch[x][1] = 0;\n    val[x] = v;\n    siz[x] = 1;\n    lazy[x] = 0;\n    fa[x] = f;\n}\n\nbool get(int x)//返回x是它父亲的哪个儿子\n{\n    return x == ch[fa[x]][1];\n}\n\nvoid pushup(int now)\n{\n    if(now)\n        siz[now] = siz[ls] + siz[rs] + 1;\n}\n\nvoid pushdown(int now)\n{\n    if(lazy[now])\n    {\n        lazy[ls] ^= 1;\n        lazy[rs] ^= 1;\n        swap(ls,rs);//翻转把左右子树交换一下就好了\n        lazy[now] = 0;\n    }\n}\n\nvoid connect(int son,int f,int dir)\n{\n    fa[son] = f;\n    ch[f][dir] = son;\n}\n\nint y,z,yson,zson,xson;\nvoid Rotate(int x)//把x旋转到fa[x]的位置,用get来判断要左旋还是右旋\n{\n    y = fa[x];\n    z = fa[y];\n    yson = get(x), zson = get(y);//记录x和y是他们父亲的哪个儿子\n    xson = ch[x][yson^1];\n    connect(x,z,zson);\n    connect(y,x,yson^1);\n    connect(xson,y,yson);\n    pushup(y);\n}\n\nvoid splay(int x,int to)//把x旋转到to的下面\n{\n    pushdown(x);\n    while(fa[x] != to)\n    {\n        if(fa[fa[x]] == to)\n            Rotate(x);\n        else if(get(x)==get(fa[x]))\n            Rotate(fa[x]), Rotate(x);\n        else\n            Rotate(x), Rotate(x);\n    }\n    pushup(x);\n    if(to == 0)//x移到根了，更新根\n        root = x;\n}\n\nvoid build(int l,int r,int \u0026now,int f)\n{\n    if(l\u003er) return ;\n    int m = l + r \u003e\u003e 1;\n    newnode(m,now,f);\n    build(l,m-1,ls,now);\n    build(m+1,r,rs,now);\n    pushup(now);\n}\n\nint findk(int k,int now)//找区间中第k个数字的下标(0是第一个)\n{\n    pushdown(now);\n    if(k == siz[ls]+1) return now;\n    else if(k \u003c= siz[ls]) return findk(k,ls);\n    else return findk(k-siz[ls]-1,rs);\n}\n\nvoid update(int L,int R)\n{\n    int \u0026now = root;//为了用上面那个宏弄了个引用...(一开始没写引用狂T o(╥﹏╥)o)\n    splay(findk(L,root),0);\n    splay(findk(R+2,root),root);\n    lazy[ch[rs][0]] ^= 1;\n    pushup(rs);\n    pushup(root);\n}\n\nvoid dfs(int now)\n{\n    pushdown(now);\n    if(ls)\n        dfs(ls);\n    if(val[now]\u003c=N\u0026\u0026val[now]\u003e=1)\n        printf(\"%d \",val[now]);\n    if(rs)\n        dfs(rs);\n}\n\nint main()\n{\n    int l,r;\n    scanf(\"%d%d\",\u0026N,\u0026M);\n    newnode(0,root,0);\n    newnode(N+1,ch[root][1],root);\n    build(1,N,ch[ch[root][1]][0],ch[root][1]);\n    while(M--)\n    {\n        scanf(\"%d%d\",\u0026l,\u0026r);\n        update(l,r);\n    }\n    dfs(root);\n    return 0;\n}\n\n```\n\n\n\n\n\n",
        "Title": "Splay bzoj3223文艺平衡树",
        "CreateTime": 1536234720000,
        "FormatTime": "2018.09.06",
        "Categories": "数据结构",
        "Tags": [
            ""
        ],
        "EditorType": "markdown"
    },
    {
        "Content": "Treap = Tree + heap，Tree是BST，即同时维护二叉查找树和堆的性质\nTreap的定义：\n\n```\nint ch[maxn][2], val[maxn], siz[maxn], num[maxn], pri[maxn];//此处优先级用了小根堆\nint tot, rt;\n#define ls ch[now][0]\n#define rs ch[now][1]\n```\nch数组存的是左右孩子节点的下标\nval是BST的值，siz是子树大小，\nnum指值为val的数有多少个\npri是堆的值(此处选择了小根堆)\ntot是treap的结点总数(val相同的很多个数只占一个结点)\nrt是当前的树根\n宏是拿来偷懒滴\n1、一棵BST，无论如何左旋右旋，结点间的关系一定不会变。\n2、BST在数据随机的情况下所有操作的期望都是O(logN)\nTreap就是利用以上两点，把插入的数据通过旋转，变得好像是随机插入的一样。 \nTreap的每次插入，先像普通的BST一样找到插入的位置，然后给pri赋随机值，再以旋转的方式用pri在不改变BST的性质的前提下维护heap。\n\n旋转:\n旋转后siz会变，要更新\n```\ninline void pushup(int now)\n{\n    siz[now] = siz[ls] + siz[rs] + num[now];\n}\n\nvoid rotate(int \u0026x,int dir)//把now旋转到它的儿子的位置,dir为0代表右旋,1左旋\n{\n    int son = ch[x][dir];\n    ch[x][dir] = ch[son][dir^1];\n    ch[son][dir^1] = x;\n    pushup(x);//旋转后x在下面，先更新x\n    pushup(x=son);\n}\n```\n\n插入一个值为v的数:\n递归写起来比较舒服~\n4种情况：\n1、找到了一个空位\n新建一个点，over\n2、当前节点的val == v\n当前结点的num+1，over\n3、当前节点的val \u003e v\n递归往左子树插入\n检查左孩子的pri是否小于当前的pri，小于则右旋(左子树完成插入后可能不满足堆的性质)\n4、跟3反过来\n\n一路上的siz都要++(下面多了一个数)\n```\nvoid Insert(int v,int \u0026now)\n{\n    if(!now)//找到空位直接新开一个点\n    {\n        newnode(v,now);\n        return ;\n    }\n    ++siz[now];\n    if(val[now] == v)//这个数已经存在,num+1即可\n    {\n        ++num[now];\n        return ;\n    }\n    else if(v \u003c val[now])\n    {\n        Insert(v,ls);\n        if(pri[ls] \u003c pri[now])\n            rotate(now,0);//左儿子优先级小就把左儿子旋到上面来(右旋)\n    }\n    else\n    {\n        Insert(v,rs);\n        if(pri[rs] \u003c pri[now])\n            rotate(now,1);//右儿子优先级小就把右儿子旋到上面来(左旋)\n    }\n}\n```\n\n删除一个值为v的数:\n3种情况 吧\n1、如果找到val == v的结点，且该结点的num \u003e 1，num-1就行了\n2、找到val == v的结点，且该结点的num == 1\n(1)如果没有左右子树，直接赋个0删了就行\n(2)如果左右子树中有一个为空，赋值为不为空的那个(就是直接拿孩子把它覆盖掉)\n(3)如果左右子树都有，把孩子中pri小的那个转上来(维护堆的性质不变)，然后再递归删当前结点(为什么不是删孩子结点？因为旋转完，当前节点已经转到孩子那里去了啊)\n3、val != v\n递归删左或右即可\n\n一路上的siz都要-1\n3的(3)siz不用-1，因为转上去的孩子siz都是没变的，转下去的那个点被删了，不用管它的siz\n\n```\nvoid dele(int v,int \u0026now)\n{\n    if(!now)//防非法数据\n        return ;\n    if(val[now] == v)\n    {\n        if(num[now] \u003e 1)\n        {\n            --siz[now];\n            --num[now];\n            return ;\n        }\n        else\n        {\n            if(!ls \u0026\u0026 !rs)\n            {\n                now = 0;\n                return ;\n            }\n            else if(!ls || !rs)\n            {\n                now = ls + rs;\n                return ;\n            }\n            else\n            {\n                int dir = pri[ls] \u003e pri[rs];\n                rotate(now,dir);\n                dele(v,now);\n            }\n        }\n    }\n    else\n    {\n        --siz[now];\n        dele(v,ch[now][v\u003eval[now]]);\n    }\n}\n```\n查值为v的数的排名\n比较简单 ，直接看注释吧\n\n```\nint rk(int v,int now)\n{\n    if(!now) return 0;//防非法数据\n    if(v == val[now])\n        return siz[ls] + 1;//siz[ls]是比v小的数的数量，+1就是v的排名\n    else if(v \u003c val[now])\n        return rk(v,ls);\n    else\n        return rk(v,rs)+siz[ls]+num[now];//往右子树找记得把左子树大小和当前点的大小加上\n}\n```\n\n查排名为k的数:\n跟上面差不多\n```\nint kth(int k,int now)\n{\n    if(siz[ls] \u003c k \u0026\u0026 siz[ls] + num[now] \u003e= k)\n        return val[now];\n    else if(k \u003c= siz[ls])\n        return kth(k,ls);\n    else\n        return kth(k-siz[ls]-num[now],rs);\n}\n```\n\n求前驱、后继\n\n```\nint pre(int v,int now)\n{\n    if(!now) return -inf;//找到空的地方返回-inf，因为上一层有max，-inf不会计入答案\n    if(val[now] \u003e= v)//当前节点的值比v大,不可能成为前驱\n        return pre(v,ls);//往左节点找\n    return max(pre(v,rs), val[now]);\n}\n\nint suc(int v,int now)\n{\n    if(!now) return inf;\n    if(val[now] \u003c= v)//当前节点的值比v小,不可能成为后继\n        return suc(v,rs);//往右节点找\n    return min(suc(v,ls), val[now]);\n}\n```\n\nbzoj3224普通平衡树:\n\n```\n#include\u003ccstdio\u003e\n#include\u003cqueue\u003e\n#include\u003ccstdlib\u003e\n#include\u003calgorithm\u003e\nusing namespace std;\nconst int maxn = 1e5 + 5;\nconst int inf = 1e9 + 9;\nint ch[maxn][2], val[maxn], siz[maxn], num[maxn], pri[maxn];//优先级用小根堆\nint tot, rt;\n#define ls ch[now][0]\n#define rs ch[now][1]\nqueue\u003cint\u003e que;\ninline void newnode(int v,int \u0026x)\n{\n    if(!que.empty())\n    {\n        x = que.front();\n        que.pop();\n    }\n    else\n        x = ++tot;\n    ch[x][0] = ch[x][1] = 0;\n    num[x] = 1;\n    val[x] = v;\n    siz[x] = 1;\n    pri[x] = rand();\n}\n\ninline void reuse(int x)\n{\n    que.push(x);\n}\n\ninline void pushup(int now)\n{\n    siz[now] = siz[ls] + siz[rs] + num[now];\n}\n\nvoid rotate(int \u0026x,int dir)//把now旋转到它的儿子的位置,dir为0代表左儿子\n{\n    int son = ch[x][dir];\n    ch[x][dir] = ch[son][dir^1];\n    ch[son][dir^1] = x;\n    pushup(x);//旋转后x在下面，先更新x\n    //x = son;\n    pushup(x=son);\n}\n\nvoid Insert(int v,int \u0026now)\n{\n    if(!now)//找到空位直接新开一个点\n    {\n        newnode(v,now);\n        return ;\n    }\n    ++siz[now];\n    if(val[now] == v)//这个数已经存在,num+1即可\n    {\n        ++num[now];\n        return ;\n    }\n    else if(v \u003c val[now])\n    {\n        Insert(v,ls);\n        if(pri[ls] \u003c pri[now])\n            rotate(now,0);//左儿子优先级小就把左儿子旋到上面来(右旋)\n    }\n    else\n    {\n        Insert(v,rs);\n        if(pri[rs] \u003c pri[now])\n            rotate(now,1);//右儿子优先级小就把右儿子旋到上面来(左旋)\n    }\n}\n\nvoid dele(int v,int \u0026now)\n{\n    if(!now)\n        return ;\n    if(val[now] == v)\n    {\n        if(num[now] \u003e 1)\n        {\n            --siz[now];\n            --num[now];\n            return ;\n        }\n        else\n        {           \n            if(!ls \u0026\u0026 !rs)\n            {\n\t\t\t\treuse(now);\n                now = 0;\n                return ;\n            }\n            else if(!ls || !rs)\n            {\n            \treuse(now);\n                now = ls + rs;\n                return ;\n            }\n            else\n            {\n                int dir = pri[ls] \u003e pri[rs];\n                rotate(now,dir);\n                dele(v,now);\n            }\n        }\n    }\n    else\n    {\n        --siz[now];\n        dele(v,ch[now][v\u003eval[now]]);\n    }\n}\n\nint rk(int v,int now)\n{\n    if(!now) return 0;\n    if(v == val[now])\n        return siz[ls] + 1;\n    else if(v \u003c val[now])\n        return rk(v,ls);\n    else\n        return rk(v,rs)+siz[ls]+num[now];\n}\n\nint kth(int k,int now)\n{\n    if(siz[ls] \u003c k \u0026\u0026 siz[ls] + num[now] \u003e= k)\n        return val[now];\n    else if(k \u003c= siz[ls])\n        return kth(k,ls);\n    else\n        return kth(k-siz[ls]-num[now],rs);\n}\n\nint pre(int v,int now)\n{\n    if(!now) return -inf;\n    if(val[now] \u003e= v)//当前节点的值比v大,不可能成为前驱\n        return pre(v,ls);//往左节点找\n    return max(pre(v,rs), val[now]);\n}\n\nint suc(int v,int now)\n{\n    if(!now) return inf;\n    if(val[now] \u003c= v)//当前节点的值比v小,不可能成为后继\n        return suc(v,rs);//往右节点找\n    return min(suc(v,ls), val[now]);\n}\n\nint n,op,x;\nint main()\n{\n    scanf(\"%d\",\u0026n);\n    while(n--)\n    {\n        scanf(\"%d%d\",\u0026op,\u0026x);\n        switch(op)\n        {\n            case 1: Insert(x,rt); break;\n            case 2: dele(x,rt); break;\n            case 3: printf(\"%d\\n\",rk(x,rt));break;\n            case 4: printf(\"%d\\n\",kth(x,rt));break;\n            case 5: printf(\"%d\\n\",pre(x,rt));break;\n            default:printf(\"%d\\n\",suc(x,rt));\n        }\n    }\n    return 0; \n}\n```",
        "Title": "Treap(旋转)  bzoj3224普通平衡树",
        "CreateTime": 1536161341000,
        "FormatTime": "2018.09.05",
        "Categories": "数据结构",
        "Tags": [
            ""
        ],
        "EditorType": "markdown"
    },
    {
        "Content": "一般线段树做区间修改操作时，先是找到目标区间，然后修改该区间，并打下延迟标记，最后从目标区间自底向上，更新所有包含目标区间的区间的值(即pushup)。当该区间子节点被访问前，pushdown下推标记。\n这种维护区间的方式存在一点点弊端。例如用这种方式写一棵可持久化线段树，因为每次pushdown都相当于继续之前延迟了的更新操作，所以得开新的节点，然后开着开着可能就爆内存了.....\n\n一种更好的方法就是用标记永久化。 从字面意思就可以知道，永久化的标记是不会变的，这个不变是不会变小(一般的那种 pushdown的时候标记都清0了)。\n\n实现过程：update[L,R]时，把所有包含[L,R]的区间更新(显然修改[L,R]能影响到的就是这些区间)，然后在[L,R]上打上标记；query[L,R]时，自顶向下找区间[L,R]，统计从根到目标节点的路上标记的和，结果就是目标区间的值加上路径上所有标记的影响。\n优势：不用pushdown，代码短了，且可持久化的时候不用开新的节点；与下推标记的写法相比略快一点\n下面附上poj3468和hdu4348的代码\npoj3468\n```\n#include\u003ccstdio\u003e\n#include\u003ccstring\u003e\nusing namespace std;\n#define lson l,m,rt\u003c\u003c1\n#define rson m+1,r,rt\u003c\u003c1|1\nconst int maxn = 100000+10;\ntypedef long long ll;\nll t[maxn\u003c\u003c2],lazy[maxn\u003c\u003c2];\n\nvoid build(int l,int r,int rt)\n{\n\tlazy[rt] = 0;\n\tif(l==r)\n\t{\n\t\tscanf(\"%lld\",\u0026t[rt]);\n\t\treturn ;\n\t}\n\tint m = l+r \u003e\u003e 1;\n\tbuild(lson);\n\tbuild(rson);\n\tt[rt] = t[rt\u003c\u003c1] + t[rt\u003c\u003c1|1];\n}\n\nvoid update(int L,int R,int val,int l,int r,int rt)\n{\n    t[rt] += (ll)(R-L+1) * val;\n\tif(L==l\u0026\u0026r==R)\n\t{\n\t\tlazy[rt] += val;\n\t\treturn ;\n\t}\n\tint m = l + r \u003e\u003e 1;\n\tif(R\u003c=m)\n\t\tupdate(L,R,val,lson);\n\telse if(L\u003em)\n\t\tupdate(L,R,val,rson);\n    else update(L,m,val,lson), update(m+1,R,val,rson);\n}\n\nll query(int L,int R,int l,int r,int rt,int add)\n{\n\tif(L==l\u0026\u0026r==R)\n        return t[rt] + (ll)add*(r-l+1);\n\tint m = l + r \u003e\u003e 1;\n\tif(R\u003c=m)\n\t\treturn query(L,R,lson,add+lazy[rt]);\n\telse if(L\u003em)\n\t\treturn query(L,R,rson,add+lazy[rt]);\n    else return query(L,m,lson,add+lazy[rt]) + query(m+1,R,rson,add+lazy[rt]);\n}\n\nint N,Q;\nint x,y;\nll z;\nchar str[10];\nint main()\n{\n    scanf(\"%d%d\",\u0026N,\u0026Q);\n    build(1,N,1);\n    while(Q--)\n    {\n        scanf(\"%s\",str);\n        if(str[0]=='C')\n        {\n            scanf(\"%d%d%d\",\u0026x,\u0026y,\u0026z);\n            update(x,y,z,1,N,1);\n        }\n        \n        \n        else\n        {\n            scanf(\"%d%d\",\u0026x,\u0026y);\n            printf(\"%lld\\n\",query(x,y,1,N,1,0));\n        }\n    }\n\treturn 0;\n}\n\n```\nhdu4348\n\n```\n#include\u003ccstdio\u003e\n#include\u003calgorithm\u003e\n#include\u003ccstring\u003e\nusing namespace std;\nconst int maxn = 1e5 + 5;\ntypedef long long ll;\nint lazy[maxn*30],ls[maxn*30],rs[maxn*30],N,Q;\nll t[maxn*30];\nint tot,root[maxn],nowroot;\n#define lson l,m,ls[now]\n#define rson m+1,r,rs[now]\nvoid build(int l,int r,int \u0026now)\n{\n    now = ++tot;\n    lazy[now] = 0;\n    if(l==r)\n    {\n        scanf(\"%I64d\",\u0026t[now]);\n        //printf(\"t[%d] = %lld\\n\",now,t[now]);\n        return ;\n    }\n    int m = l + r \u003e\u003e 1;\n    build(lson);\n    build(rson);\n    t[now] = t[ls[now]] + t[rs[now]];\n    //printf(\"t[%d] = %lld\\n\",now,t[now]);\n}\n\nvoid update(int L,int R,int val,int l,int r,int \u0026now,int lst)\n{\n    now = ++tot;\n    ls[now] = ls[lst], rs[now] = rs[lst];\n    t[now] = t[lst] + (ll)(R-L+1)*val;\n    lazy[now] = lazy[lst];\n    if(L == l \u0026\u0026 r == R)\n    {\n        lazy[now] += val;\n        return ;\n    }\n    int m = l + r \u003e\u003e 1;\n    if(R\u003c=m)\n        update(L,R,val,lson,ls[lst]);\n    else if(L\u003em)\n        update(L,R,val,rson,rs[lst]);\n    else\n        update(L,m,val,lson,ls[lst]), update(m+1,R,val,rson,rs[lst]);\n}\n\nll query(int L,int R,int l,int r,int now,int add)\n{\n    if(L == l \u0026\u0026 r == R)\n        return t[now] + (ll)(R-L+1)*add;\n    int m = l + r \u003e\u003e 1;\n    if(R\u003c=m)\n        return query(L,R,lson,add+lazy[now]);\n    else if(L\u003em)\n        return query(L,R,rson,add+lazy[now]);\n    else\n        return query(L,m,lson,add+lazy[now]) + query(m+1,R,rson,add+lazy[now]);\n}\n\nvoid init()\n{\n    tot = 0;\n    nowroot = 1;\n}\n\nint main()\n{\n    char op[2];\n    int l,r,v;\n    while(scanf(\"%d%d\",\u0026N,\u0026Q)!=EOF)\n    {\n        init();\n        build(1,N,root[1]);\n        while(Q--)\n        {\n            scanf(\"%s\",op);\n            switch(op[0])\n            {\n            case 'Q':\n                scanf(\"%d%d\",\u0026l,\u0026r);\n                printf(\"%I64d\\n\",query(l,r,1,N,root[nowroot],0));\n                break;\n            case 'C':\n                scanf(\"%d%d%d\",\u0026l,\u0026r,\u0026v);\n                update(l,r,v,1,N,root[nowroot+1],root[nowroot]);\n                ++nowroot;\n                break;\n            case 'H':\n                scanf(\"%d%d%d\",\u0026l,\u0026r,\u0026v);\n                printf(\"%I64d\\n\",query(l,r,1,N,root[v+1],0));\n                break;\n            default:\n                scanf(\"%d\",\u0026v);\n                tot = root[v+2] - 1;//回收内存\n                nowroot = v+1;\n                break;\n            }\n        }\n    }\n}\n\n```",
        "Title": "线段树 标记永久化",
        "CreateTime": 1535372616000,
        "FormatTime": "2018.08.27",
        "Categories": "数据结构",
        "Tags": [
            ""
        ],
        "EditorType": "markdown"
    },
    {
        "Content": "最近在学splay，就用这道题来记一下模板。\n\nsplay是二叉搜索树，满足中序遍历有序的性质；同时，splay操作可以在不改变中序序列的前提下改变树的结构。因此，splay可以十分方便地维护区间信息。\n\n```\n#include\u003ccstdio\u003e\nusing namespace std;\n\nconst int maxn = 1e5 + 5;\ntypedef long long ll;\n\nint fa[maxn], ch[maxn][2], val[maxn], siz[maxn];\nll sum[maxn], lazy[maxn];\nint a[maxn];\n\nint tot, root, N, Q;\n#define rrt ch[root][1]\n#define ls ch[rt][0]\n#define rs ch[rt][1]\nbool get(int x)\n{\n    return ch[fa[x]][1] == x;\n}\n\nvoid connect(int x,int f,int which)\n{\n    fa[x] = f;\n    ch[f][which] = x;\n}\n\nvoid pushup(int rt)\n{\n    siz[rt] = siz[ls] + siz[rs] + 1;\n    sum[rt] = sum[ls] + sum[rs] + val[rt];\n}\n\nvoid pushdown(int rt)\n{\n    if(lazy[rt])\n    {\n        lazy[ls] += lazy[rt];\n        lazy[rs] += lazy[rt];\n        sum[ls] += (ll)siz[ls] * lazy[rt];\n        sum[rs] += (ll)siz[rs] * lazy[rt];\n        val[rt] += lazy[rt];\n        lazy[rt] = 0;\n    }\n}\n\nint y,z,yson,zson,xson;\nvoid rotate(int x)\n{\n    y = fa[x];\n    z = fa[y];\n    pushdown(y);\n    pushdown(x);\n    yson = get(x);\n    zson = get(y);\n    xson = ch[x][yson^1];\n    if(z) connect(x,z,zson);\n    fa[x] = z;\n    connect(y,x,yson^1);\n    connect(xson,y,yson);\n    pushup(y);\n}\n\nvoid splay(int x,int to)//把x移动到to的下面\n{\n    pushdown(x);\n    while(fa[x] != to)\n    {\n        if(fa[fa[x]] == to) rotate(x);\n        else if(get(x) == get(fa[x])) rotate(fa[x]), rotate(x);//三点共线\n        else rotate(x), rotate(x);\n    }\n    pushup(x);\n    if(to == 0)//x移动到根了\n        root = x;//更新根\n}\n\nvoid newnode(int \u0026x,int v,int f)\n{\n    x = ++tot;\n    ch[x][0] = ch[x][1]  = lazy[x] = 0;\n    siz[x] = 1;\n    sum[x] = v;\n    fa[x] = f;\n    val[x] = v;\n}\n\nvoid build(int \u0026rt,int l,int r,int f)\n{\n    if(l\u003er) return ;\n    int m = l + r \u003e\u003e 1;\n    newnode(rt,a[m],f);\n    build(ls,l,m-1,rt);\n    build(rs,m+1,r,rt);\n    pushup(rt);\n}\n\nvoid initbuild()\n{\n    root = tot = 0;\n    ch[0][0] = ch[0][1] = siz[0] = sum[0] = lazy[0] = fa[0] = val[0] = 0;\n    newnode(root,0,0);//0\n    newnode(rrt,0,root);//N+1\n    for(int i=1;i\u003c=N;++i)\n\t\tscanf(\"%d\",\u0026a[i]);\n    build(ch[rrt][0],1,N,rrt);\n    pushup(rrt);\n    pushup(root);\n}\n\nint get_kth(int rt,int k)\n{\n    pushdown(rt);\n    int temp = siz[ls] + 1;\n    if(temp == k) return rt;\n    if(temp \u003e k) return get_kth(ls,k);\n    return get_kth(rs,k-temp);\n}\n\nvoid update(int l,int r,int v)\n{\n    splay(get_kth(root,l),0);//因为加了虚节点0(占了下标1)，实际区间的下标为2到N+1\n    splay(get_kth(root,r+2),root);//所以区间中的第l-1个元素就是树上的第l个点\n\n    lazy[ch[rrt][0]] += v;\n    sum[ch[rrt][0]] += ll(v * siz[ch[rrt][0]]);\n    pushup(root);\n    pushup(rrt);\n}\n\nll query(int l,int r)\n{\n    splay(get_kth(root,l),0);\n    splay(get_kth(root,r+2),root);\n\n    return sum[ch[rrt][0]];\n}\n\nint main()\n{\n\tchar op[2];\n\tint l, r, v;\n\tscanf(\"%d%d\",\u0026N,\u0026Q);\n\tinitbuild();\n\twhile(Q--)\n\t{\n\t\tscanf(\"%s%d%d\",op,\u0026l,\u0026r);\n\t\tif(op[0]=='C')\n\t\t{\n\t\t\tscanf(\"%d\",\u0026v);\n\t\t\tupdate(l,r,v);\n\t\t}\n\t\telse\n\t\t\tprintf(\"%lld\\n\",query(l,r));\n\t}\n\treturn 0;\n}\n\n```",
        "Title": "poj 3468 (splay)",
        "CreateTime": 1535350664000,
        "FormatTime": "2018.08.27",
        "Categories": "数据结构",
        "Tags": [
            ""
        ],
        "EditorType": "markdown"
    },
    {
        "Content": "题意: 有一个长度为n的数组a，初值均为0，有m组修改，由题目给的一个随机函数生成l, r, v，把a在区间 [ l , r ] 中小于v的值修改为v，最终输出 $\\bigoplus_{i=1}^n$ $a_i$*$i$    (对$a_1$到$a_n$求异或和)\n\n思路: 先把l r v全都弄出来，维护每个区间a的最大值和最小值。\n在update的时候，如果mina \u003e= v，不用更新，直接return了；如果maxa \u003c= v，直接更新区间，打上懒惰标记；否则继续分割区间，向下更新。\n\n```\n#include\u003cbits/stdc++.h\u003e\nusing namespace std;\ntypedef unsigned int ui;\ntypedef long long ll;\nconst int maxn = 1e5 + 5;\nconst int maxm = 5e6 + 5;\nconst ui mod = 1 \u003c\u003c 30;\nui x, y, z, w, f[3*maxm], Left[maxm], Right[maxm], v[maxm];\nui fun()\n{\n    x ^= (x \u003c\u003c 11);\n    x ^= (x \u003e\u003e 4);\n    x ^= (x \u003c\u003c 5);\n    x ^= (x \u003e\u003e 14);\n    w = x ^ (y ^ z);\n    x = y;\n    y = z;\n    z = w;\n    return z;\n}\n\nll ans, a[maxn], maxa[maxn\u003c\u003c2], mina[maxn\u003c\u003c2], lazy[maxn\u003c\u003c2];\n#define lson l,m,rt\u003c\u003c1\n#define rson m+1,r,rt\u003c\u003c1|1\n#define getm int m = l + r \u003e\u003e 1\nvoid pushup(int rt)\n{\n    mina[rt] = min(mina[rt\u003c\u003c1],mina[rt\u003c\u003c1|1]);\n    maxa[rt] = max(maxa[rt\u003c\u003c1],maxa[rt\u003c\u003c1|1]);\n}\n\nvoid pushdown(int rt)\n{\n    if(lazy[rt])\n    {\n        lazy[rt\u003c\u003c1] = lazy[rt\u003c\u003c1|1] = lazy[rt];\n        maxa[rt\u003c\u003c1] = maxa[rt\u003c\u003c1|1] = lazy[rt];\n        mina[rt\u003c\u003c1] = mina[rt\u003c\u003c1|1] = lazy[rt];\n        lazy[rt] = 0;\n    }\n}\n\nvoid update(ui L,ui R,ui val,int l,int r,int rt)\n{\n    if(mina[rt] \u003e= val) return ;//最小值都比v大，不用更新\n    if(L \u003c= l \u0026\u0026 r \u003c= R)\n    {\n        if(maxa[rt] \u003c= val)//最大值比v小，全部更新，打标记\n        {\n            maxa[rt] = val;\n            lazy[rt] = val;\n            return ;\n        }\n        //否则继续切分区间，向下更新\n    }\n\n    getm;\n    pushdown(rt);\n    if(L\u003c=m)\n        update(L,R,val,lson);\n    if(R\u003em)\n        update(L,R,val,rson);\n    pushup(rt);\n}\n\nll query(int pos,int l,int r,int rt)\n{\n    if(l==r)\n        return maxa[rt];\n    getm;\n    pushdown(rt);\n    if(pos\u003c=m)\n        return query(pos,lson);\n    else\n        return query(pos,rson);\n}\n\nint T, N, M;\nint main()\n{\n    scanf(\"%d\",\u0026T);\n    while(T--)\n    {\n        memset(a,0,8*(N+1));\n        memset(lazy,0,32*(N+1));\n        memset(mina,0,32*(N+1));\n        memset(maxa,0,32*(N+1));\n        scanf(\"%d%d%u%u%u\",\u0026N,\u0026M,\u0026x,\u0026y,\u0026z);\n        for(int i=1;i\u003c=3*M;++i)\n            f[i] = fun();\n        for(int i=1;i\u003c=M;++i)\n        {\n            Left[i] = min(f[3*i-2] % N, f[3*i-1] % N) + 1;\n            Right[i] = max(f[3*i-2] % N, f[3*i-1] % N) + 1;\n            v[i] = f[3*i] % mod;\n            update(Left[i],Right[i],v[i],1,N,1);\n        }\n        ans = 0;\n        for(int i=1;i\u003c=N;++i)\n            ans ^= ((ll)i * query(i,1,N,1));\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}\n\n```",
        "Title": "HDU6356 Glad You Came(线段树区间更新+剪枝)",
        "CreateTime": 1533747008000,
        "FormatTime": "2018.08.09",
        "Categories": "数据结构",
        "Tags": [
            ""
        ],
        "EditorType": "markdown"
    },
    {
        "Content": "题目链接: [hdu6315](http://acm.hdu.edu.cn/showproblem.php?pid=6315)\n题目大意: 输入一个n，下一行输入一个长度为n的数组b，b是1到n的一种全排列，还有一个长度为n初值全为0的数组a\n\t\t\t\t两种操作: 1) 输入add l r ,将$a_l$到$a_r$的数字全都 +1\n\t\t\t\t\t\t\t\t2) 输入 query l r，查询 $\\sum_{i=l}^r $ $ \\dfrac{a_i}{b_i} $，$ \\dfrac{a_i}{b_i} $的值向下取整\n思路: 因为$ \\dfrac{a_i}{b_i} $的值向下取整，当一个区间内a的最大值比该区间b的最小值还要小，那么这个区间对答案的贡\n\t\t 献一定是0。用线段树维护三个值: 区间中a的最小值，b的最大值，区间中的$\\sum \\dfrac{a_i}{b_i} $\t\t\n\t\t 当a的增加并没有使max(a) \u003e min(b)时，用lazy标记记录a的增加，而不更新到下面的结点\n\t\t 当a的增加时区间中的max(a)\u003e=min(b)时，一路更新到那些max(a)\u003e=min(b)的叶子结点，把叶子的minb[rt] += b[l]，\n\t\t 并把这片叶子对答案的贡献＋1\n跑得很慢的代码:\n\n```\n#include\u003cbits/stdc++.h\u003e\nusing namespace std;\nconst int maxn = 1e5 + 10;\nint b[maxn],n,q;\n\n#define lson l,m,rt\u003c\u003c1\n#define rson m+1,r,rt\u003c\u003c1|1\nint mb[maxn\u003c\u003c2],ma[maxn\u003c\u003c2],lazy[maxn\u003c\u003c2],tot[maxn\u003c\u003c2];\n\nvoid pushup(int rt)\n{\n\tmb[rt] = min(mb[rt\u003c\u003c1],mb[rt\u003c\u003c1|1]);\n\tma[rt] = max(ma[rt\u003c\u003c1],ma[rt\u003c\u003c1|1]);\n\ttot[rt] = tot[rt\u003c\u003c1] + tot[rt\u003c\u003c1|1];\n}\n\nvoid pushdown(int rt)\n{\n\tif(lazy[rt])\n\t{\n\t\tlazy[rt\u003c\u003c1] += lazy[rt];\n\t\tlazy[rt\u003c\u003c1|1] += lazy[rt];\n\t\tma[rt\u003c\u003c1] += lazy[rt];\n\t\tma[rt\u003c\u003c1|1] += lazy[rt];\n\t\tlazy[rt] = 0;\n\t}\n}\n\nvoid build(int l,int r,int rt)\n{\n\tlazy[rt] = 0;\n\ttot[rt] = 0;\n\tif(l==r)\n\t{\n\t\tmb[rt] = b[l];\n\t\tma[rt] = 0;\n\t\treturn ;\n\t}\n\tint m = l + r \u003e\u003e 1;\n\tbuild(lson);\n\tbuild(rson);\n\tpushup(rt);\n}\n\n//tot数组表示区间中a/b在取整求和时的贡献，初值为0\n//因为向下取整，所以a\u003cb时贡献是0。当a\u003e=b时，该区间的tot值加一\n//同时该区间的b值也+1，当a再次达到b时，tot再+1 \n//(例如1/1的贡献是1，此时把tot+=1,分母+=1，下次a达到2的时候,2/2又使得tot+=1。。。。) \nvoid update(int L,int R,int l,int r,int rt)\n{\n\tif(L\u003c=l\u0026\u0026r\u003c=R)\n\t{\n\t\t++ma[rt];\n\t\tif(ma[rt]\u003e=mb[rt]\u0026\u0026l==r)//a增加后超过了b，a/b取整求和的时候不为0了 \n\t\t{\n\t\t\t++tot[rt];\n\t\t\tmb[rt] += b[l]; \n\t\t\treturn ;\n\t\t}\n\t\tif(ma[rt]\u003cmb[rt])//该区间的a虽然增加了，但比b小，a/b取整求和的时候为0，用lazy记下来即可 \n\t\t{\n\t\t\t++lazy[rt];\n\t\t\treturn ;\n\t\t}\n\t}\n\tint m = l + r \u003e\u003e 1;\n\tpushdown(rt);\n\tif(L\u003c=m)\n\t\tupdate(L,R,lson);\n\tif(R\u003em)\n\t\tupdate(L,R,rson);\n\tpushup(rt);\n}\n\nint query(int L,int R,int l,int r,int rt)\n{\n\tif(L\u003c=l\u0026\u0026r\u003c=R)\n\t\treturn tot[rt];\n\tint m = l + r \u003e\u003e 1,ans = 0;\n\tif(L\u003c=m)\n\t\tans += query(L,R,lson);\n\tif(R\u003em)\n\t\tans += query(L,R,rson);\n\treturn ans;\n}\n\nchar op[10];\nint l, r;\nint main()\n{\n\tscanf(\"%d%d\",\u0026n,\u0026q);\n\tfor(int i=1;i\u003c=n;++i)\n\t\tscanf(\"%d\",\u0026b[i]);\n\tbuild(1,n,1);\n\twhile(q--)\n\t{\n\t\tscanf(\"%s%d%d\",op,\u0026l,\u0026r);\n\t\tif(op[0]=='a')\n\t\t\tupdate(l,r,1,n,1);\n\t\telse\n\t\t\tprintf(\"%d\\n\",query(l,r,1,n,1));\n\t}\n\treturn 0;\n}\n```\n\n\t\t           \t",
        "Title": "HDU6315 Naive Operations (2018多校第二场) 线段树",
        "CreateTime": 1532575251000,
        "FormatTime": "2018.07.26",
        "Categories": "数据结构",
        "Tags": [
            ""
        ],
        "EditorType": "markdown"
    },
    {
        "Content": "\n```c\n#include\u003cbits/stdc++.h\u003e\nusing namespace std;\nconst int maxn = 100000+10;\nint N,M,R,P,w[maxn];\n\nstruct\n{\n\tint to,next;\t\n}e[maxn\u003c\u003c1];\n\nint head[maxn],edgeNum;\nvoid add(int u,int v)\n{\n\te[edgeNum].next = head[u];\n\te[edgeNum].to = v;\n\thead[u] = edgeNum++;\n}\n\n/*-------------------------树剖------------------------------*/\nint deep[maxn],fa[maxn],siz[maxn],son[maxn];\nvoid dfs1(int u,int pre,int d)\n{\n\tdeep[u] = d;\n\tfa[u] = pre;\n\tsiz[u] = 1;\n\tson[u] = 0;\n\tfor(int i=head[u];~i;i=e[i].next)\n\t{\n\t\tint v = e[i].to;\n\t\tif(v!=pre)\n\t\t{\n\t\t\tdfs1(v,u,d+1);\n\t\t\tsiz[u] += siz[v];\n\t\t\tif(siz[v]\u003esiz[son[u]])\n\t\t\t\tson[u] = v;\n\t\t}\n\t}\n}\n\nint top[maxn],id[maxn],rk[maxn],cnt;\nint \u0026n = cnt;\nvoid dfs2(int u,int t)\n{\n\ttop[u] = t;\n\tid[u] = ++cnt;\n\trk[cnt] = u;\n\tif(!son[u]) return;\n\t\n\tdfs2(son[u],t);\n\t\n\tfor(int i=head[u];~i;i=e[i].next)\n\t{\n\t\tint v = e[i].to;\n\t\tif(v!=son[u]\u0026\u0026v!=fa[u])\n\t\t\tdfs2(v,v);\n\t}\n}\n/*-------------------------树剖------------------------------*/\n\n/*-------------------------线段树------------------------------*/\n#define lson l,m,rt\u003c\u003c1\n#define rson m+1,r,rt\u003c\u003c1|1\nint sum[maxn\u003c\u003c2],lazy[maxn\u003c\u003c2];\nvoid pushup(int rt)\n{\n\tsum[rt] = (sum[rt\u003c\u003c1]%P + sum[rt\u003c\u003c1|1]%P) % P;\n}\n\nvoid build(int l,int r,int rt)\n{\n    if(l==r)\n    {\n        sum[rt] = w[rk[l]]%P;\n        return ;\n    }\n    int m = l+r\u003e\u003e1;\n    build(lson);\n    build(rson);\n    pushup(rt);\n}\n\nvoid pushdown(int rt,int l,int r)\n{\n\tif(lazy[rt])\n\t{\n\t\tlazy[rt\u003c\u003c1] = (lazy[rt\u003c\u003c1] + lazy[rt]) % P;\n\t\tlazy[rt\u003c\u003c1|1] = (lazy[rt\u003c\u003c1|1] + lazy[rt]) % P;\n\t\tsum[rt\u003c\u003c1] += (lazy[rt] * l)%P;\n\t\tsum[rt\u003c\u003c1] %= P;\n\t\tsum[rt\u003c\u003c1|1] += (lazy[rt] * r)%P;\n\t\tsum[rt\u003c\u003c1|1] %= P;\n\t\tlazy[rt] = 0;\n\t}\n}\n\nvoid update(int L,int R,int val,int l,int r,int rt)\n{\n\tif(L\u003c=l\u0026\u0026r\u003c=R)\n\t{\n\t\tsum[rt] = (sum[rt]%P + (val%P) * ((r-l+1)%P)) % P;\n\t\tlazy[rt] += val%P;\n\t\treturn ;\n\t}\n\tint m = l + r \u003e\u003e 1;\n\tpushdown(rt,m-l+1,r-m);\n\tif(L\u003c=m)\n\t\tupdate(L,R,val,lson);\n\tif(R\u003em)\n\t\tupdate(L,R,val,rson);\n\tpushup(rt);\n}\n\nint query(int L,int R,int l,int r,int rt)\n{\n\tif(L\u003c=l\u0026\u0026r\u003c=R)\n\t\treturn sum[rt];\n\tint m = l + r \u003e\u003e 1,ans = 0;\n\tpushdown(rt,m-l+1,r-m);\n\tif(L\u003c=m)\n        ans = (ans%P + query(L,R,lson)%P) % P;\n    if(R\u003em)\n        ans = (ans%P + query(L,R,rson)%P) % P;\n    return ans%P;\n}\n/*-------------------------线段树------------------------------*/\n\n/*-----------------------树剖加线段树--------------------------*/\nvoid update(int x,int y,int z)\n{\n\tz %= P;\n\twhile(top[x]!=top[y])\n\t{\n\t\tif(deep[top[x]]\u003cdeep[top[y]])\n\t\t\tswap(x,y);\n\t\tupdate(id[top[x]],id[x],z,1,n,1);\n\t\tx = fa[top[x]];\n\t}\n\tif(deep[x]\u003edeep[y])\n\t\tswap(x,y);\n\tupdate(id[x],id[y],z,1,n,1);\n}\n\nint query(int x,int y)\n{\n\tint ans = 0;\n\twhile(top[x] != top[y])\n\t{\n\t\tif(deep[top[x]] \u003c deep[top[y]])\n\t\t\tswap(x,y);\n\t\tans = (ans%P + query(id[top[x]],id[x],1,n,1)%P) % P;\n\t\tx = fa[top[x]];\n\t}\n\tif(deep[x]\u003edeep[y])\n\t\tswap(x,y);\n\tans = (ans%P + query(id[x],id[y],1,n,1)%P) % P;\n\treturn ans%P;\n}\n/*-----------------------树剖加线段树--------------------------*/\n\nvoid init()\n{\n\tmemset(head,-1,4*N+4);\n\tcnt = edgeNum = 0;\n}\n\nint u,v,x,y,z,op;\nint main()\n{\t\n\tscanf(\"%d%d%d%d\",\u0026N,\u0026M,\u0026R,\u0026P);\n\tinit();\n\tfor(int i=1;i\u003c=N;++i)\n\t\tscanf(\"%d\",\u0026w[i]);\n\tfor(int i=1;i\u003cN;++i)\n\t{\n\t\tscanf(\"%d%d\",\u0026u,\u0026v);\n\t\tadd(u,v);\n\t\tadd(v,u);\n\t}\n\tdfs1(R,0,0);\n\tdfs2(R,R);\n\tbuild(1,n,1);\n\twhile(M--)\n\t{\n\t\tscanf(\"%d%d\",\u0026op,\u0026x);\n\t\tif(op==1)\n\t\t{\n\t\t\tscanf(\"%d%d\",\u0026y,\u0026z);\n\t\t\tupdate(x,y,z);\n\t\t}\n\t\telse if(op==2)\n\t\t{\n\t\t\tscanf(\"%d\",\u0026y);\n\t\t\tprintf(\"%d\\n\",query(x,y)%P);\n\t\t}\n\t\telse if(op==3)\n\t\t{\n\t\t\tscanf(\"%d\",\u0026z);\n\t\t\tupdate(id[x],id[x]+siz[x]-1,z,1,n,1);\n\t\t}\n\t\telse\n\t\t\tprintf(\"%d\\n\",query(id[x],id[x]+siz[x]-1,1,n,1));\n\t}\n\treturn 0;\n}\n```\n",
        "Title": "树剖模板(点权)(洛谷P3384)",
        "CreateTime": 1532447499000,
        "FormatTime": "2018.07.24",
        "Categories": "数据结构",
        "Tags": [
            ""
        ],
        "EditorType": "markdown"
    },
    {
        "Content": "\t题意：三种操作，0 e 表示插入一个数字e，1 e 表示删除一个数字e，2 e k 表示查询比e大的第k个数，删除和查询均可能没有\n\t目标。\n\n\t思路：建一棵权值线段树，维护每个数字区间中数字的数量。 查询时，先查出1到e的数字数量n，然后查询第k+n大。\n\n```\n#include\u003ccstdio\u003e\n#include\u003ccstring\u003e\nusing namespace std;\n#define lson l,m,rt\u003c\u003c1\n#define rson m+1,r,rt\u003c\u003c1|1\nconst int maxn = 1e5 + 10;\nconst int N = 100000;\nint num[maxn\u003c\u003c2];\nvoid update(int pos,int val,int l,int r,int rt)\n{\n    if(l==r)\n    {\n        if(num[rt]+val\u003c0)\n        {\n            printf(\"No Elment!\\n\");\n            return ;\n        }\n        num[rt] += val;\n        return ;\n    }\n\n    int m = l + r \u003e\u003e 1;\n    if(pos\u003c=m)\n        update(pos,val,lson);\n    else\n        update(pos,val,rson);\n    num[rt] = num[rt\u003c\u003c1] + num[rt\u003c\u003c1|1];\n}\n\nint query(int k,int l,int r,int rt)//找第k大\n{\n    if(num[rt]\u003ck)\n    {\n        printf(\"Not Find!\\n\");\n        return -1;\n    }\n    if(l==r)\n        return l;\n    int m = l + r \u003e\u003e 1;\n    if(k\u003c=num[rt\u003c\u003c1])\n        return query(k,lson);\n    else\n        return query(k-num[rt\u003c\u003c1],rson);\n}\n\nint query(int L,int R,int l,int r,int rt)//L\u003c= \u003c=R的数的数量\n{\n    if(L\u003c=l\u0026\u0026r\u003c=R)\n        return num[rt];\n    int m = l + r \u003e\u003e 1;\n    int ans = 0;\n    if(L\u003c=m)\n        ans += query(L,R,lson);\n    if(R\u003em)\n        ans += query(L,R,rson);\n    return ans;\n}\n\nvoid init()\n{\n    memset(num,0,sizeof(num));\n}\n\nint Q,p,e,k,n;\nint main()\n{\n    while(scanf(\"%d\",\u0026Q)!=EOF)\n    {\n        init();\n        while(Q--)\n        {\n            scanf(\"%d%d\",\u0026p,\u0026e);\n            if(!p)\n                update(e,1,1,N,1);\n            else if(p==1)\n                update(e,-1,1,N,1);\n            else\n            {\n                scanf(\"%d\",\u0026k);\n                n = query(1,e,1,N,1);\n                k += n;\n                n = query(k,1,N,1);\n                if(n!=-1)\n                    printf(\"%d\\n\",n);\n            }\n        }\n    }\n    return 0;\n}\n\n```",
        "Title": "HDU2852 KiKi's K-Number (权值线段树求第k大)",
        "CreateTime": 1531917860000,
        "FormatTime": "2018.07.18",
        "Categories": "数据结构",
        "Tags": [
            ""
        ],
        "EditorType": "markdown"
    },
    {
        "Content": "题意: 输入N个数字，查询区间[L,R]中有多少个不同的数字\n\t(第i个数字为a[i])\n\t思路：要维护的是不同的数字的数量，所以每个数只记最后出现的那一次。对N个位置每个位置建一棵线段树，线段树维护的是插入\n\ta[i]后树上各区间数字的数量。如果a[i]这个数字在前面被插入过，就在新建的树中把 包含a[i]的上一个位置的 所有区间 的 \n\t值-1，然后再照常插入a[i]，因此要用一个数组记录a[i]上次插入时的位置。查询时只要查R对应的版本的线段树就行了。\t\n\n```c\n#include\u003cbits/stdc++.h\u003e\nusing namespace std;\nconst int maxn = 30010;\nint t[maxn*30],tot,rts[maxn],lson[maxn*30],rson[maxn*30];\n\nvoid add(int pos,int val,int l,int r,int \u0026rt,int lst)\n{\n    rt = ++tot;\n    t[rt] = t[lst]+val,lson[rt] = lson[lst],rson[rt] = rson[lst];\n    if(l==r)\n        return ;\n    int m = l + r \u003e\u003e 1;\n    if(pos\u003c=m)\n        add(pos,val,l,m,lson[rt],lson[lst]);\n    else\n        add(pos,val,m+1,r,rson[rt],rson[lst]);\n}\n\nint query(int L,int R,int l,int r,int rt)\n{\n    if(L\u003c=l\u0026\u0026r\u003c=R)\n        return t[rt];\n    int m = l + r \u003e\u003e 1,ans = 0;\n    if(L\u003c=m)\n        ans += query(L,R,l,m,lson[rt]);\n    if(R\u003em)\n        ans += query(L,R,m+1,r,rson[rt]);\n    return ans;\n}\n\nint N,a[maxn],x,y,Q,past[1000005];\nint main()\n{\n    scanf(\"%d\",\u0026N);\n    for(int i=1;i\u003c=N;++i)\n        scanf(\"%d\",\u0026a[i]);\n\n    for(int i=1;i\u003c=N;++i)\n    {\n        if(past[a[i]])//插入过\n        {\n            add(past[a[i]],-1,1,N,rts[i],rts[i-1]);//先把上个位置-1\n            add(i,1,1,N,rts[i],rts[i]);//再把新的位置+1\n        }\n        else\n            add(i,1,1,N,rts[i],rts[i-1]);\n        past[a[i]] = i;\n    }\n\n    scanf(\"%d\",\u0026Q);\n    while(Q--)\n    {\n        scanf(\"%d%d\",\u0026x,\u0026y);\n        printf(\"%d\\n\",query(x,y,1,N,rts[y]));\n    }\n    return 0;\n}\n\n```\n\t\t \n",
        "Title": "SPOJ3267 D-query(可持久化线段树)",
        "CreateTime": 1531917443000,
        "FormatTime": "2018.07.18",
        "Categories": "数据结构",
        "Tags": [
            ""
        ],
        "EditorType": "markdown"
    },
    {
        "Content": "实在太蠢了搞不定ST表o(╥﹏╥)o，只能学个倍增法了。\n\n讲倍增法前先看看暴力法。\n第一步肯定是dfs求每个点的深度。\n查询lca(a,b)时，先把ab中深度较大的点往上移，移到两个点深度相同为止；\n现在两个点深度相同了，于是两个点一起往上移，直至移到同一个位置，即最近公共祖先。\n\n倍增法其实就是在暴力的基础上，对把两个点上移的过程进行倍增操作(因为一步一步走真的很慢啊)\n\n倍增操作即：如果向上移动 $2^i$ 步后，两个点的位置仍不相同，则把两个点直接往上移 $2^i$ 步\n\t\t\t\t\t  (为什么两个点的位置不能相同？因为相同的话大概率就跑过头了啊)\n\t\t\t\t\t  i从树的最大深度开始递减，这样往上走，最终两个点会相聚在最近公共祖先，或差一步到达最近公共祖先\n\t\t\t\t\t  操作的过程中需要预处理的量:\n\t\t\t\t\t\t  fa[ ]数组，fa[v] = u表示v的父节点为u\n\t\t\t\t\t\t  anc[ ][ ]数组，anc[i][j] = k表示节点 i 往上走 $2^j$ 步会走到节点k\n\t\t\t\t\t\t  in[ ],out[ ]，dfs序的入出时间戳(特判会用到，见代码注释)\n\t\t\t\t\t\t  deep[ ]数组，deep[u]=d表示节点u的深度为d\n\t\t\t\t\t\t  树的最大深度m,可以默认20，也可以根据输入的N算一下\n\nanc的求法:\n\t显然anc[i][0] = fa[i]\n\t容易得到，i向上走 $2^j$ 步的位置与i先向上走 $2^{j-1}$ 步，再向上走 $2^{j-1}$ 步是一样的，\n\t即: anc[i][j] = anc[anc[i][j-1]][j-1]\n\n模板题poj1330的代码:\n\n```\n#include\u003ccstdio\u003e\n#include\u003ccstring\u003e\n#include\u003ccmath\u003e\n#include\u003calgorithm\u003e\nusing namespace std;\n\nconst int maxn = 10010;\n\nstruct edge\n{\n    int to,next;\n}e[maxn\u003c\u003c1];\nint head[maxn\u003c\u003c1],cnt,fa[maxn],anc[maxn][20],in[maxn],out[maxn],tot,m;\nvoid add(int u,int v)\n{\n    e[tot].next = head[u];\n    e[tot].to = v;\n    head[u] = tot++;\n}\n\nvoid init(int N)\n{\n    m = ceil(log(N+0.0)/log(2.0));\n    cnt = 0;\n    memset(head,-1,8*N);\n    memset(fa,0,4*N);\n    memset(anc,0,80*N);\n    tot = 0;\n}\n\nint deep[maxn],maxdeep;\nvoid dfs(int u,int pre,int d)\n{\n    in[u] = ++cnt;\n    deep[u] = d;\n    anc[u][0] = fa[u];\n    for(int i=1;i\u003c=m;++i)\n    {\n        anc[u][i] = anc[anc[u][i-1]][i-1];\n        if(!anc[u][i])\n            break;\n    }\n    for(int i=head[u];~i;i=e[i].next)\n    {\n        int v = e[i].to;\n        if(v == pre)\n            continue;\n        dfs(v,u,d+1);\n    }\n    out[u] = cnt;\n}\n\nint lca(int a,int b)\n{\n    if(deep[a]\u003edeep[b])//保证a在上面\n        swap(a,b);\n    if(in[a]\u003c=in[b]\u0026\u0026out[b]\u003c=out[a])//在dfs序中，a夹着b，即b在a的子树中，\n        return a;                   //最近公共祖先显然是a\n    for(int i=m;~i;--i)\n        if(deep[a]\u003cdeep[b]\u0026\u0026deep[a]\u003c=deep[anc[b][i]])\n            b = anc[b][i];//上移至深度相同，也可以倍增\n    for(int i=m;~i;--i)\n    {\n        if(anc[a][i]!=anc[b][i])\n            a = anc[a][i],b = anc[b][i];\n    }\n    return anc[a][0];\n}\n\nint T,N,u,v,rt,a,b;\nint main()\n{\n    scanf(\"%d\",\u0026T);\n    while(T--)\n    {\n        scanf(\"%d\",\u0026N);\n        init(N);\n        for(int i=1;i\u003cN;++i)\n        {\n            scanf(\"%d%d\",\u0026u,\u0026v);\n            add(u,v);\n            add(v,u);\n            fa[v] = u;\n        }\n        rt = 1;\n        while(fa[rt]) ++rt;\n        dfs(rt,rt,1);\n        scanf(\"%d%d\",\u0026a,\u0026b);\n        printf(\"%d\\n\",lca(a,b));\n    }\n    return 0;\n}\n//(PS:单论这题的最优解法应该是暴力，因为只有一组查询。。。)\n```\n\n \t\t\t\t\t\t  ",
        "Title": "倍增法求LCA(最近公共祖先)",
        "CreateTime": 1531500654000,
        "FormatTime": "2018.07.14",
        "Categories": "图算法",
        "Tags": [
            ""
        ],
        "EditorType": "markdown"
    },
    {
        "Content": "老板与员工之间是树形关系。每次给一个员工下达任务就是修改这个员工为根的子树。\n用dfs序把每一棵子树转化成一个区间，用线段树维护，T就是区间更新维护lazy，C就是单点查询。\n```\n#include \u003cbits/stdc++.h\u003e\nusing namespace std;\nconst int maxn = 50005;\nint T,N,M,u,v,L[maxn\u003c\u003c2],R[maxn\u003c\u003c2],cnt,task[maxn\u003c\u003c2];\nvector\u003cint\u003e boss[maxn];\nint emp[maxn];\nvoid init()\n{\n    memset(emp,0,sizeof(emp));\n    for(int i=0;i\u003c=N;++i)\n    {\n\t\tboss[i].clear();\n\t}\n    cnt = 0;\n}\n\nvoid dfs(int u)\n{\n    L[u] = ++cnt;\n    int len = boss[u].size();\n    for(int i=0;i\u003clen;++i)\n    {\n        dfs(boss[u][i]);\n    }\n    R[u] = cnt;\n}\n\nvoid build(int l,int r,int rt)\n{\n    task[rt] = -1;\n    if(l==r)\n        return ;\n    int m = l + r\u003e\u003e1;\n    build(l,m,rt\u003c\u003c1);\n    build(m+1,r,rt\u003c\u003c1|1);\n}\n\nvoid pushdown(int rt)\n{\n    if(~task[rt])\n    {\n        task[rt\u003c\u003c1] = task[rt\u003c\u003c1|1] = task[rt];\n        task[rt] = -1;\n    }\n}\n\nvoid update(int L,int R,int C,int l,int r,int rt)\n{\n    if(L\u003c=l\u0026\u0026r\u003c=R)\n    {\n        task[rt] = C;\n        return ;\n    }\n    int m = l + r\u003e\u003e1;\n    pushdown(rt);\n    if(L\u003c=m)\n        update(L,R,C,l,m,rt\u003c\u003c1);\n    if(R\u003em)\n        update(L,R,C,m+1,r,rt\u003c\u003c1|1);\n}\n\nint query(int p,int l,int r,int rt)\n{\n    if(l==r)\n        return task[rt];\n    pushdown(rt);\n    int m = l + r\u003e\u003e1;\n    if(p\u003c=m)\n        return query(p,l,m,rt\u003c\u003c1);\n    else\n        return query(p,m+1,r,rt\u003c\u003c1|1);\n}\nchar op[2];\nint x,y;\nint main()\n{\n    int cas = 1;\n    scanf(\"%d\",\u0026T);\n    while(T--)\n    {\n        init();\n        scanf(\"%d\",\u0026N);\n        for(int i=1;i\u003cN;++i)\n        {\n            scanf(\"%d%d\",\u0026u,\u0026v);\n            emp[u] = 1;\n            boss[v].push_back(u);\n        }\n        for(int i=1;i\u003c=N;++i)\n            if(!emp[i])//不是任何人的员工，即老板(树根)\n            {\n                dfs(i);\n                break;\n            }\n        build(1,cnt,1);\n        scanf(\"%d\",\u0026M);\n        printf(\"Case #%d:\\n\",cas++);\n        while(M--)\n        {\n            scanf(\"%s\",op);\n            if(op[0]=='C')\n            {\n                scanf(\"%d\",\u0026x);\n                printf(\"%d\\n\",query(L[x],1,cnt,1));\n            }\n            else\n            {\n                scanf(\"%d%d\",\u0026x,\u0026y);\n                update(L[x],R[x],y,1,cnt,1);\n            }\n        }\n    }\n    return 0;\n}\n```",
        "Title": "HDU3974 Assign the task(dfs序+线段树)",
        "CreateTime": 1531137195000,
        "FormatTime": "2018.07.09",
        "Categories": "数据结构",
        "Tags": [
            ""
        ],
        "EditorType": "markdown"
    },
    {
        "Content": "离散化：\n\t对数组排完序后用unique去重，unique返回的是去重后的数组的末地址，减去第一个元素的地址就能得到去重后的数组大小，用lower_bound查找原数字在排序去重后的序列中的位序，用位序代替数字完成离散化。\n\n```c\n#include\u003ccstdio\u003e\n#include\u003calgorithm\u003e\nusing namespace std;\n#define lson l,m,ls[rt]\n#define rson m+1,r,rs[rt] \ntypedef long long ll;\nconst int maxn = 1e5 + 5;\nint ls[maxn*30],rs[maxn*30],tot,rts[maxn];//tot为总结点数 \nint t[maxn*30];\nint a[maxn],num[maxn];\n\nvoid build(int l,int r,int \u0026rt)\n{\n\trt = ++tot;\n\tt[rt] = 0;//建一棵全为0的空树。 \n\tif(l==r)\t\t\n\t\treturn ;\n\tint m = l+r\u003e\u003e1;\n\tbuild(lson); \n\tbuild(rson);\n}\n\nvoid add(int p,int C,int l,int r,int \u0026rt,int lst)\n{\n\trt = ++tot;\n\tls[rt] = ls[lst],rs[rt] = rs[lst];\n\tt[rt] = t[lst] + C;\t\t\t\t\t//先从上一个版本的结点拷贝信息，因为传的是引用， \n\tif(l==r)\t\t\t\t\t\t\t//进入下一层递归时rt = ++tot;这一句会给新的结点编号。 \n\t\treturn ;\n\tint m = l+r\u003e\u003e1;\n\tif(p\u003c=m)\n\t\tadd(p,C,lson,ls[rt]);\n\telse\n\t\tadd(p,C,rson,rs[rt]);\n}\n\nint query(int x,int y,int l,int r,int k)\n{\n\tif(l==r)\n\t\treturn l;\n\tint c = t[ls[y]] - t[ls[x]];//c表示左子树中数字的数量 \n\tint m = l+r\u003e\u003e1;\n\tif(c\u003e=k)//k\u003c=c时，第k小是左子树中的第k小。\n\t\treturn query(ls[x],ls[y],l,m,k);\n\telse//k\u003ec时，第k小是右子树中的第k-c小 \n\t\treturn query(rs[x],rs[y],m+1,r,k-c);\t\n}\n\nint N,M,c,x,y,k;\nint main()\n{\n\twhile(scanf(\"%d%d\",\u0026N,\u0026M)!=EOF)\n\t{\n\t\ttot = 0;\t\n\t\tfor(int i=1;i\u003c=N;++i)\n\t\t{\n\t\t\tscanf(\"%d\",\u0026a[i]);\n\t\t\tnum[i] = a[i];\n\t\t}\n\t\t\n\t\tsort(num+1,num+N+1);\n\t\tint cnt = unique(num+1,num+N+1)-(num+1);\n\t\tbuild(1,cnt,rts[0]);\n\t\tfor(int i=1;i\u003c=N;++i)\n\t\t\ta[i] = lower_bound(num+1,num+cnt+1,a[i])-num;\n\t\t\n\t\tfor(int i=1;i\u003c=N;++i)\n\t\t\tadd(a[i],1,1,cnt,rts[i],rts[i-1]);\n\t\t\t\t\t\n\t\twhile(M--)\n\t\t{\n\t\t\tscanf(\"%d%d%d\",\u0026x,\u0026y,\u0026k);\n\t\t\tprintf(\"%d\\n\",num[query(rts[x-1],rts[y],1,cnt,k)]);\n\t\t}\n\t}\t\n\treturn 0;\n}\n```\n",
        "Title": "主席树模板(POJ2104)",
        "CreateTime": 1531115295000,
        "FormatTime": "2018.07.09",
        "Categories": "数据结构",
        "Tags": [
            ""
        ],
        "EditorType": "markdown"
    },
    {
        "Content": "```\n#include\u003ccstdio\u003e\n#include\u003calgorithm\u003e\n#include\u003ccstring\u003e\nusing namespace std;\n#define lson l,m,rt\u003c\u003c1\n#define rson m+1,r,rt\u003c\u003c1|1\n\nconst int maxn = 50010;\nint ls[maxn\u003c\u003c2],rs[maxn\u003c\u003c2],ms[maxn\u003c\u003c2],lazy[maxn\u003c\u003c2];\n\nvoid pushdown(int rt,int len)\n{\n\tif(~lazy[rt])\n\t{\n\t\tlazy[rt\u003c\u003c1] = lazy[rt\u003c\u003c1|1] = lazy[rt];\n\t\tif(lazy[rt])//0,入住\n\t\t{\n\t\t\tms[rt\u003c\u003c1] = ls[rt\u003c\u003c1] = rs[rt\u003c\u003c1] = 0;\n\t\t\tms[rt\u003c\u003c1|1] = ls[rt\u003c\u003c1|1] = rs[rt\u003c\u003c1|1] = 0;\n\t\t}\n\t\telse//1,退房\n\t\t{\n\t\t\tms[rt\u003c\u003c1] = ls[rt\u003c\u003c1] = rs[rt\u003c\u003c1] = len-(len\u003e\u003e1);\n\t\t\tms[rt\u003c\u003c1|1] = ls[rt\u003c\u003c1|1] = rs[rt\u003c\u003c1|1] = len\u003e\u003e1;\n\t\t}\n\t\tlazy[rt] = -1;\n\t}\n}\n\nvoid pushup(int rt,int len)\n{\n\tls[rt] = ls[rt\u003c\u003c1];\n\trs[rt] = rs[rt\u003c\u003c1|1];\n\tif(ls[rt]==len-len/2)\n\t\tls[rt] += ls[rt\u003c\u003c1|1];\n\tif(rs[rt]==len/2)\n\t\trs[rt] += rs[rt\u003c\u003c1];\n\tms[rt] = max(max(ms[rt\u003c\u003c1],ms[rt\u003c\u003c1|1]),ls[rt\u003c\u003c1|1]+rs[rt\u003c\u003c1]);\n}\n\n\nvoid build(int l,int r,int rt)\n{\n\tms[rt] = ls[rt] = rs[rt] = r-l+1;\n\tlazy[rt] = -1;\n\tif(l==r)\n\t\treturn ;\n\tint m = (l+r)\u003e\u003e1;\n\tbuild(lson);\n\tbuild(rson);\n}\n\nvoid update(int L,int R,int C,int l,int r,int rt)\n{\n\tif(L\u003c=l\u0026\u0026r\u003c=R)\n\t{\n\t\tif(!C)//退房\n\t\t\tms[rt] = ls[rt] = rs[rt] = (r-l+1);\n\t\telse//入住\n\t\t\tms[rt] = ls[rt] = rs[rt] = 0;\n\t\tlazy[rt] = C;\n\t\treturn ;\n\t}\n\tpushdown(rt,r-l+1);\n\tint m = (l + r)\u003e\u003e1;\n\tif(L\u003c=m)\n\t\tupdate(L,R,C,lson);\n\tif(R\u003em)\n\t\tupdate(L,R,C,rson);\n\tpushup(rt,r-l+1);\n}\n\n\nint query(int len,int l,int r,int rt)\n{\n\tif(l==r)\n\t\treturn l;\n\tpushdown(rt,r-l+1);\n\tint m = (l+r)\u003e\u003e1;\n\tif(ms[rt\u003c\u003c1]\u003e=len)\n\t\treturn query(len,lson);\n\telse if(ls[rt\u003c\u003c1|1]+rs[rt\u003c\u003c1]\u003e=len)\n\t\treturn m - rs[rt\u003c\u003c1] + 1;//ls[rt\u003c\u003c1|1]的l\n\telse\n\t\treturn query(len,rson);\n}\n\nint N,M,op,len,x,y,p;\nint main()\n{\n    scanf(\"%d%d\",\u0026N,\u0026M);\n    build(1,N,1);\n    while(M--)\n\t{\n\t\tscanf(\"%d\",\u0026op);\n\t\tif(op==1)\n\t\t{\n\t\t\tscanf(\"%d\",\u0026len);//printf(\"ms[1]==%d\\n\",ms[1]);\n\t\t\tif(ms[1]\u003clen)\n\t\t\t\tprintf(\"0\\n\");\n\t\t\telse\n\t\t\t{\n\n\t\t\t\tp = query(len,1,N,1);\n\t\t\t\tprintf(\"%d\\n\",p);\n\t\t\t\tupdate(p,p+len-1,1,1,N,1);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tscanf(\"%d%d\",\u0026x,\u0026y);\n\t\t\tupdate(x,x+y-1,0,1,N,1);\n\t\t}\n\t}\n\treturn 0;\n}\n```",
        "Title": "POJ3667(线段树区间合并)",
        "CreateTime": 1530890188000,
        "FormatTime": "2018.07.06",
        "Categories": "数据结构",
        "Tags": [
            ""
        ],
        "EditorType": "markdown"
    },
    {
        "Content": "今天课上学的堆排序。\n\n```\n#include\u003cbits/stdc++.h\u003e\nusing namespace std;\n\nvoid HeapAdjust(int a[],int i,int len)\n{\n\tif(i\u003elen/2)//大于len/2的是叶子结点，不用调整 \n\t\treturn ;\n\tint m = i;\n\tif((i\u003c\u003c1)\u003c=len)\n\t\tm = a[i]\u003ea[i\u003c\u003c1] ? i : i\u003c\u003c1; \n\tif((i\u003c\u003c1|1)\u003c=len)\n\t\tm = a[m]\u003ea[i\u003c\u003c1|1] ? m : i\u003c\u003c1|1;\n\t//在左右子节点中找出最大值的下标 \n\tif(m!=i)\n\t{\n\t\tswap(a[i],a[m]);\n\t\tHeapAdjust(a,m,len);//保证交换后的子树仍能构成堆 \n\t}\t\t\n}\n\nvoid BuildHeap(int a[],int len)\n{\n\tint i = len\u003e\u003e1;//非叶节点最大序号值为len/2 \n\twhile(i)\n\t\tHeapAdjust(a,i--,len);\n}\n\nvoid HeapSort(int a[],int len)\n{\n\tBuildHeap(a,len);//此时a[1]是最大值 \n\tint i = len;\n\twhile(i)\n\t{\n\t\tswap(a[1],a[i]);//a[1]放到最后，进入有序区 \n\t\tHeapAdjust(a,1,i---1);//堆的大小减1 \n\t}\n}\n\nint N,a[1000];\nint main()\n{\n\t\n\twhile(scanf(\"%d\",\u0026N)!=EOF)\n\t{\n\t\tfor(int i=1;i\u003c=N;++i)\n\t\t\tscanf(\"%d\",\u0026a[i]);\n\t\tHeapSort(a,N);\n\t\tfor(int i=1;i\u003c=N;++i)\n\t\t\tprintf(\"%d%c\",a[i],i==N?'\\n':' ');\n\t}\n\treturn 0; \n}\n```",
        "Title": "堆排序",
        "CreateTime": 1529677087000,
        "FormatTime": "2018.06.22",
        "Categories": "数据结构",
        "Tags": [
            ""
        ],
        "EditorType": "markdown"
    },
    {
        "Content": "```\n#define lson l,m,rt\u003c\u003c1\n#define rson m+1,r,rt\u003c\u003c1|1\n#define pushup(rt) t[rt] = t[rt\u003c\u003c1] + t[rt\u003c\u003c1|1];\nconst int maxn = 100000+10;\ntypedef long long ll;\nll t[maxn\u003c\u003c2],lazy[maxn\u003c\u003c2],a[maxn];\n\nvoid build(int l,int r,int rt)\n{\n\tlazy[rt] = 0;\n\tif(l==r)\n\t{\n\t\tscanf(\"%lld\",\u0026t[rt]);\n\t\treturn ;\n\t}\n\tint m = (l+r)\u003e\u003e1;\n\tbuild(lson);\n\tbuild(rson);\n\tpushup(rt);\n}\n\n\nvoid pushdown(int l,int r,int rt)\n{\n\tif(lazy[rt])\n\t{\n\t\tlazy[rt\u003c\u003c1] += lazy[rt];\n\t\tlazy[rt\u003c\u003c1|1] += lazy[rt];\n\t\tt[rt\u003c\u003c1] += l*lazy[rt];\n\t\tt[rt\u003c\u003c1|1] += r*lazy[rt];\n\t\tlazy[rt] = 0;\n\t}\n}\nvoid update(int L,int R,int C,int l,int r,int rt)\n{\n\tif(L\u003c=l\u0026\u0026r\u003c=R)\n\t{\n\t\tt[rt] += (r-l+1)*C;\n\t\tlazy[rt] += C;\n\t\treturn ;\n\t}\n\tint m = (l+r)\u003e\u003e1;\n\tpushdown(m-l+1,r-m,rt);\n\tif(L\u003c=m)\n\t\tupdate(L,R,C,lson);\n\tif(R\u003em)\n\t\tupdate(L,R,C,rson);\n\tpushup(rt);\n}\n\nll query(int L,int R,int l,int r,int rt)\n{\n\tif(L\u003c=l\u0026\u0026r\u003c=R)\n\t\treturn t[rt];\n\tint m = (l+r)\u003e\u003e1;\n\tpushdown(m-l+1,r-m,rt);\n\tll ans = 0;\n\tif(L\u003c=m)\n\t\tans += query(L,R,lson);\n\tif(R\u003em)\n\t\tans += query(L,R,rson);\n\treturn ans;\n}\n```",
        "Title": "线段树模板（新）",
        "CreateTime": 1526462314000,
        "FormatTime": "2018.05.16",
        "Categories": "数据结构",
        "Tags": [
            ""
        ],
        "EditorType": "markdown"
    },
    {
        "Content": "思路:先序序列的每个元素代表一个根节点，这个元素在中序序列中左边的部分就是它的左子树，右边部分就是它的右子树\n\n代码如下(求树深度的部分是多余的):\n\n```\n#include\u003ciostream\u003e\nusing namespace std;\nint N;\nstring xian,zhong;\n\nstruct node\n{\n\tchar data;\n\tint d;\n\tnode *lson,*rson;\n\tnode()\n\t{\n\t\tlson = rson = nullptr;\n\t}\n}*root;\n\nint p,depth;\nvoid build(int l,int r,node *\u0026rt,int d)\n{\n\tif(l\u003er)     //下面那个for没找到则l\u003er,\n\t\treturn ;//即该节点是叶子结点，没有孩子节点\n\trt = new node;\n\trt-\u003edata = xian[p];\n\trt-\u003ed = d;\n\tdepth = max(depth,d);\n\tint m;\n\tfor(m=l;m\u003c=r;++m)//在中序序列中找到当前的根\n\t\tif(zhong[m]==xian[p])\n\t\t\tbreak;\n\t++p;\n\tbuild(l,m-1,rt-\u003elson,d+1);//以m为界把中序序列一分为二\n\tbuild(m+1,r,rt-\u003erson,d+1);\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin\u003e\u003eN;\n\tcin\u003e\u003exian;\n\tcin\u003e\u003ezhong;\n\tdepth = 0;\n\tp = 0;\n\tbuild(0,N-1,root,1);\n\tcout\u003c\u003cdepth\u003c\u003cendl;\n\treturn 0;\n}\n\n```",
        "Title": "根据二叉树的先序遍历和中序遍历序列建树",
        "CreateTime": 1526286548000,
        "FormatTime": "2018.05.14",
        "Categories": "数据结构",
        "Tags": [
            ""
        ],
        "EditorType": "markdown"
    },
    {
        "Content": "Painting some colored segments on a line, some previously painted segments may be covered by some the subsequent ones.\nYour task is counting the segments of different colors you can see at last.\n\n\nInput\n\n\nThe first line of each data set contains exactly one integer n, 1 \u003c= n \u003c= 8000, equal to the number of colored segments.\nEach of the following n lines consists of exactly 3 nonnegative integers separated by single spaces:\n\nx1 x2 c\n\nx1 and x2 indicate the left endpoint and right endpoint of the segment, c indicates the color of the segment.\n\nAll the numbers are in the range [0, 8000], and they are all integers.\n\nInput may contain several data set, process to the end of file.\n\n\n\nOutput\n\n\nEach line of the output should contain a color index that can be seen from the top, following the count of the segments of this color, they should be printed according to the color index.\nIf some color can't be seen, you shouldn't print it.\n\nPrint a blank line after every dataset.\n\n\n\nSample Input\n\n\n5\n0 4 4\n0 3 1\n3 4 2\n0 2 2\n0 2 3\n4\n0 1 1\n3 4 1\n1 3 2\n1 3 1\n6\n0 1 0\n1 2 1\n2 3 1\n1 2 0\n2 3 0\n1 2 1\n\n\nSample Output\n\n\n1 1\n2 1\n3 1\n1 1\n\n0 2\n1 1\n\n题意: 输入一个n,n行x,y,c,把区间[x,y]涂成c颜色,问最后每种颜色各有多少块(如11221233,1两块，2两块，3一块)\n\n这一类线段树区间染色覆盖的问题，实际上都是对lazy标记的维护\n首先要把lazy初始化为不存在的值。这题的颜色为0-8000，初始化为-1即可\n现在假设区间[1,5]的颜色为1，欲将区间[1,3]染成2，思路如下:\n\t先将[1,5]分成[1,3]和[4,5]，然后修改[1,3]的值，\n因为此时[1,5]已由[1,3]和[4,5]替换，[1,5]失去意义，故删除[1,5]的lazy值(置为-1)\n这一步中划分和删除操作都在pushdown中实现\n\n```\nvoid pushdown(int rt)\n{\n\tc[rt\u003c\u003c1] = c[rt\u003c\u003c1|1] = c[rt];//划分\n\tc[rt] = -1;//删除\n}\n```\n\t接着上面，若此时要把[1,5]染为3，直接修改[1,5]的lazy值即可，不用管下面的子节点，等到查询的时候再pushdown即可\n\n针对这题: 染区间[1,2],[3,4]为同一种颜色的时候，不能直接修改四个点的值，因为[2,3]显然是没颜色的，在update操作时把区间左值+1，变成左开右闭，避免染多\n\n代码:\n\n```\n#include\u003cbits/stdc++.h\u003e\n#define lson l,m,rt\u003c\u003c1\n#define rson m+1,r,rt\u003c\u003c1|1\n//#define pushup(rt) t[rt]=t[rt\u003c\u003c1]+t[rt\u003c\u003c1|1];\nusing namespace std;\n//typedef long long ll;\nconst int maxn = 8005;\nint c[maxn\u003c\u003c2];\nint ANS[maxn],last;\n\nvoid pushdown(int rt)\n{\n\tc[rt\u003c\u003c1] = c[rt\u003c\u003c1|1] = c[rt];\n\tc[rt] = -1;\n}\nvoid update(int L,int R,int C,int l,int r,int rt)\n{\n\tif(L\u003c=l\u0026\u0026R\u003e=r)\n\t{\n\t\tc[rt] = C;\n\t\treturn ;\n\t}\n\n\tif(~c[rt])\n\t\tpushdown(rt);\n\tint m = (l+r)\u003e\u003e1;\n\tif(L\u003c=m)\n\t\tupdate(L,R,C,lson);\n\tif(R\u003em)\n\t\tupdate(L,R,C,rson);\n}\n\nvoid query(int l,int r,int rt)\n{\n\tif(l==r)\n\t{\n\t\tif(~c[rt]\u0026\u0026c[rt]!=last)//last记录上一个区间的颜色，\n\t\t{                      //不同就让这个区间的颜色块数+1\n\t\t\t++ANS[c[rt]];\n\t\t}\n\t\tlast = c[rt];\n\t\treturn ;\n\t}\n\tint m = (l+r)\u003e\u003e1;\n\tif(~c[rt])\n\t\tpushdown(rt);\n\tquery(lson);\n\tquery(rson);\n}\n\nint N;\nint sum,x,y,col;\nint main()\n{\n\twhile(scanf(\"%d\",\u0026N)!=EOF)\n\t{\n\t\tmemset(c,-1,sizeof(c));\n\t\tmemset(ANS,0,sizeof(ANS));\n\t\tfor(int i=1;i\u003c=N;++i)\n\t\t{\n\t\t\tscanf(\"%d%d%d\",\u0026x,\u0026y,\u0026col);\n\t\t\tif(x\u003cy)\n\t\t\t/*因为下面更新的是x+1,\n\t\t\t当题目输入x == y时不能更新，否则会re*/\n\t\t\t\tupdate(x+1,y,col,1,8000,1);\n\t\t\t\t//区间左值+1变成左开右闭\n\t\t}\n\t\tlast = -1;\n\t\tquery(1,8000,1);\n\t\tfor(int i=0;i\u003c=8000;++i)\n\t\t{\n\t\t\tif(ANS[i])\n\t\t\t\tprintf(\"%d %d\\n\",i,ANS[i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}\n```",
        "Title": "zoj1610- Count the Colors（线段树区间染色覆盖问题）",
        "CreateTime": 1525921800000,
        "FormatTime": "2018.05.10",
        "Categories": "数据结构",
        "Tags": [
            ""
        ],
        "EditorType": "markdown"
    },
    {
        "Content": "\t昨天华工省赛1题打铁QAQ，自己那部分的题也没a出来，有点小难受。\n\t这学期的比赛基本告一段落了，下半学期要先把绩点补一补，先不挂科。然后要继续拓展知识的宽度，在慢慢拓展宽度的情况下选一个方面强化一下深度。 训练了这么多次，感觉RMQ问题还是挺常见的，那就从RMQ入手开始多做些题。\n\t我的计划是先找线段树的题做，然后慢慢学ST和差分，顺带把做题用到的知识点了解一下。 现在总自己对感觉脑子里的数据结构理解很浅，只能a裸题，这个现状得改。 此外，队友学的部分我也得涉猎一些。昨天的B题打完了线段树，搞定了环，就差个素数筛，而且队友会，但是我不知道有这东西，他也不知道我在干啥→_→ ......\n\t继续努力。\n\t",
        "Title": "小小学习计划∠( ᐛ 」∠)＿",
        "CreateTime": 1525624984000,
        "FormatTime": "2018.05.07",
        "Categories": "杂",
        "Tags": [
            ""
        ],
        "EditorType": "markdown"
    },
    {
        "Content": "写的链式的，数组实现还不会。\n链式如果delete就会花费很多时间，不delete就花很多内存。\n就先这样吧......\n```\n#include\u003cbits/stdc++.h\u003e\nusing namespace std;\n\nstring str,pri;\nint T,n;\nstruct Node\n{\n    int cnt;\n    Node *next[26];\n    Node *fail;\n    Node()\n    {\n        cnt = 0;\n        memset(next,0,sizeof(next));\n        fail = nullptr;\n    }\n}*rt,*p,*pp;//要在主函数第一行写上 rt = new Node;\n\n\nvoid Insert(string str)//往字典树中插入一个字符串\n{\n    int a;\n    Node *p = rt;\n    for(int i=0;str[i]!='\\0';++i)\n    {\n        a = str[i] - 'a';\n        if(p-\u003enext[a] == NULL)\n        {\n            p-\u003enext[a] = new Node;\n            p-\u003enext[a]-\u003ecnt = 0;\n        }\n        p = p-\u003enext[a];\n    }\n    ++p-\u003ecnt;//记录该单词出现的次数\n}\n\n\nvoid getfail()\n{\n\tqueue\u003cNode*\u003e que;\n\tque.push(rt);                          \t//根节点先入队\n\twhile(!que.empty())\t\t\t\t\t   \n\t{\n\t\tp = que.front();\n\t\tque.pop();\n\t\tfor(int i=0;i\u003c26;i++)\t\t\t\t//遍历队首元素的next，\n\t\t{\n\t\t\tif(p-\u003enext[i])\n\t\t\t{\n\t\t\t\tif(p==rt)\t\t\t\t\t//根节点的子节点的fail指针直接指向rt\n\t\t\t\t\tp-\u003enext[i]-\u003efail = rt;\t//(显然，因为同一层不可能存在相同的节点)\n\t\t\t\telse\t\t\t\t\t\t//从p的fail指针指向的元素中找存在next[i]的\n\t\t\t\t{\n\t\t\t\t\tpp = p-\u003efail;\n\t\t\t\t\twhile(pp)\t\t\t\t//pp为rt的时候退出循环\n\t\t\t\t\t{\n\t\t\t\t\t\tif(pp-\u003enext[i])\t\t//找到就把fail指过去\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tp-\u003enext[i]-\u003efail = pp-\u003enext[i];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpp = pp-\u003efail;\n\t\t\t\t\t}\n\t\t\t\t\tif(pp==nullptr)\t\t\t//找不到就指rt\n\t\t\t\t\t\tp-\u003enext[i]-\u003efail = rt;\n//\t\t\t\t\tif(!p-\u003enext[i]-\u003efail)   这样写也可以\n//\t\t\t\t\t\tp-\u003enext[i]-\u003efail = rt;\n\t\t\t\t}\n\t\t\t\tque.push(p-\u003enext[i]);//p的所有子节点入队\n\t\t\t}\n\t\t}\n\t}\n}\n\nint query()\n{\n\tint i;//主串下标\n\tint a;\n\tint cnt = 0;//模式串出现的次数\n\tp = rt;\n\tint len = str.length();\n\tfor(int i=0;i\u003clen;i++)\n\t{\n\t\ta = str[i] - 'a';\n\t\twhile(p-\u003enext[a]==nullptr\u0026\u0026p!=rt)\t//找主串第i个元素首次出现的位置\n\t\t\tp = p-\u003efail;\t\t\t\t\t//当前节点的next找不到就跳到fail\n\t\tp = p-\u003enext[a];\n\t\tif(p==nullptr)//没找到\n\t\t\tp = rt;\n\t\tpp = p;\n\t\twhile(pp!=rt)//从str[i]首次出现的地方往后找\n\t\t{\n\t\t\tif(pp-\u003ecnt\u003e=0)//找到一个单词，就把这个单词出现的次数统计下来\n\t\t\t{\n\t\t\t\tcnt += pp-\u003ecnt;\n\t\t\t\tpp-\u003ecnt = -1;//-1表示访问过(后面有可能还会搜到这个节点，标记以便查重)\n\t\t\t}\n\t\t\telse//此节点已统计过，不用再往下\n\t\t\t\tbreak;\n\t\t\tpp = pp-\u003efail;\n\t\t}\n\t}\n\treturn cnt;\n}\n\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\n    cin\u003e\u003eT;\n    while(T--)\n\t{\n\t\trt = new Node;\n\t\tcin\u003e\u003en;\n\t\twhile(n--)\n\t\t{\n\t\t\tcin\u003e\u003epri;\n\t\t\tInsert(pri);\n\t\t}\n\t\tgetfail();\n\t\tcin\u003e\u003estr;\n\t\tcout\u003c\u003cquery()\u003c\u003cendl;\n\t\tdelete rt;\n\t}\n}\n```",
        "Title": "AC自动机(hdu2222)",
        "CreateTime": 1524062204000,
        "FormatTime": "2018.04.18",
        "Categories": "字符串",
        "Tags": [
            ""
        ],
        "EditorType": "markdown"
    },
    {
        "Content": "```\nchar t[1000005],p[10005];\nint Next[10005];\n\nvoid getNext()\n{\n    int j=0,k=-1;\n    int len = strlen(p);\n    Next[0] = -1;\n    while(j\u003clen)\n        if(k==-1||p[j]==p[k])\n            Next[++j] = ++k;\n        else\n            k = Next[k];\n}\n\nint KMP()\n{\n\tgetNext();\n\tint j = 0,i = 0;\n\tint tlen = strlen(t),plen = strlen(p);\n\twhile(i\u003ctlen\u0026\u0026j\u003cplen)\n\t{\n\t\tif(j==-1||t[i]==p[j])\n\t\t{\n\t\t\t++i;\n\t\t\t++j;\n\t\t}\n\t\telse\n\t\t\tj = Next[j];\n\t}\n\tif(j==plen)\n\t\treturn i-plen;\n\telse\n\t\treturn -1;\t\n}\n\n//nextval应该很少用到吧。。。\nvoid getNextval()\n{\n    int j=0,k=-1;\n    int len = strlen(p);\n    Next[0] = -1;\n    while(j\u003clen)\n        if(k==-1||p[j]==p[k])\n        {\n        \t++j,++k;\n        \tif (p[j] != p[k])\n                Next[j] = k;\n            else\n                Next[j] = Next[k];\n        }\n        \n        else\n            k = Next[k];\n}\n\n```",
        "Title": "KMP模板",
        "CreateTime": 1523449889000,
        "FormatTime": "2018.04.11",
        "Categories": "字符串",
        "Tags": [
            ""
        ],
        "EditorType": "markdown"
    },
    {
        "Content": "好久没打搜索了。。一个bfs哇了一晚上╭(╯^╰)╮\n题目几乎是一个裸的bfs，只不过每个点有两种状态，每走一步状态就反转，所以判下一个点的去过没有的时候要判断与当前状态相反的点。\n代码:\n\n```\n#include \u003cbits/stdc++.h\u003e\nusing namespace std;\n\nbool t[100005]; \nint T,n,m;\nbool vis[100005][2];\nstruct point\n{\n\tint x,y,c;\t\n\tpoint(int X=0,int Y=0,int C=0)\n\t{\n\t\tx = X;\n\t\ty = Y;\n\t\tc = C;\n\t}\n\tbool operator==(point a)\n\t{\n\t\treturn x==a.x\u0026\u0026y==a.y;\n\t}\n}S,E;\n\nbool ok(point \u0026a)\n{\n\tif(a.x\u003e0\u0026\u0026a.y\u003e0\u0026\u0026a.x\u003c=n\u0026\u0026a.y\u003c=m\u0026\u0026!vis[(a.x-1)*m+a.y][a.c%2])\t\n\t{\n\t\tvis[(a.x-1)*m+a.y][a.c%2] = 1;//写在这里下面可以省几行ヽ(￣▽￣)? \n\t\treturn true;\n\t}\n\t\t\n\treturn false;\n} \n\nint bfs()\n{\n\tqueue\u003cpoint\u003e que;\n\tpoint p,ps,px,pz,py;\n\tque.push(S);\n\tvis[(S.x-1)*m+S.y][0] = 1;\n\twhile(!que.empty())\n\t{\n\t\tp = que.front();\n\t\tque.pop();\n\t\tif(p==E)\n\t\t{\n\t\t\treturn p.c;\n\t\t}\n\t\tps = point(p.x-1,p.y,p.c+1);//上下左右 \n\t\tpx = point(p.x+1,p.y,p.c+1);\n\t\tpz = point(p.x,p.y-1,p.c+1);\n\t\tpy = point(p.x,p.y+1,p.c+1);\n\t\tif(!(p.c%2)) //c是偶数，为一种状态 \n\t\t{\n\t\t\tif(t[(p.x-1)*m+p.y]%2==0)//0上下，1左右 \n\t\t\t{\n\t\t\t\tif(ok(ps))\n\t\t\t\t\tque.push(ps);\n\t\t\t\tif(ok(px))\n\t\t\t\t\tque.push(px);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(ok(pz))\n\t\t\t\t\tque.push(pz);\t\n\t\t\t\tif(ok(py))\n\t\t\t\t\tque.push(py);\t\n\t\t\t}\t\n\t\t} \n\t\telse//c是奇数，另一种状态 \n\t\t{\n\t\t\tif(t[(p.x-1)*m+p.y]%2==0)//0左右，1上下 \n\t\t\t{\n\t\t\t\tif(ok(pz))\n\t\t\t\t\tque.push(pz);\t\n\t\t\t\tif(ok(py))\n\t\t\t\t\tque.push(py);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(ok(ps))\n\t\t\t\t\tque.push(ps);\n\t\t\t\tif(ok(px))\n\t\t\t\t\tque.push(px);\t\n\t\t\t}\t\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main()\n{\n\tscanf(\"%d\",\u0026T);\n\twhile(T--)\n\t{\n\t\tmemset(vis,0,sizeof(vis));\n\t\tscanf(\"%d%d\",\u0026n,\u0026m);\n\t\tint l = 1;\n\t\tfor(int i=1;i\u003c=n;i++)\n\t\t{\t\n\t\t\tfor(int j=1;j\u003c=m;j++)\n\t\t\t{\n\t\t\t\tscanf(\"%d\",\u0026t[l++]);\n\t\t\t}\n\t\t} \t\t\t\n\t\tscanf(\"%d%d%d%d\",\u0026S.x,\u0026S.y,\u0026E.x,\u0026E.y);\n\t\tprintf(\"%d\\n\",bfs());\n\t}\t\n}\n```",
        "Title": "ZOJ4020 Traffic Light (bfs)",
        "CreateTime": 1523435469000,
        "FormatTime": "2018.04.11",
        "Categories": "搜索",
        "Tags": [
            ""
        ],
        "EditorType": "markdown"
    },
    {
        "Content": "题目主干如下：\n链接：https://www.nowcoder.com/acm/contest/94/E\n来源：牛客网\n\n我们给出一个字符串的集合，在这个集合中有个字符串，编号为的字符串的长度为。我们给出个查询，每个查询是一个整数对，表示我们假定号串在左边，号串在右边，我们要查询的是最大的长度使号串的前缀与号串的后缀相等。\n如我们有串：\"ACGT\"、\"AACCGGTT\"、“AAAA”，则查询(2,3)的结果为0，因为\"AAAA\"在右面欲与左面的\"AACCGGTT\"进行拼接，显然并没有公共的前后缀区域可以使两串拼接。而查询(3,2)的结果为2，因为此时“AAAA”放在了左面欲与右面的\"AACCGGTT\"拼接，这时有最长的公共区域\"AA\"。\n输入描述:\n多文件，多数据，每个文件中只会有一组测试数据。\n对于每组数据：\n* 第一行，是一个整数表示有多少个串。\n* 接下来的行，每行是一个DNA串，只由\"ACGT\"这四个大写英文字母组成。\n* 接下来的一行，是一个整数，表示查询的个数。\n* 接下来的`$Q$`行，每行有两个整数表示查询的整数对，含义请参见题目描述。\n* 所有的DNA串长度加和不会超过。\n输出描述:\n对于每组查询，输出一个整数，表示答案，独占一行。\n示例1\n输入\n\n3\nAAAA\nACGT\nAACCGGTT\n12\n1 1\n1 2\n1 3\n2 2\n2 3\n3 3\n3 3\n3 2\n3 1\n2 2\n2 1\n1 1\n输出\n\n4\n1\n2\n4\n0\n8\n8\n0\n0\n4\n0\n4\n\n比赛的时候想着自己不会后缀树，凉了凉了，回来看到网上大佬的代码，是真的强无敌，自己对kmp还是不理解啊。\n大佬的思路: 把提供后缀的串接在提供前缀的串前面，得到新串str，求str的next数组，next[str.length]就是最长相同前后缀的长度，为了防止拼接后的字符串越过两个原串的边界，在中间加一个唯一的字符隔开,即str = r + '#' + l，这样跨越了#的前后缀就不可能相同了;\n\n代码如下:\n\n```\n#include\u003cbits/stdc++.h\u003e\nusing namespace std;\n \nstring a[300005],str;\nint Next[300005];\nint N,Q,l,r;\n \nvoid getNext(int len)\n{\n    int j=0,k=-1;\n    Next[0] = -1;\n    while(j\u003clen)\n        if(k==-1||str[j]==str[k])\n            Next[++j] = ++k;\n        else\n            k = Next[k];\n}\n \nint main()\n{\n    ios::sync_with_stdio(false);\n    cin\u003e\u003eN;\n    for(int i=1;i\u003c=N;i++)\n        cin\u003e\u003ea[i];\n    cin\u003e\u003eQ;\n    while(Q--)\n    {\n        cin\u003e\u003el\u003e\u003er;\n        str = a[r] + '*' + a[l];\n        getNext(str.length());     \n        cout\u003c\u003cNext[str.length()]\u003c\u003cendl;\n    }  \n    return 0;\n}\n```\n以后要谨记: next数组存的是该位置最长相同前后缀的长度。 只是背下kmp，或是把模板带去是没用的。。根本不可能有裸题的嘛QAQ\n",
        "Title": "2018年华工校赛E——Youhane Assembler",
        "CreateTime": 1523205575000,
        "FormatTime": "2018.04.09",
        "Categories": "字符串",
        "Tags": [
            ""
        ],
        "EditorType": "markdown"
    },
    {
        "Content": "师兄要求的天梯赛总结→_→\n\n1.为什么翻车\n\t\t第一题确实是不会做。然后T1有两道题卡了，“福到了”卡住是因为记错getline的语法导致输入不对，a不了；“倒数第N个字符串”在倒着减的时候忘记减1了一直wa(倒数第N个要从后往前减N-1次。。。)。 做题还是很马虎，打自己QAQ。\n2.为什么没上180\n\t\t前面翻车了拖时间，全队T1都翻了，也不敢做T2啊......(借口)\n\t\t就算完美发挥水平也就120左右啊(事实)\n\t\t上180仍需努力。\n3.哪些题没做出来\n\t\t看了一下，T2的2和3都是会能的。3我打了一遍，眼睛瞎了忘记输出那一列排名wa了。。   看了下榜又滚回去肝T1第一题了(虽然没肝出来)\n\n我还年轻。。我还能学。",
        "Title": "天梯赛总结",
        "CreateTime": 1522682850000,
        "FormatTime": "2018.04.02",
        "Categories": "杂",
        "Tags": [
            ""
        ],
        "EditorType": "markdown"
    },
    {
        "Content": "```\nstruct Node\n{\n\tint cnt;\n\tNode *next[26];\n\tbool exist;\n\tNode()\n\t{\n\t\tcnt = 0;\n\t\tmemset(next,0,sizeof(next));\n\t\texist = false; \n\t}\t\n}*rt;//要在主函数第一行写上 rt = new Node; \n\n\nvoid Insert(string str)//往字典树中插入一个字符串\n{\n\tint a;\n\tNode *p = rt;\n\tint i = 0;\n\twhile(str[i]!='\\0')\n\t{\n\t\ta = str[i] - 'a';\n\t\tif(p-\u003enext[a] == NULL)\n        {\n            p-\u003enext[a] = new Node;\n            p-\u003enext[a]-\u003ecnt = 0;\n        }\n      \tp = p-\u003enext[a];\n        \n        p-\u003ecnt += 1;\n        ++i;\n\t}\n\tp-\u003eexist = true;\n}\n\nint QueryCnt(string str)//查询某前缀(str)的单词有多少个\n{\n\tint a;\n\tNode *p = rt;\n\t\n\tint i = 0;\n    while(str[i] \u0026\u0026 p!=NULL)\n    {\n\t\ta = str[i] - 'a';\n        p = p-\u003enext[a];\n        ++i;\n    }\n\t\n    if(p == NULL)\n        return 0;\n    else\n        return p-\u003ecnt;\n}\n\nbool Queryword(string str)//查询字典树中有没有字符串str\n{\n\tint a;\n\tNode *p = rt;\n\t\n\tint i = 0;\n\twhile(str[i] \u0026\u0026 p!=NULL)\n    {\n\t\ta = str[i] - 'a';\n        p = p-\u003enext[a];\n        ++i;\n    }\n    if(p == NULL)\n        return 0;\n    if(p-\u003eexist==false)\n    \treturn 0;\n    return true;\n}\n```",
        "Title": "字典树模板(链式)",
        "CreateTime": 1522341463000,
        "FormatTime": "2018.03.30",
        "Categories": "数据结构",
        "Tags": [
            ""
        ],
        "EditorType": "markdown"
    },
    {
        "Content": "```\n#include\u003cstdio.h\u003e\n#include\u003ccstring\u003e\n#include\u003ciostream\u003e\nusing namespace std;\ntypedef long long ll;\n\nll t[100005\u003c\u003c2],lazy[100005\u003c\u003c2],a[100005];\nvoid pushup(int rt)\n{\n\tt[rt] = t[rt\u003c\u003c1] + t[rt\u003c\u003c1|1];\n}\n\nvoid pushdown(int rt,int l,int r)\n{\n\tif(lazy[rt])\n\t{\n\t\tlazy[rt\u003c\u003c1] += lazy[rt];\n\t\tlazy[rt\u003c\u003c1|1] += lazy[rt];//更新此节点的子节点 \n\t\tt[rt\u003c\u003c1] += lazy[rt]*l;\n\t\tt[rt\u003c\u003c1|1] += lazy[rt]*r;//下推懒惰标记至子节点 \n\t\tlazy[rt] = 0;//此节点懒惰标记置0 \n\t}\n}\n\nvoid build(int l,int r,int rt)\n{\n\tlazy[rt] = 0;\n\tif(l==r)\n\t{\n\t\tt[rt] = a[l];\n\t\treturn ;\n\t}\n\tint m = (l+r)\u003e\u003e1;\n\tbuild(l,m,rt\u003c\u003c1);\n\tbuild(m+1,r,rt\u003c\u003c1|1); \n\tpushup(rt); //此节点改变，其父节点也要更新 \n}\n\nll query(int L,int R,int l,int r,int rt)\n{\n\tif(l\u003e=L\u0026\u0026r\u003c=R)\n\t{\n\t\treturn t[rt];\n\t}\n\tint m = (l+r)\u003e\u003e1;\n\tpushdown(rt,m-l+1,r-m);//先更新再查询 \n\tll ans = 0;\n\tif(L\u003c=m)\n\t\tans += query(L,R,l,m,rt\u003c\u003c1);\n\tif(R\u003em)\n\t\tans += query(L,R,m+1,r,rt\u003c\u003c1|1);\n\treturn ans;\n}\n\nvoid update(int L,int R,ll C,int l,int r,int rt)\n{\n\tif(l\u003e=L\u0026\u0026R\u003e=r)//直接更新此区间的值，并打上懒惰标记 \n\t{\n\t\tt[rt] += C*(r-l+1);\n\t\tlazy[rt] += C;\n\t\treturn ; \n\t}\n\tint m = (l+r)\u003e\u003e1;\n\tpushdown(rt,m-l+1,r-m);//先解决之前的懒惰标记再更新 \n\tif(L\u003c=m)\n\t\tupdate(L,R,C,l,m,rt\u003c\u003c1);\n\tif(R\u003em)\n\t\tupdate(L,R,C,m+1,r,rt\u003c\u003c1|1);\n\tpushup(rt); //此节点改变，其父节点也要更新 \n}\n\n\n\nint N,Q;\nint x,y;\nll z;\nchar str[10];\nint main()\n{\n\tios::sync_with_stdio(false);\n\twhile(cin\u003e\u003eN\u003e\u003eQ)\n\t{\n\t\tfor(int i=1;i\u003c=N;i++)\n\t\t{\n\t\t\tcin\u003e\u003ea[i];\n\t\t}\n\t\tbuild(1,N,1);\n\t\twhile(Q--)\n\t\t{\n\t\t\tcin\u003e\u003estr;\t\t\n\t\t\tif(str[0]=='C')\n\t\t\t{\n\t\t\t\tcin\u003e\u003ex\u003e\u003ey\u003e\u003ez;\n\t\t\t\tupdate(x,y,z,1,N,1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcin\u003e\u003ex\u003e\u003ey;\n\t\t\t\tcout\u003c\u003cquery(x,y,1,N,1)\u003c\u003cendl;\n\t\t\t}\n\t\t}\n\t}\t\n\treturn 0;\n}\n```",
        "Title": "线段树模板(POJ3468)",
        "CreateTime": 1522211960000,
        "FormatTime": "2018.03.28",
        "Categories": "数据结构",
        "Tags": [
            ""
        ],
        "EditorType": "markdown"
    },
    {
        "Content": "\u003cp\u003e    题目很水。主要是学会了怎么重载\u0026gt;\u0026gt;，记录一下。\u003c/p\u003e\u003cp\u003e    因为输入的数据要存入变量中，故重载\u0026gt;\u0026gt;的函数参数表中要以引用的方式传参\u003cbr /\u003e\u003c/p\u003e\u003cp\u003e题目链接: https://www.patest.cn/contests/gplt/L1-005\u003cbr /\u003e\u003c/p\u003e\u003cp\u003e代码:\u003c/p\u003e\u003cpre class=\"cpp\"\u003e#include \u0026lt;iostream\u0026gt;\n#include\u0026lt;queue\u0026gt;\n#include\u0026lt;algorithm\u0026gt;\n#include\u0026lt;cmath\u0026gt;\n#include\u0026lt;cstring\u0026gt;\n#include\u0026lt;map\u0026gt;\n\nusing namespace std;\n\nmap\u0026lt;int,int\u0026gt; m;\n\nstruct student\n{\n\tstring id;\n\tint num1,num2;\n\tfriend istream\u0026amp; operator\u0026gt;\u0026gt;(istream\u0026amp; c,student \u0026amp;a)\n\t{\n\t\tcin\u0026gt;\u0026gt;a.id\u0026gt;\u0026gt;a.num1\u0026gt;\u0026gt;a.num2;\n\t}\n\tfriend ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; c,student a)\n\t{\n\t\tcout\u0026lt;\u0026lt;a.id\u0026lt;\u0026lt;' '\u0026lt;\u0026lt;a.num2\u0026lt;\u0026lt;endl;\n\t}\n}stu[1005];\n\nint N,T,num;\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\twhile(cin\u0026gt;\u0026gt;N)\n\t{\n\t\tfor(int i=0;i\u0026lt;N;i++)\n\t\t{\n\t\t\tcin\u0026gt;\u0026gt;stu[i];\n\t\t\tm[stu[i].num1] = i;\n\t\t}\n\t\tcin\u0026gt;\u0026gt;T;\n\t\tfor(int i=0;i\u0026lt;T;i++)\n\t\t{\n\t\t\tcin\u0026gt;\u0026gt;num;\n\t\t\tcout\u0026lt;\u0026lt;stu[m[num]];\n\t\t}\n\t}\n}\n\u003c/pre\u003e\u003cbr /\u003e\u003cdiv\u003e\u003cp style=\"margin-bottom:1.5em;border:0px;font-size:12px;line-height:inherit;font-family:'Droid Sans', Verdana, 'Microsoft YaHei', Tahoma, sans-serif;vertical-align:baseline;color:rgb(51,51,51);background-color:rgb(250,250,250);\"\u003e\u003cbr /\u003e\u003c/p\u003e\u003c/div\u003e",
        "Title": "团体程序设计天梯赛-练习集\tL1-005    考试座位号",
        "CreateTime": 1521091168000,
        "FormatTime": "2018.03.15",
        "Categories": "ACM水题",
        "Tags": [
            ""
        ],
        "EditorType": "富文本"
    },
    {
        "Content": "\u003cp\u003e        两种优先队列的声明方法\u003c/p\u003e\u003cp\u003e        std::priority_queue\u0026lt;T\u0026gt; que;\u003cbr /\u003e\u003c/p\u003e\u003cp\u003e        std::priority_queue\u0026lt;T, std::vector\u0026lt;T\u0026gt;, cmp\u0026gt; que;\u003c/p\u003e\u003cp\u003e        优先队列的top默认是大的，若要小的优先，则要定义一个结构体cmp，将()运算符重载\u003c/p\u003e\u003cp\u003e因为优先队列的优先级通过！cmp来判断，cmp要这样写：\u003c/p\u003e\u003cpre class=\"cpp\"\u003estruct cmp\n{\n\tbool operator()(int \u0026amp;a,int \u0026amp;b)\n\t{\n\t\treturn a\u0026gt;b;\n\t}    \n};\u003c/pre\u003e\u003cp\u003e        \u003c/p\u003e\u003cp\u003e        题目略\u003c/p\u003e\u003cp\u003e思路:先对a数组升序数据排序，逐一判断a[i]与i的关系)(i从1开始)，\u003c/p\u003e\u003cp\u003e        若==就continue；\u003c/p\u003e\u003cp\u003e        小于就a[i]+k，i--，重新对a进行排序；\u003c/p\u003e\u003cp\u003e        大于就直接tom赢了。\u003cbr /\u003e\u003c/p\u003e\u003cp\u003e每次小于都sort一次:15ms\u003c/p\u003e\u003cpre class=\"cpp\"\u003e#include\u0026lt;cstdio\u0026gt;\n#include\u0026lt;cstring\u0026gt;\n#include\u0026lt;algorithm\u0026gt;\nusing namespace std;\n\nint M,N,K,a[105],n;\nint main()\n{\n\tscanf(\"%d\",\u0026amp;M);\n\twhile(M--)\n\t{\n\t\tmemset(a,0,sizeof(a));\n\t\tscanf(\"%d %d\",\u0026amp;N,\u0026amp;K);\n\t\tfor(int i=1;i\u0026lt;=N;i++)\n\t\t{\n\t\t\tscanf(\"%d\",\u0026amp;a[i]);\t\t\t\n\t\t}\n\t\tsort(a+1,a+N+1);\n\t\tint flag = 1;\n\t\tfor(int i=1;i\u0026lt;=N;i++)\n\t\t{\n\t\t\tif(a[i]==i)\n\t\t\t\tcontinue;\n\t\t\telse if(a[i]\u0026lt;i)\n\t\t\t{\n\t\t\t\ta[i] += K;\n\t\t\t\ti--;\n\t\t\t\tsort(a+1,a+N+1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tflag = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag)\n\t\t\tprintf(\"Jerry\\n\");\n\t\telse\n\t\t\tprintf(\"Tom\\n\");\n\t}\n}\u003c/pre\u003e\u003cp\u003e用priority_queue优化:0ms\u003c/p\u003e\u003cpre class=\"cpp\"\u003e#include\u0026lt;cstdio\u0026gt;\n#include\u0026lt;queue\u0026gt;\nusing namespace std;\n\nstruct cmp\n{\n\tbool operator()(int \u0026amp;a,int \u0026amp;b)\n\t{\n\t\treturn a\u0026gt;b;\n\t}    \n};\nint M,N,K,a,n;\nint main()\n{\n\tscanf(\"%d\",\u0026amp;M);\n\twhile(M--)\n\t{\n\t    priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, cmp\u0026gt; que;\n\t\tscanf(\"%d %d\",\u0026amp;N,\u0026amp;K);\n\t\tfor(int i=1;i\u0026lt;=N;i++)\n\t\t{\n\t\t\tscanf(\"%d\",\u0026amp;a);\n\t\t\tque.push(a);\n\t\t}\n\t\tint flag = 1;\n\t\tfor(int i=1;i\u0026lt;=N;i++)\n\t\t{\n\t\t    a = que.top();\n\t\t    que.pop();\n\t\t\tif(a==i)\n\t\t\t\tcontinue;\n\t\t\telse if(a\u0026lt;i)\n\t\t\t{\n\t\t\t\ta += K;\n\t\t\t\tque.push(a);\n\t\t\t\ti--;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tflag = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag)\n\t\t\tprintf(\"Jerry\\n\");\n\t\telse\n\t\t\tprintf(\"Tom\\n\");\n\t}\n}\n\u003c/pre\u003e\u003cbr /\u003e\u003cbr /\u003e\u003cp\u003e        \u003c/p\u003e\u003cp\u003e   \u003cbr /\u003e\u003c/p\u003e",
        "Title": "HDU5090(贪心+priority_queue优化)",
        "CreateTime": 1520694043000,
        "FormatTime": "2018.03.10",
        "Categories": "ACM水题",
        "Tags": [
            ""
        ],
        "EditorType": "富文本"
    },
    {
        "Content": "\u003cp\u003e        今天是我第一次用克鲁斯卡尔a题。纪念一下。\u003c/p\u003e\u003cp\u003e        kruskal算法是一种贪心算法，它每次取权重最小的边并判断该边的两个端点是否属于同一棵树，显然当端点属于\u003cbr /\u003e\u003c/p\u003e\u003cp\u003e同一棵树时加上这条边会使这棵树出现环，此时舍去该边；当端点不属于同一棵树时，将该边加入树中，因为该边的\u003c/p\u003e\u003cp\u003e权重是当前最小的，最后得到的一定是最小生成树。\u003c/p\u003e\u003cp\u003e        首先要判断两个点是否在同一棵树上，这就要用到快速查询数据是否属于同一个集合的工具——并查集。\u003cbr /\u003e\u003c/p\u003e\u003cp\u003e        并查集的基本思想：每个集合选一个元素为代表，其他的元素都直接或间接地指向这个代表，形成一棵树。在查找\u003c/p\u003e\u003cp\u003e两个元素时，只要看它们指向的代表的值是否相同就能知道它们是否属于同一个集合。\u003c/p\u003e\u003cp\u003e        并查集的实现方法：以一个数组f[]来存储元素的信息，假设为代表的元素为a，则f[a]=a,该元素为树的根节点， 其余\u003c/p\u003e\u003cp\u003e所有该集合元素的数组都是叶子结点，值都为a，即f[b] = a,f[c]=a ...... 当所有元素都直接指向代表时，查询的时间\u003c/p\u003e\u003cp\u003e复杂度为O(1)。但随着元素的加入，该树可能会退化成一条长链，查询的时间复杂度会退化为O(n)，此时只要把所有元素\u003c/p\u003e\u003cp\u003e都指向代表即可。\u003c/p\u003e\u003cp\u003e        代码如下：\u003cbr /\u003e\u003c/p\u003e\u003cpre class=\"cpp\"\u003eint find(int x)\n{\n\treturn f[x]==x ? x : f[x]=find(f[x]);\n}\u003c/pre\u003e\u003cp\u003e        每次查询完都会把f[x]的值更新为find(f[x])\u003c/p\u003e\u003cp\u003e        有了并查集，就可以正式开始kruskal了。\u003cbr /\u003e\u003c/p\u003e\u003cp\u003e        首先要以边的权重对边进行排序，直接用STL sort即可\u003cbr /\u003e\u003c/p\u003e\u003cp\u003e        然后按顺序遍历每一条边，将边的两端点用并查集判断是否属于同一集合，否则合并这两条边\u003cbr /\u003e\u003c/p\u003e\u003cpre class=\"cpp\"\u003efor(int i=0;i\u0026lt;m;i++)\n{\n\tx = find(wall[i].u);\n\ty = find(wall[i].v);\n\tif(x!=y)\n\t{\n\t\t//cnt++;\n\t\tcost += wall[i].w;\n\t\tf[x] = y;\n\t}\t \n}\u003c/pre\u003e\u003cp\u003e        合并的操作就是让f[x] = y; ，相当于把xy连起来，cost用于记录最小生成树的各边权值之和。\u003c/p\u003e\u003cp\u003e        附上刚刚a的题：http://acm.hdu.edu.cn/showproblem.php?pid=6187\u003cbr /\u003e\u003c/p\u003e\u003cp\u003e        ac代码：\u003cbr /\u003e\u003c/p\u003e\u003cp\u003e   \u003cbr /\u003e\u003c/p\u003e\u003cpre class=\"cpp\"\u003e#include\u0026lt;iostream\u0026gt;\n#include\u0026lt;cstdio\u0026gt; \n#include\u0026lt;algorithm\u0026gt;\n\nusing namespace std;\n\nint n,m,c,d,cost,cnt,f[200005],sum;\n\nstruct Wall\n{\n\tint u;\n\tint v;\n\tint w;\n}wall[200005];\n\nbool cmp(Wall a,Wall b)\n{\n\treturn a.w\u0026gt;b.w;\n}\n\nint find(int x)\n{\n\treturn f[x]==x ? x : f[x]=find(f[x]);\n}\n\nint main()\n{\n\twhile(~scanf(\"%d%d\",\u0026amp;n,\u0026amp;m))\n\t{\n\t\tsum = 0;\n\t\tcost = 0;\n\t\tcnt = 0;\n\t\tfor(int i=1;i\u0026lt;=n;i++)\n\t\t{\n\t\t\tscanf(\"%d%d\",\u0026amp;c,\u0026amp;d);\n\t\t\tf[i] = i;\n\t\t}\n\t\tint u,v,w;\n\t\tfor(int i=0;i\u0026lt;m;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d\",\u0026amp;u,\u0026amp;v,\u0026amp;w);\n\t\t\twall[i].u = u;\n\t\t\twall[i].v = v;\n\t\t\twall[i].w = w;\n\t\t\tsum += w;\n\t\t}\n\t\tint x,y; \t\t\t\n\t\tsort(wall,wall+m,cmp);\n\t\t//kruskal\n\t\tfor(int i=0;i\u0026lt;m;i++)\n\t\t{\n\t\t\tx = find(wall[i].u);\n\t\t\ty = find(wall[i].v);\n\t\t\tif(x!=y)\n\t\t\t{\n\t\t\t\tcnt++;\n\t\t\t\tcost += wall[i].w;\n\t\t\t\tf[x] = y;\n\t\t\t}\t \n\t\t}\t\n\t\tprintf(\"%d %d\\n\",m-cnt,sum-cost);\n\t}\t\n} \u003c/pre\u003e\u003cbr /\u003e\u003cp\u003e        \u003cbr /\u003e\u003c/p\u003e",
        "Title": "最小生成树——kruskal",
        "CreateTime": 1520433105000,
        "FormatTime": "2018.03.07",
        "Categories": "图算法",
        "Tags": [
            ""
        ],
        "EditorType": "富文本"
    },
    {
        "Content": "\u003cp\u003e        刚刚逛了半天京东。。。干脆以购物车为例。\u003c/p\u003e\u003cp\u003e        现在我们有一个类叫做购物车(shopping cart简称SC)。想不出什么功能，就简单点：就一个输出总费用\u003c/p\u003e\u003cp\u003e的功能，大概这样。然后我现在车里有个iPad Air 2。\u003c/p\u003e\u003cpre class=\"cpp\"\u003e#include\u0026lt;iostream\u0026gt;\nusing namespace std;\n\nclass SC\n{\n\tint price;\npublic:\n\tSC(int p=0)\n\t{\n\t\tprice = p;\n\t}\n\t~SC(){}\n\tvoid show()\n\t{\n\t\tcout\u0026lt;\u0026lt;price\u0026lt;\u0026lt;endl;\n\t}\n};\n\nint main()\n{\n\tSC iPadAir2(2458);\t \n}\u003c/pre\u003e\u003cbr /\u003e\u003cp\u003e        现在我要往车里加东西，在类里面添加一个求和的功能。\u003c/p\u003e\u003cpre class=\"cpp\"\u003e\tint add(SC a)\n\t{\n\t\tprice += a.price;\n\t\treturn price;\n\t}\u003c/pre\u003e\u003cbr /\u003e\u003cp\u003e        为了使用的时候少打add跟括号，现在重载+运算符，把add改成operator+即可。\u003cbr /\u003e\u003c/p\u003e\u003cpre class=\"cpp\"\u003e\tint operator+(SC a)\n\t{\n\t\tprice += a.price;\n\t\treturn price;\n\t}\u003c/pre\u003e\u003cp\u003e        现在可以直接使用SC1 + SC2了。\u003c/p\u003e\u003cp\u003e\u003c/p\u003e\u003cp\u003e        在这里，operator+函数是类的成员函数。\u003c/p\u003e\u003cp\u003e        下面，假设我觉得一台ipad不够用，我要给家人一人买一台，需要加一个乘法功能。\u003c/p\u003e\u003cpre class=\"cpp\"\u003e\tint operator*(int n)\n\t{\n\t\treturn price*n;\n\t}\u003c/pre\u003e\u003cp\u003e        现在，cout\u0026lt;\u0026lt;iPadAir2*3;是没有问题的，但输出3*iPadAir2会报错。原因是:operator*是类的成员函数，重载后\u003c/p\u003e\u003cp\u003e左操作数必须是调用对象，但常理上iPadAir2*3与3*iPadAir2应该是等价的，用友元函数就可以很好地解决这个问题。\u003c/p\u003e\u003cpre class=\"cpp\"\u003e\tfriend int operator*(int n,SC \u0026amp;a)\n\t{\n\t\ta = a*n;\n\t\treturn a.price;\n\t}\u003c/pre\u003e\u003cbr /\u003e\u003cp\u003e        类的友元函数是非成员函数，但其访问权限与成员函数相同。\u003c/p\u003e\u003cp\u003e        友元常用于重载\u0026lt;\u0026lt;运算符，便于用cout对类进行输出。若不使用友元，而使用成员函数重载\u0026lt;\u0026lt;替代show函数，\u003c/p\u003e\u003cp\u003e函数代码如下：\u003c/p\u003e\u003cpre class=\"cpp\"\u003e\tvoid operator\u0026lt;\u0026lt;(ostream \u0026amp;c)\n\t{\n\t\tcout\u0026lt;\u0026lt;price\u0026lt;\u0026lt;endl;\n\t}\u003c/pre\u003e\u003cp\u003e        这样的缺陷是，因为调用对象必须为左操作数，故使用时必须写作iPadAir2\u0026lt;\u0026lt;cout; 十分怪异。\u003c/p\u003e\u003cp\u003e        利用友元反转操作数顺序即可达到预期效果：\u003cbr /\u003e\u003c/p\u003e\u003cpre class=\"cpp\"\u003e\tfriend void operator\u0026lt;\u0026lt;(ostream \u0026amp;c,SC a)\n\t{\n\t\tcout\u0026lt;\u0026lt;a.price\u0026lt;\u0026lt;endl;\n\t}\u003c/pre\u003e\u003cp\u003e        现在还存在的一个问题是，无法像输出基本类型时那样一次输出多个数，即不能cout\u0026lt;\u0026lt;iPadAir2\u0026lt;\u0026lt;iPadAir2;\u003c/p\u003e\u003cp\u003e        现在看一下\u0026lt;\u0026lt;运算符的定义: 其左边必须是一个ostream对象，如cout\u0026lt;\u0026lt;1;显然满足这一点。我们都知道，\u003cbr /\u003e\u003c/p\u003e\u003cp\u003e        cout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;2;是可行的，这意味着2前面的\u0026lt;\u0026lt;运算符左边的cout\u0026lt;\u0026lt;1是一个ostream对象，于是乎只要将\u003c/p\u003e\u003cp\u003eoperator\u0026lt;\u0026lt;()函数的返回类型改为对ostream对象的引用即可。\u003c/p\u003e\u003cpre class=\"cpp\"\u003e\tfriend ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream \u0026amp;c,SC a)\n\t{\n\t\tcout\u0026lt;\u0026lt;a.price\u0026lt;\u0026lt;endl;\n\t}\u003c/pre\u003e        睡了睡了，明天再看。\u003cbr /\u003e\u003cp\u003e\u003cbr /\u003e\u003c/p\u003e\u003cp\u003e        \u003cbr /\u003e\u003c/p\u003e\u003cp\u003e        \u003cbr /\u003e\u003c/p\u003e\u003cbr /\u003e\u003cp\u003e                                     \u003c/p\u003e",
        "Title": "C++运算符重载",
        "CreateTime": 1519229366000,
        "FormatTime": "2018.02.22",
        "Categories": "C++语法",
        "Tags": [
            ""
        ],
        "EditorType": "富文本"
    },
    {
        "Content": "\u003cp\u003e        晚上睡不着觉又a不动题，干脆看看书......\u003c/p\u003e\u003cp\u003e        学校课上讲的C++刚到面向对象就结束了，简直比吃鸡剩两个人时天命圈刷到自己脚底下突然屏幕一暗中间出现一个\u003c/p\u003e\u003cp\u003e图标上面写着一行\"网络延迟检测\"还要难受。没得办法，自己看看书做做笔记学一学了。\u003cbr /\u003e\u003c/p\u003e",
        "Title": "序",
        "CreateTime": 1519228818000,
        "FormatTime": "2018.02.22",
        "Categories": "C++语法",
        "Tags": [
            ""
        ],
        "EditorType": "富文本"
    },
    {
        "Content": "\u003cdiv class=\"panel_content\"\u003e题目:\u003c/div\u003e\u003cdiv class=\"panel_content\"\u003eIgnatius花了一个星期的时间终于找到了传说中的宝藏,宝藏被放在一个房间里,房间的门用密码锁起来了,在门旁边的墙上有一些关于密码的提示信息: \u003cbr /\u003e密码是一个C进制的数,并且只能由给定的M个数字构成,同时密码是一个给定十进制整数N(0\u0026lt;=N\u0026lt;=5000)的正整数倍(如果存在多个满足条件的数,那么最小的那个就是密码),如果这样的密码存在,那么当你输入它以后门将打开,如果不存在这样的密码......那就把门炸了吧. \u003cbr /\u003e\u003cbr /\u003e注意:由于宝藏的历史久远,当时的系统最多只能保存500位密码.因此如果得到的密码长度大于500也不能用来开启房门,这种情况也被认为密码不存在. \u003cbr /\u003e\u003c/div\u003eInput输入数据的第一行是一个整数T(1\u0026lt;=T\u0026lt;=300),表示测试数据的数量.每组测试数据的第一行是两个整数N(0\u0026lt;=N\u0026lt;=5000)和C(2\u0026lt;=C\u0026lt;=16),其中N表示的是题目描述中的给定十进制整数,C是密码的进制数.测试数据的第二行是一个整数M(1\u0026lt;=M\u0026lt;=16),它表示构成密码的数字的数量,然后是M个数字用来表示构成密码的数字.两个测试数据之间会有一个空行隔开. \u003cbr /\u003e\u003cbr /\u003e注意:在给出的M个数字中,如果存在超过10的数,我们约定用A来表示10,B来表示11,C来表示12,D来表示13,E来表示14,F来表示15.我保证输入数据都是合法的. \u003cbr /\u003eOutput对于每组测试数据,如果存在要求的密码,则输出该密码,如果密码不存在,则输出\"give me the bomb please\". \u003cbr /\u003e\u003cbr /\u003e注意:构成密码的数字不一定全部都要用上;密码有可能非常长,不要试图用一个整型变量来保存密码;我保证密码最高位不为0(除非密码本身就是0). \u003cbr /\u003eSample Input\u003cpre style=\"white-space:pre-wrap;\"\u003e3\n22 10\n3\n7 0 1\n\n2 10\n1\n1\n\n25 16\n3\nA B C\u003c/pre\u003eSample Output\u003cpre style=\"white-space:pre-wrap;\"\u003e110\ngive me the bomb please\nCCB\u003cspan style=\"font-size:1px;\"\u003e \u003c/span\u003e\n//Huge input, scanf is recommended.\u003c/pre\u003e\u003cp\u003e\u003cbr /\u003e\u003c/p\u003e\u003cp\u003e        题目大意: 中文题自己看→_→ ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑\u003c/p\u003e\u003cp\u003e        解题思路: 500位不能用N的倍数去一个一个判断。要用bfs一个一个数地加。每加一个数要%N一次防爆。因为每个数都是余数，舍掉的N的倍数的前缀没有影响，故余数相同的情况是同一种情况，用vis记录并判重。如第二个测试数据，余数永远是1，不可能除尽2，若不用余数判重，必须算到501位才能得出结果。\u003cbr /\u003e\u003c/p\u003e\u003cp\u003e        ac代码：\u003cbr /\u003e\u003c/p\u003e\u003cpre class=\"cpp\"\u003e#include\u0026lt;iostream\u0026gt;\n#include\u0026lt;queue\u0026gt;\n#include\u0026lt;cstring\u0026gt;\n#include\u0026lt;string\u0026gt; \n#include\u0026lt;algorithm\u0026gt;\nusing namespace std;\nint T,N,C,M;\nint k;\nchar c;\nint a[16];\nbool vis[10000];\nstring ans;\n\nstruct node\n{\n\tint num;\n\tstring str;\n\tint len;\n\tnode(int n=0,string s=\"\",int l=0)\n\t{\n\t\tnum = n;\n\t\tstr = s;\n\t\tlen = l;\n\t}\n};\n\nchar toChar(int x)\n{\n\tif(x\u0026lt;10)\t\n\t\treturn x + '0';\n\telse\n\t\treturn x - 10 + 'A';\n}\n \nvoid bfs()\n{\n\tqueue\u0026lt;node\u0026gt; que;\n\tnode p,pp;\n\tfor(int i=0;i\u0026lt;M;i++)\n\t{\n\t\tif(a[i]==0)//没有0开头的数 \n\t\t\tcontinue;\n\t\tp.num = a[i];\n\t\tp.str = toChar(a[i]);\n\t\tp.len = 1;\n\t\tque.push(p);\n\t}\n\twhile(!que.empty())\n\t{\n\t\tp = que.front();\n\t\tque.pop();\n\t\tif(p.num%N==0)\n\t\t{\n\t\t\tans = p.str;\n\t\t\treturn ; \n\t\t}\n\t\tif(p.len\u0026gt;500)\n\t\t\tcontinue;\n\t\tfor(int i=0;i\u0026lt;M;i++)  \n        {  \n        \tpp = p;\n            pp.str = pp.str+toChar(a[i]);   \n            pp.num = (pp.num*C + a[i]) % N; \n            pp.len++; \n\t\t\tif(!vis[pp.num])\n\t\t\t{\n\t\t\t\tvis[pp.num] = 1;\n\t\t\t\tque.push(pp);\n\t\t\t//\tcout\u0026lt;\u0026lt;\"将\"\u0026lt;\u0026lt;pp.str\u0026lt;\u0026lt;\"压入队列\\n\";\t\n\t\t\t}             \n\t\t}\n\t}\n\tans = \"\";\t\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin\u0026gt;\u0026gt;T;\n\twhile(T--)\n\t{\n\t\tk = 0;//判断M个数中有没有0 \n\t\tmemset(vis,0,sizeof(vis));\n\t\tcin\u0026gt;\u0026gt;N\u0026gt;\u0026gt;C;\n\t\tcin\u0026gt;\u0026gt;M;\n\t\tfor(int i=0;i\u0026lt;M;i++)\n\t\t{\n\t\t\tcin\u0026gt;\u0026gt;c;\t\t\n\t\t\tif(c\u0026gt;='0'\u0026amp;\u0026amp;c\u0026lt;='9')\n\t\t\t\ta[i] = c - '0';\t\t\n\t\t\telse\n\t\t\t\ta[i] = c - 55;\t\n\t\t\tif(!a[i])\n\t\t\t\tk = 1;\t//有0\t\t\n\t\t}\n\t\tif(!N\u0026amp;\u0026amp;k)//N==0且有0 \n\t\t{\n\t\t\tcout\u0026lt;\u0026lt;0\u0026lt;\u0026lt;endl;\n\t\t\tcontinue;\n\t\t}\n\t\tif(!N\u0026amp;\u0026amp;!k)//N==0但没0 \n\t\t{\n\t\t\tcout\u0026lt;\u0026lt;\"give me the bomb please\"\u0026lt;\u0026lt;endl;\n\t\t\tcontinue;\n\t\t}\n\t\tsort(a,a+M);//后面的队列先加入小的数，得到的第一个答案就是最小的密码 \n\t\tbfs();\n\t\tif(ans==\"\")\n\t\t\tcout\u0026lt;\u0026lt;\"give me the bomb please\"\u0026lt;\u0026lt;endl;\n\t\telse\n\t\t\tcout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl;\n\t}\n\treturn 0; \n}\u003c/pre\u003e\u003cbr /\u003e\u003cp\u003e\u003cbr /\u003e\u003c/p\u003e\u003cp\u003e\u003cbr /\u003e\u003c/p\u003e",
        "Title": "HDU 1266 超级密码",
        "CreateTime": 1518922306000,
        "FormatTime": "2018.02.18",
        "Categories": "搜索",
        "Tags": [
            ""
        ],
        "EditorType": "富文本"
    },
    {
        "Content": "\u003cp\u003e怕是寒假做不完搜索1了......\u003c/p\u003e\u003cp\u003e题目：\u003c/p\u003e\u003cp\u003e\u003c/p\u003e\u003cdiv class=\"panel_content\"\u003eThe Czech Technical University is rather old — you already know that it celebrates 300 years of its existence in 2007. Some of the university buildings are old as well. And the navigation in old buildings can sometimes be a little bit tricky, because of strange long corridors that fork and join at absolutely unexpected places. \u003cbr /\u003e\u003cbr /\u003eThe result is that some first-graders have often di?culties finding the right way to their classes. Therefore, the Student Union has developed a computer game to help the students to practice their orientation skills. The goal of the game is to find the way out of a labyrinth. Your task is to write a verification software that solves this game. \u003cbr /\u003e\u003cbr /\u003eThe labyrinth is a 2-dimensional grid of squares, each square is either free or filled with a wall. Some of the free squares may contain doors or keys. There are four di?erent types of keys and doors: blue, yellow, red, and green. Each key can open only doors of the same color. \u003cbr /\u003e\u003cbr /\u003eYou can move between adjacent free squares vertically or horizontally, diagonal movement is not allowed. You may not go across walls and you cannot leave the labyrinth area. If a square contains a door, you may go there only if you have stepped on a square with an appropriate key before.\u003c/div\u003eInputThe input consists of several maps. Each map begins with a line containing two integer numbers R and C (1 ≤ R, C ≤ 100) specifying the map size. Then there are R lines each containing C characters. Each character is one of the following: \u003cbr /\u003e\u003cbr /\u003e\u003ccenter\u003e\u003cimg src=\"https://odzkskevi.qnssl.com/a7ef1acff61732031b94921073b7cb74?v=1517991252\" width=\"423\" height=\"150\" alt=\"\" /\u003e\u003c/center\u003e\u003cbr /\u003e\u003cbr /\u003eNote that it is allowed to have \u003cbr /\u003emore than one exit,\u003cbr /\u003eno exit at all,\u003cbr /\u003emore doors and/or keys of the same color, and\u003cbr /\u003ekeys without corresponding doors and vice versa.\u003cbr /\u003e\u003cbr /\u003eYou may assume that the marker of your position (“*”) will appear exactly once in every map. \u003cbr /\u003e\u003cbr /\u003eThere is one blank line after each map. The input is terminated by two zeros in place of the map size.OutputFor each map, print one line containing the sentence “Escape possible in S steps.”, where S is the smallest possible number of step to reach any of the exits. If no exit can be reached, output the string “The poor student is trapped!” instead. \u003cbr /\u003e\u003cbr /\u003eOne step is defined as a movement between two adjacent cells. Grabbing a key or unlocking a door does not count as a step.Sample Input\u003cpre style=\"white-space:pre-wrap;\"\u003e1 10\n*........X\n\n1 3\n*#X\n\n3 20\n####################\n#XY.gBr.*.Rb.G.GG.y#\n####################\n\n0 0\u003c/pre\u003eSample Output\u003cpre style=\"white-space:pre-wrap;\"\u003eEscape possible in 9 steps.\nThe poor student is trapped!\nEscape possible in 45 steps.\u003c/pre\u003e\u003cp\u003e\u003cbr /\u003e\u003c/p\u003e\u003cp\u003e题目大意:走迷宫，#是墙，*是起点，X是终点，. 是路，小写字母是钥匙，大写字母是门，可能没有终点，输出有终点时去最近的终点的路程。\u003c/p\u003e\u003cp\u003e解题思路:这道题跟前面那个基本一样，就是状态压缩bfs，区别就两点，一是终点(出口)不唯一，且可能不存在，在输入时要判断是否存在出口，不存在就不要bfs了；二是钥匙不是从a开始的。Y是第25个字母，但显然不能用2的25次方的储存状态，在输入时简单处理即可。\u003cbr /\u003e\u003c/p\u003e\u003cp\u003e代码如下:\u003c/p\u003e\u003cpre class=\"cpp\"\u003e\u003c/pre\u003e\u003cpre class=\"cpp\"\u003e#include\u0026lt;iostream\u0026gt;\n#include\u0026lt;queue\u0026gt;\n#include\u0026lt;cstring\u0026gt;\nusing namespace std;\n\nint dx[] = {1,-1,0,0};\nint dy[] = {0,0,1,-1};\nint n,m,k;\nchar map[105][105];\nint vis[105][105][1\u0026lt;\u0026lt;5];\nstruct node\n{\n    int x,y,step;\n    int k;//记录状态\n    node(int X=0,int Y=0,int Step=0,int K = 0)\n    {\n        x = X;\n        y = Y;\n        step = Step;\n        k = K;\n    }\n}p,S,pp;\n\nqueue\u0026lt;node\u0026gt; que;\n\nvoid pick_Up()\n{\n\tint num = map[pp.x][pp.y] - 'a';\n\tpp.k |= (1 \u0026lt;\u0026lt; num);\n}\n\nbool cannot_Open(int num)\n{\n\tint a = p.k#\n\treturn a==0;//检验有没有相应的钥匙 \n}\n\nint bfs()\n{\n\tque.push(S);\n\tint num;\n\tvis[S.x][S.y][0] = 1;\n\twhile(!que.empty())\n\t{\n\n\t\tp = que.front();\n\t\tque.pop();\n\t\tif(map[p.x][p.y]=='X')\n\t\t\treturn p.step; \n\t\tfor(int i=0;i\u0026lt;4;i++)\n\t\t{\t\t\n\t\t\tpp.x = p.x+dx[i];\n\t\t\tpp.y = p.y+dy[i];\n\t\t\tpp.step = p.step+1;\n\t\t\tpp.k = p.k;\n\t\t\tif(!map[pp.x][pp.y]||map[pp.x][pp.y]=='#')//判断边界    \n\t\t\t\tcontinue;    \n\t\t\tif(map[pp.x][pp.y]=='B'||map[pp.x][pp.y]=='A'||map[pp.x][pp.y]=='C'||map[pp.x][pp.y]=='D')//遇到门 \n\t\t\t{\t\t\t\t\n\t\t\t\tnum =  map[pp.x][pp.y] - 'A';//A门对应0，B门对应1...... \n\t\t\t\tnum = 1\u0026lt;\u0026lt;num;//转换为2进制的位，如有A门对应pow(2,0)(第一位上的1)，B门对应pow(2,1)（第二位上的1）...... \n\t\t\t\tif(cannot_Open(num))\n\t\t\t\t\tcontinue;\t\t\t\t\t\n\t\t\t}\n\t\t\telse if(map[pp.x][pp.y]=='b'||map[pp.x][pp.y]=='a'||map[pp.x][pp.y]=='c'||map[pp.x][pp.y]=='d')//钥匙 \n\t\t\t{\n\t\t\t\tpick_Up();//遇到钥匙就捡起来...  \n\n\t\t\t}\n\t\t\t\n\t\t\tif(!vis[pp.x][pp.y][pp.k])//同一状态同一地点只走一次 \n\t\t\t{\n\t\t\t\tvis[pp.x][pp.y][pp.k] = 1;\n\t\t\t\tque.push(pp);\n\t\t\t}\t\t\n\t\t}\n\t}\n\treturn -1;\n}\n\nvoid init() \n{\n\tmemset(map,0,sizeof(map));\n\tmemset(vis,0,sizeof(vis));\n\twhile(!que.empty())\n\t{\n\t\tque.pop();\t\n\t}\t\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\twhile(cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026amp;\u0026amp;(n||m))\n    {\n    \tk = 0; \n    \tinit();\n        for(int i=1;i\u0026lt;=n;i++)\n        {\n            for(int j=1;j\u0026lt;=m;j++)\n            {\n                cin\u0026gt;\u0026gt;map[i][j];\n                if(map[i][j]=='R'||map[i][j]=='r')//一开始忘记处理，遇到Y就崩了。。。 \n                \tmap[i][j] -= ('R' - 'A');\n                else if(map[i][j]=='G'||map[i][j]=='g')\n                \tmap[i][j] -= ('G' - 'C');\n                else if(map[i][j]=='G'||map[i][j]=='g')\n                \tmap[i][j] -= ('G' - 'C');\n                else if(map[i][j]=='Y'||map[i][j]=='y')\n                \tmap[i][j] -= ('Y' - 'D');\n                if(map[i][j]=='X')\n                {\n                \tk = 1;\n\t\t\t\t}\n\t\t\t\telse if(map[i][j]=='*')\n\t\t\t\t{\n\t\t\t\t\tS.x = i;\n\t\t\t\t\tS.y = j;\n\t\t\t\t}\n            }\n        }\n        if(k==0)\n        {\n        \tcout\u0026lt;\u0026lt;\"The poor student is trapped!\"\u0026lt;\u0026lt;endl;\n        \tcontinue;\n\t\t}\t\n       \tint ans = bfs();\n       \tif(ans==-1)\n       \t{\n       \t\tcout\u0026lt;\u0026lt;\"The poor student is trapped!\"\u0026lt;\u0026lt;endl;\n        \tcontinue;\t\n\t\t}\n\t\tcout\u0026lt;\u0026lt;\"Escape possible in \"\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;\" steps.\\n\";\n       \t\t\n    }\n}\u003c/pre\u003e\u003cbr /\u003e",
        "Title": "hdu 1885 Key Task",
        "CreateTime": 1518773857000,
        "FormatTime": "2018.02.16",
        "Categories": "搜索",
        "Tags": [
            ""
        ],
        "EditorType": "富文本"
    },
    {
        "Content": "\u003cdiv class=\"panel_content\" style=\"font-family:'Microsoft YaHei';padding:0px;font-size:14px;color:rgb(63,63,63);line-height:30px;text-align:left;background-color:rgb(255,255,255);max-width:680px;\"\u003eIgnatius再次被魔王抓走了(搞不懂他咋这么讨魔王喜欢)……\u003cbr style=\"padding:0px;max-width:680px;\" /\u003e\u003cbr style=\"padding:0px;max-width:680px;\" /\u003e这次魔王汲取了上次的教训，把Ignatius关在一个n*m的地牢里，并在地牢的某些地方安装了带锁的门，钥匙藏在地牢另外的某些地方。刚开始Ignatius被关在(sx,sy)的位置，离开地牢的门在(ex,ey)的位置。Ignatius每分钟只能从一个坐标走到相邻四个坐标中的其中一个。魔王每t分钟回地牢视察一次，若发现Ignatius不在原位置便把他拎回去。经过若干次的尝试，Ignatius已画出整个地牢的地图。现在请你帮他计算能否再次成功逃亡。只要在魔王下次视察之前走到出口就算离开地牢，如果魔王回来的时候刚好走到出口或还未到出口都算逃亡失败。\u003c/div\u003e\u003cdiv class=\"panel_bottom\" style=\"font-family:'Microsoft YaHei';padding:0px;font-size:14px;color:rgb(63,63,63);line-height:30px;text-align:left;background-color:rgb(255,255,255);max-width:680px;\"\u003e \u003c/div\u003e\u003cp style=\"font-family:'Microsoft YaHei';font-size:14px;color:rgb(63,63,63);line-height:30px;text-align:left;background-color:rgb(255,255,255);max-width:680px;\"\u003e \u003c/p\u003e\u003cdiv class=\"panel_title\" align=\"left\" style=\"font-family:'Microsoft YaHei';padding:0px;font-size:14px;color:rgb(63,63,63);line-height:30px;background-color:rgb(255,255,255);max-width:680px;\"\u003eInput\u003c/div\u003e\u003cdiv class=\"panel_content\" style=\"font-family:'Microsoft YaHei';padding:0px;font-size:14px;color:rgb(63,63,63);line-height:30px;text-align:left;background-color:rgb(255,255,255);max-width:680px;\"\u003e每组测试数据的第一行有三个整数n,m,t(2\u0026lt;=n,m\u0026lt;=20,t\u0026gt;0)。接下来的n行m列为地牢的地图，其中包括:\u003cbr style=\"padding:0px;max-width:680px;\" /\u003e\u003cbr style=\"padding:0px;max-width:680px;\" /\u003e. 代表路\u003cbr style=\"padding:0px;max-width:680px;\" /\u003e* 代表墙\u003cbr style=\"padding:0px;max-width:680px;\" /\u003e@ 代表Ignatius的起始位置\u003cbr style=\"padding:0px;max-width:680px;\" /\u003e^ 代表地牢的出口\u003cbr style=\"padding:0px;max-width:680px;\" /\u003eA-J 代表带锁的门,对应的钥匙分别为a-j\u003cbr style=\"padding:0px;max-width:680px;\" /\u003ea-j 代表钥匙，对应的门分别为A-J\u003cbr style=\"padding:0px;max-width:680px;\" /\u003e\u003cbr style=\"padding:0px;max-width:680px;\" /\u003e每组测试数据之间有一个空行。\u003c/div\u003e\u003cdiv class=\"panel_bottom\" style=\"font-family:'Microsoft YaHei';padding:0px;font-size:14px;color:rgb(63,63,63);line-height:30px;text-align:left;background-color:rgb(255,255,255);max-width:680px;\"\u003e \u003c/div\u003e\u003cp style=\"font-family:'Microsoft YaHei';font-size:14px;color:rgb(63,63,63);line-height:30px;text-align:left;background-color:rgb(255,255,255);max-width:680px;\"\u003e \u003c/p\u003e\u003cdiv class=\"panel_title\" align=\"left\" style=\"font-family:'Microsoft YaHei';padding:0px;font-size:14px;color:rgb(63,63,63);line-height:30px;background-color:rgb(255,255,255);max-width:680px;\"\u003eOutput\u003c/div\u003e\u003cdiv class=\"panel_content\" style=\"font-family:'Microsoft YaHei';padding:0px;font-size:14px;color:rgb(63,63,63);line-height:30px;text-align:left;background-color:rgb(255,255,255);max-width:680px;\"\u003e针对每组测试数据，如果可以成功逃亡，请输出需要多少分钟才能离开，如果不能则输出-1。\u003c/div\u003e\u003cdiv class=\"panel_bottom\" style=\"font-family:'Microsoft YaHei';padding:0px;font-size:14px;color:rgb(63,63,63);line-height:30px;text-align:left;background-color:rgb(255,255,255);max-width:680px;\"\u003e \u003c/div\u003e\u003cp style=\"font-family:'Microsoft YaHei';font-size:14px;color:rgb(63,63,63);line-height:30px;text-align:left;background-color:rgb(255,255,255);max-width:680px;\"\u003e \u003c/p\u003e\u003cdiv class=\"panel_title\" align=\"left\" style=\"font-family:'Microsoft YaHei';padding:0px;font-size:14px;color:rgb(63,63,63);line-height:30px;background-color:rgb(255,255,255);max-width:680px;\"\u003eSample Input\u003c/div\u003e\u003cdiv class=\"panel_content\" style=\"font-family:'Microsoft YaHei';padding:0px;font-size:14px;color:rgb(63,63,63);line-height:30px;text-align:left;background-color:rgb(255,255,255);max-width:680px;\"\u003e\u003cdiv style=\"padding:0px;line-height:30px;max-width:680px;\"\u003e4 5 17\u003c/div\u003e\u003cdiv style=\"padding:0px;line-height:30px;max-width:680px;\"\u003e@A.B.\u003c/div\u003e\u003cdiv style=\"padding:0px;line-height:30px;max-width:680px;\"\u003ea*.*.\u003c/div\u003e\u003cdiv style=\"padding:0px;line-height:30px;max-width:680px;\"\u003e*..*^\u003c/div\u003e\u003cdiv style=\"padding:0px;line-height:30px;max-width:680px;\"\u003ec..b*\u003c/div\u003e\u003cdiv style=\"padding:0px;line-height:30px;max-width:680px;\"\u003e4 5 16\u003c/div\u003e\u003cdiv style=\"padding:0px;line-height:30px;max-width:680px;\"\u003e@A.B.\u003c/div\u003e\u003cdiv style=\"padding:0px;line-height:30px;max-width:680px;\"\u003ea*.*.\u003c/div\u003e\u003cdiv style=\"padding:0px;line-height:30px;max-width:680px;\"\u003e*..*^\u003c/div\u003e\u003cdiv style=\"padding:0px;line-height:30px;max-width:680px;\"\u003ec..b*\u003c/div\u003e\u003c/div\u003e\u003cdiv class=\"panel_bottom\" style=\"font-family:'Microsoft YaHei';padding:0px;font-size:14px;color:rgb(63,63,63);line-height:30px;text-align:left;background-color:rgb(255,255,255);max-width:680px;\"\u003e \u003c/div\u003e\u003cp style=\"font-family:'Microsoft YaHei';font-size:14px;color:rgb(63,63,63);line-height:30px;text-align:left;background-color:rgb(255,255,255);max-width:680px;\"\u003e \u003c/p\u003e\u003cdiv class=\"panel_title\" align=\"left\" style=\"font-family:'Microsoft YaHei';padding:0px;font-size:14px;color:rgb(63,63,63);line-height:30px;background-color:rgb(255,255,255);max-width:680px;\"\u003eSample Output\u003c/div\u003e\u003cdiv class=\"panel_content\" style=\"font-family:'Microsoft YaHei';padding:0px;font-size:14px;color:rgb(63,63,63);line-height:30px;text-align:left;background-color:rgb(255,255,255);max-width:680px;\"\u003e\u003cdiv style=\"padding:0px;line-height:30px;max-width:680px;\"\u003e16\u003c/div\u003e\u003cp style=\"padding:0px;line-height:30px;max-width:680px;\"\u003e-1\u003c/p\u003e\u003cp style=\"padding:0px;line-height:30px;max-width:680px;\"\u003e\u003cbr /\u003e\u003c/p\u003e\u003cp style=\"padding:0px;line-height:30px;max-width:680px;\"\u003e解题思路:第一次打状压。调了两三个小时，心累。 这题两个点卡住我，1是拿到钥匙后状态会改变，所以要在后面再判重；2是最短路大于t时，因为我把路程大于t的节点剪掉了，没有加入队列，bfs后面也没写return，导致返回了未知值而wa。\u003c/p\u003e\u003cp style=\"padding:0px;line-height:30px;max-width:680px;\"\u003e代码如下：\u003c/p\u003e\u003cpre class=\"cpp\"\u003e\u003cspan class=\"hljs-meta\" style=\"color:rgb(187,181,41);font-family:Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;font-size:14.4px;white-space:pre;\"\u003e\u003c/span\u003e\u003c/pre\u003e#include\u0026lt;iostream\u0026gt;\u003cbr /\u003e#include\u0026lt;queue\u0026gt;\u003cbr /\u003e#include\u0026lt;cstring\u0026gt;\u003cbr /\u003eusing namespace std;\u003cbr /\u003e\u003cbr /\u003e\u003cbr /\u003eint dx[] = {1,-1,0,0};\u003cbr /\u003eint dy[] = {0,0,1,-1};\u003cbr /\u003eint n,m,t;\u003cbr /\u003echar map[25][25];\u003cbr /\u003eint vis[25][25][1\u0026lt;\u0026lt;11];\u003cbr /\u003estruct node\u003cbr /\u003e{\u003cbr /\u003e    int x,y,step;\u003cbr /\u003e    int k;//记录状态\u003cbr /\u003e    node(int X=0,int Y=0,int Step=0,int K = 0)\u003cbr /\u003e    {\u003cbr /\u003e        x = X;\u003cbr /\u003e        y = Y;\u003cbr /\u003e        step = Step;\u003cbr /\u003e        k = K;\u003cbr /\u003e    }\u003cbr /\u003e    friend bool operator==(const node a,const node b)\u003cbr /\u003e    {\u003cbr /\u003e        if(a.x==b.x\u0026amp;\u0026amp;a.y==b.y)\u003cbr /\u003e            return true;\u003cbr /\u003e        else\u003cbr /\u003e            return false;\u003cbr /\u003e    }\u003cbr /\u003e}p,S,E,pp;\u003cbr /\u003e\u003cbr /\u003e\u003cbr /\u003e\u003cbr /\u003e\u003cbr /\u003equeue\u0026lt;node\u0026gt; que;\u003cbr /\u003e\u003cbr /\u003e\u003cbr /\u003evoid pick_Up()\u003cbr /\u003e{\u003cbr /\u003e\u003cspan style=\"white-space:pre;\"\u003e\t\u003c/span\u003eint num = map[pp.x][pp.y] - 'a';\u003cbr /\u003e\u003cspan style=\"white-space:pre;\"\u003e\t\u003c/span\u003epp.k |= (1 \u0026lt;\u0026lt; num);\u003cbr /\u003e}\u003cbr /\u003e\u003cbr /\u003e\u003cbr /\u003ebool cannot_Open(int num)\u003cbr /\u003e{\u003cbr /\u003e\u003cspan style=\"white-space:pre;\"\u003e\t\u003c/span\u003eint a = p.k\u0026amp;num;\u003cbr /\u003e\u003cspan style=\"white-space:pre;\"\u003e\t\u003c/span\u003ereturn a==0;//检验有没有相应的钥匙 \u003cbr /\u003e}\u003cbr /\u003e\u003cbr /\u003e\u003cbr /\u003eint bfs()\u003cbr /\u003e{\u003cbr /\u003e\u003cspan style=\"white-space:pre;\"\u003e\t\u003c/span\u003eque.push(S);\u003cbr /\u003e\u003cspan style=\"white-space:pre;\"\u003e\t\u003c/span\u003eint num;\u003cbr /\u003e\u003cspan style=\"white-space:pre;\"\u003e\t\u003c/span\u003evis[S.x][S.y][0] = 1;\u003cbr /\u003e\u003cspan style=\"white-space:pre;\"\u003e\t\u003c/span\u003ewhile(!que.empty())\u003cbr /\u003e\u003cspan style=\"white-space:pre;\"\u003e\t\u003c/span\u003e{\u003cbr /\u003e\u003cspan style=\"white-space:pre;\"\u003e\t\t\u003c/span\u003ep = que.front();\u003cbr /\u003e\u003cspan style=\"white-space:pre;\"\u003e\t\t\u003c/span\u003eque.pop();\u003cbr /\u003e\u003cspan style=\"white-space:pre;\"\u003e\t\t\u003c/span\u003eif(p.step\u0026gt;=t)\u003cbr /\u003e\u003cspan style=\"white-space:pre;\"\u003e\t\t\t\u003c/span\u003ereturn -1;\u003cbr /\u003e\u003cspan style=\"white-space:pre;\"\u003e\t\t\u003c/span\u003eif(p==E)\u003cbr /\u003e\u003cspan style=\"white-space:pre;\"\u003e\t\t\t\u003c/span\u003ereturn p.step; \u003cbr /\u003e\u003cspan style=\"white-space:pre;\"\u003e\t\t\u003c/span\u003efor(int i=0;i\u0026lt;4;i++)\u003cbr /\u003e\u003cspan style=\"white-space:pre;\"\u003e\t\t\u003c/span\u003e{\u003cbr /\u003e\u003cspan style=\"white-space:pre;\"\u003e\t\t\t\u003c/span\u003epp.x = p.x+dx[i];\u003cbr /\u003e\u003cspan style=\"white-space:pre;\"\u003e\t\t\t\u003c/span\u003epp.y = p.y+dy[i];\u003cbr /\u003e\u003cspan style=\"white-space:pre;\"\u003e\t\t\t\u003c/span\u003epp.step = p.step+1;\u003cbr /\u003e\u003cspan style=\"white-space:pre;\"\u003e\t\t\t\u003c/span\u003epp.k = p.k;\u003cbr /\u003e\u003cspan style=\"white-space:pre;\"\u003e\t\t\t\u003c/span\u003eif(!map[pp.x][pp.y]||map[pp.x][pp.y]=='*')//判断边界       一开始犯了个错，在这里判断了vis出不了答案。\u003cbr /\u003e\u003cspan style=\"white-space:pre;\"\u003e\t\t\t\u003c/span\u003e    continue;                              //           因为拿到钥匙的时候状态会变，所以要在push前判断 \u003cbr /\u003e\u003cspan style=\"white-space:pre;\"\u003e\t\t\t\u003c/span\u003eif(map[pp.x][pp.y]\u0026gt;='A'\u0026amp;\u0026amp;map[pp.x][pp.y]\u0026lt;='Z')//遇到门 \u003cbr /\u003e\u003cspan style=\"white-space:pre;\"\u003e\t\t\t\u003c/span\u003e{\u003cbr /\u003e\u003cspan style=\"white-space:pre;\"\u003e\t\t\t\t\u003c/span\u003enum =  map[pp.x][pp.y] - 'A';//A门对应0，B门对应1...... \u003cbr /\u003e\u003cspan style=\"white-space:pre;\"\u003e\t\t\t\t\u003c/span\u003enum = 1\u0026lt;\u0026lt;num;//转换为2进制的位，如有A门对应pow(2,0)(第一位上的1)，B门对应pow(2,1)（第二位上的1）...... \u003cbr /\u003e\u003cspan style=\"white-space:pre;\"\u003e\t\t\t\t\u003c/span\u003eif(cannot_Open(num))\u003cbr /\u003e\u003cspan style=\"white-space:pre;\"\u003e\t\t\t\t\t\u003c/span\u003econtinue;\u003cspan style=\"white-space:pre;\"\u003e\t\t\t\t\t\u003c/span\u003e\u003cbr /\u003e\u003cspan style=\"white-space:pre;\"\u003e\t\t\t\u003c/span\u003e}\u003cbr /\u003e\u003cspan style=\"white-space:pre;\"\u003e\t\t\t\u003c/span\u003eelse if(map[pp.x][pp.y]\u0026gt;='a'\u0026amp;\u0026amp;map[pp.x][pp.y]\u0026lt;='z')//钥匙 \u003cbr /\u003e\u003cspan style=\"white-space:pre;\"\u003e\t\t\t\u003c/span\u003e{\u003cbr /\u003e\u003cspan style=\"white-space:pre;\"\u003e\t\t\t\t\u003c/span\u003epick_Up();//遇到钥匙就捡起来...  \u003cbr /\u003e\u003cbr /\u003e\u003cbr /\u003e\u003cspan style=\"white-space:pre;\"\u003e\t\t\t\u003c/span\u003e}\u003cbr /\u003e\u003cspan style=\"white-space:pre;\"\u003e\t\t\t\u003c/span\u003e\u003cbr /\u003e\u003cspan style=\"white-space:pre;\"\u003e\t\t\t\u003c/span\u003eif(!vis[pp.x][pp.y][pp.k]\u0026amp;\u0026amp;pp.step\u0026lt;=t)//同一状态同一地点只走一次 \u003cbr /\u003e\u003cspan style=\"white-space:pre;\"\u003e\t\t\t\u003c/span\u003e{\u003cbr /\u003e\u003cspan style=\"white-space:pre;\"\u003e\t\t\t\t\u003c/span\u003evis[pp.x][pp.y][pp.k] = 1;\u003cbr /\u003e\u003cspan style=\"white-space:pre;\"\u003e\t\t\t\t\u003c/span\u003eque.push(pp);\u003cbr /\u003e\u003cspan style=\"white-space:pre;\"\u003e\t\t\t\u003c/span\u003e}\u003cspan style=\"white-space:pre;\"\u003e\t\t\u003c/span\u003e\u003cbr /\u003e\u003cspan style=\"white-space:pre;\"\u003e\t\t\u003c/span\u003e}\u003cbr /\u003e\u003cspan style=\"white-space:pre;\"\u003e\t\u003c/span\u003e}\u003cbr /\u003e\u003cspan style=\"white-space:pre;\"\u003e\t\u003c/span\u003ereturn -1;\u003cbr /\u003e}\u003cbr /\u003e\u003cbr /\u003e\u003cbr /\u003evoid init() \u003cbr /\u003e{\u003cbr /\u003e\u003cspan style=\"white-space:pre;\"\u003e\t\u003c/span\u003ememset(map,0,sizeof(map));\u003cbr /\u003e\u003cspan style=\"white-space:pre;\"\u003e\t\u003c/span\u003ememset(vis,0,sizeof(vis));\u003cbr /\u003e\u003cspan style=\"white-space:pre;\"\u003e\t\u003c/span\u003ewhile(!que.empty())\u003cbr /\u003e\u003cspan style=\"white-space:pre;\"\u003e\t\u003c/span\u003e{\u003cbr /\u003e\u003cspan style=\"white-space:pre;\"\u003e\t\t\u003c/span\u003eque.pop();\u003cspan style=\"white-space:pre;\"\u003e\t\u003c/span\u003e\u003cbr /\u003e\u003cspan style=\"white-space:pre;\"\u003e\t\u003c/span\u003e}\u003cspan style=\"white-space:pre;\"\u003e\t\u003c/span\u003e\u003cbr /\u003e}\u003cbr /\u003e\u003cbr /\u003e\u003cbr /\u003eint main()\u003cbr /\u003e{\u003cbr /\u003e\u003cspan style=\"white-space:pre;\"\u003e\t\u003c/span\u003ewhile(cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;t)\u003cbr /\u003e    {\u003cbr /\u003e    \u003cspan style=\"white-space:pre;\"\u003e\t\u003c/span\u003einit();\u003cbr /\u003e        for(int i=1;i\u0026lt;=n;i++)\u003cbr /\u003e        {\u003cbr /\u003e            for(int j=1;j\u0026lt;=m;j++)\u003cbr /\u003e            {\u003cbr /\u003e                cin\u0026gt;\u0026gt;map[i][j];\u003cbr /\u003e                if(map[i][j]=='^')\u003cbr /\u003e                {\u003cbr /\u003e                \u003cspan style=\"white-space:pre;\"\u003e\t\u003c/span\u003eE.x = i;\u003cbr /\u003e                \u003cspan style=\"white-space:pre;\"\u003e\t\u003c/span\u003eE.y = j;\u003cbr /\u003e\u003cspan style=\"white-space:pre;\"\u003e\t\t\t\t\u003c/span\u003e}\u003cbr /\u003e\u003cspan style=\"white-space:pre;\"\u003e\t\t\t\t\u003c/span\u003eelse if(map[i][j]=='@')\u003cbr /\u003e\u003cspan style=\"white-space:pre;\"\u003e\t\t\t\t\u003c/span\u003e{\u003cbr /\u003e\u003cspan style=\"white-space:pre;\"\u003e\t\t\t\t\t\u003c/span\u003eS.x = i;\u003cbr /\u003e\u003cspan style=\"white-space:pre;\"\u003e\t\t\t\t\t\u003c/span\u003eS.y = j;\u003cbr /\u003e\u003cspan style=\"white-space:pre;\"\u003e\t\t\t\t\u003c/span\u003e}\u003cbr /\u003e            }\u003cbr /\u003e        }\u003cbr /\u003e       \u003cspan style=\"white-space:pre;\"\u003e\t\u003c/span\u003ecout\u0026lt;\u0026lt;bfs()\u0026lt;\u0026lt;endl;\u003cbr /\u003e    }\u003cbr /\u003e}\u003c/div\u003e\u003cdiv class=\"panel_content\" style=\"font-family:'Microsoft YaHei';padding:0px;font-size:14px;color:rgb(63,63,63);line-height:30px;text-align:left;background-color:rgb(255,255,255);max-width:680px;\"\u003e状压: (1\u0026lt;\u0026lt;num) \u0026amp; 状态值 == 0 检验第num位是否为1\u003c/div\u003e\u003cdiv class=\"panel_content\" style=\"font-family:'Microsoft YaHei';padding:0px;font-size:14px;color:rgb(63,63,63);line-height:30px;text-align:left;background-color:rgb(255,255,255);max-width:680px;\"\u003e         (1\u0026lt;\u0026lt;num) | 状态值 增加状态\u003cbr /\u003e\u003c/div\u003e\u003cdiv class=\"panel_content\" style=\"font-family:'Microsoft YaHei';padding:0px;font-size:14px;color:rgb(63,63,63);line-height:30px;text-align:left;background-color:rgb(255,255,255);max-width:680px;\"\u003e      \u003cbr /\u003e\u003c/div\u003e",
        "Title": "胜利大逃亡(续) bfs+状压",
        "CreateTime": 1518281127000,
        "FormatTime": "2018.02.11",
        "Categories": "搜索",
        "Tags": [
            ""
        ],
        "EditorType": "富文本"
    },
    {
        "Content": "\r\n\u003cp\u003e题目：\u003c/p\u003e\r\n\u003cp\u003e\u003cspan class=\"space\" style=\"white-space:pre; display:inline-block; text-indent:2em; line-height:inherit\"\u003e\u0026nbsp;PS:懒得看的话直接拉下去看题目大意\u003c/span\u003e\u003c/p\u003e\r\n\u003cdd style=\"\"\u003e\r\n\u003cdiv class=\"ptx\" lang=\"en-US\"\u003eYou are trapped in a 3D dungeon and need to find the quickest way out! The dungeon is composed of unit cubes which may or may not be filled with rock. It takes one minute to move one unit north, south, east, west, up or down. You\r\n cannot move diagonally and the maze is surrounded by solid rock on all sides.\u0026nbsp;\u003cbr\u003e\r\n\u003cbr\u003e\r\nIs an escape possible? If yes, how long will it take?\u0026nbsp;\u003cbr\u003e\r\n\u003c/div\u003e\r\n\u003c/dd\u003e\u003cdt style=\"margin-top:20px; padding-left:35px; color:rgb(0,0,0); font-family:Simsun; font-size:14px\"\u003e\r\nInput\u003c/dt\u003e\u003cdd style=\"\"\u003e\r\n\u003cdiv class=\"ptx\" lang=\"en-US\"\u003eThe input consists of a number of dungeons. Each dungeon description starts with a line containing three integers L, R and C (all limited to 30 in size).\u0026nbsp;\u003cbr\u003e\r\nL is the number of levels making up the dungeon.\u0026nbsp;\u003cbr\u003e\r\nR and C are the number of rows and columns making up the plan of each level.\u0026nbsp;\u003cbr\u003e\r\nThen there will follow L blocks of R lines each containing C characters. Each character describes one cell of the dungeon. A cell full of rock is indicated by a '#' and empty cells are represented by a '.'. Your starting position is indicated by 'S' and the\r\n exit by the letter 'E'. There's a single blank line after each level. Input is terminated by three zeroes for L, R and C.\u003c/div\u003e\r\n\u003c/dd\u003e\u003cdt style=\"margin-top:20px; padding-left:35px; color:rgb(0,0,0); font-family:Simsun; font-size:14px\"\u003e\r\nOutput\u003c/dt\u003e\u003cdd style=\"\"\u003e\r\n\u003cdiv class=\"ptx\" lang=\"en-US\"\u003eEach maze generates one line of output. If it is possible to reach the exit, print a line of the form\u0026nbsp;\u003cbr\u003e\r\n\u003cblockquote\u003eEscaped in x minute(s).\u003c/blockquote\u003e\r\n\u003cbr\u003e\r\nwhere x is replaced by the shortest time it takes to escape.\u0026nbsp;\u003cbr\u003e\r\nIf it is not possible to escape, print the line\u0026nbsp;\u003cbr\u003e\r\n\u003cblockquote\u003eTrapped!\u003c/blockquote\u003e\r\n\u003c/div\u003e\r\n\u003c/dd\u003e\u003cdt style=\"margin-top:20px; padding-left:35px; color:rgb(0,0,0); font-family:Simsun; font-size:14px\"\u003e\r\nSample Input\u003c/dt\u003e\u003cdd style=\"\"\u003e\r\n\u003cpre class=\"sio\"\u003e3 4 5\nS....\n.###.\n.##..\n###.#\n\n#####\n#####\n##.##\n##...\n\n#####\n#####\n#.###\n####E\n\n1 3 3\nS##\n#E#\n###\n\n0 0 0\n\u003c/pre\u003e\r\n\u003c/dd\u003e\u003cdt style=\"margin-top:20px; padding-left:35px; color:rgb(0,0,0); font-family:Simsun; font-size:14px\"\u003e\r\nSample Output\u003c/dt\u003e\u003cdd style=\"\"\u003e\r\n\u003cpre class=\"sio\"\u003eEscaped in 11 minute(s).\nTrapped!\u003c/pre\u003e\r\n题目大意：你被困在一个3D迷宫里面，S表示起点，E表示终点，. 表示可走的地方，走每一步需要一分钟，求脱困的最短时间\r\n\u003cp\u003e\u003c/p\u003e\r\n\u003cp\u003e题目不难，不过有个坑——迷宫不止一条路能出去，因此要找的是最短路而不是找路。若认为这题只有一条路，用深搜，恭喜你wa了。 由于数据范围较大，即使用回溯法dfs也会超时，因此只能BFS。\u003c/p\u003e\r\n\u003cp\u003e\u003cspan style=\"color:rgb(79,79,79); text-align:justify\"\u003e下面附上代码：\u003c/span\u003e\u003cbr\u003e\r\n\u003c/p\u003e\r\n\u003cpre name=\"code\" class=\"cpp\"\u003e#include\u0026lt;iostream\u0026gt;\n#include\u0026lt;cstdio\u0026gt;\n#include\u0026lt;algorithm\u0026gt;\n#include\u0026lt;cstring\u0026gt;\n#include\u0026lt;queue\u0026gt;\nusing namespace std;\nint L,R,C,ans;\nchar map[35][35][35];\nint vis[35][35][35];\t\t//标记走过的地方用于剪枝 \nint dl[]={-1,1,0,0,0,0};  \t//六个方向 \nint dr[]={0,0,-1,1,0,0};  \nint dc[]={0,0,0,0,-1,1}; \n\n\n\n\nstruct point\n{\n\tint L;\n\tint R;\n\tint C;\n\tint num;//记录当前走到第几步 \n\t\n\tpoint(int l=0,int r=0,int c=0,int n=0)\n\t{//最近才学到原来结构体也可以有构造函数-_-|| \n\t\tL = l;\n\t\tR = r;\n\t\tC = c;\n\t\tnum = n;\n\t}\n\t~point(){}\n}S,a;\nqueue\u0026lt;point\u0026gt; que;\n\n\n\n\nint main()\n{\n\twhile(cin\u0026gt;\u0026gt;L\u0026gt;\u0026gt;R\u0026gt;\u0026gt;C\u0026amp;\u0026amp;(L||C||R))\n\t{\n\t\tmemset(map,0,sizeof(map));\n\t\tmemset(vis,0,sizeof(vis));\n\t\twhile(!que.empty())//上次终点时队列为非空，清空队列 \n\t\t\tque.pop();\n\t\tans = 999999999;\n\t\tfor(int i=1;i\u0026lt;=L;i++)\n\t\t\tfor(int j=1;j\u0026lt;=R;j++)\n\t\t\t\tfor(int k=1;k\u0026lt;=C;k++)\n\t\t\t\t{\n\t\t\t\t\tcin\u0026gt;\u0026gt;map[i][j][k];\n\t\t\t\t\tif(map[i][j][k]=='S')\n\t\t\t\t\t{\n\t\t\t\t\t\tS.L = i;\n\t\t\t\t\t\tS.R = j;\n\t\t\t\t\t\tS.C = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\t\n\t\tque.push(point(S.L,S.R,S.C,0));\n\t\tint k = 1;//标记能否走到终点\n\t\twhile(k\u0026amp;\u0026amp;!que.empty())\n\t\t{\n\t\t\ta = que.front();\n\t\t\tque.pop();\n\t\t\tfor(int i=0;i\u0026lt;6;i++)\n\t\t\t{//搜索六个方向 \n\t\t\t\tif(vis[a.L+dl[i]][a.R+dr[i]][a.C+dc[i]]==0\u0026amp;\u0026amp;(map[a.L+dl[i]][a.R+dr[i]][a.C+dc[i]]=='.'||map[a.L+dl[i]][a.R+dr[i]][a.C+dc[i]]=='E'))\n\t\t\t\t{\n\t\t\t\t\tif(map[a.L+dl[i]][a.R+dr[i]][a.C+dc[i]]=='E')\n\t\t\t\t\t{//下一步是终点了 \n\t\t\t\t\t\tans = min(a.num+1,ans);//这步应该多余了，宽搜到的一定是最短路 \n\t\t\t\t\t\tk = 0; //标记能否走到终点\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tvis[a.L+dl[i]][a.R+dr[i]][a.C+dc[i]] = 1;\n\t\t\t\t\tque.push(point(a.L+dl[i],a.R+dr[i],a.C+dc[i],a.num+1));\n\t\t\t\t}\t\n\t\t\t}\t\n\t\t}\t\t\n\t\tif(k)\n\t\t\tans = 0;\n\t\tif(ans)\t\n\t\t\tprintf(\u0026quot;Escaped in %d minute(s).\\n\u0026quot;,ans);\n\t\telse\n\t\t\tprintf(\u0026quot;Trapped!\\n\u0026quot;);\n\t}\n}\u003c/pre\u003e\r\n\u003cp\u003e\u003c/p\u003e\r\n宽搜最近刚回，总结一下：\r\n\u003cp\u003e\u003c/p\u003e\r\n\u003cp\u003e\u003cspan class=\"space\" style=\"white-space:pre; display:inline-block; text-indent:2em; line-height:inherit\"\u003e\u003cspan class=\"space\" style=\"white-space:pre; display:inline-block; text-indent:2em; line-height:inherit\"\u003e\u0026nbsp;\u003c/span\u003e\u0026nbsp;搜索一个节点时，先判断边界条件，不符合直接return，符合则将其进行标记，防止走回头路，然后将其各个子节点插入\u003c/span\u003e\u003c/p\u003e\r\n\u003cp\u003e\u003cspan class=\"space\" style=\"white-space:pre; display:inline-block; text-indent:2em; line-height:inherit\"\u003e队列中，每次从队列中取出一个元素，进行判断；如此反复，直至找到答案或队列为空。\u003c/span\u003e\u003cbr\u003e\r\n\u003c/p\u003e\r\n\u003cp\u003e\u003cspan class=\"space\" style=\"white-space:pre; display:inline-block; text-indent:2em; line-height:inherit\"\u003e\u003cspan class=\"space\" style=\"white-space:pre; display:inline-block; text-indent:2em; line-height:inherit\"\u003e\u0026nbsp;一定要做标记剪枝！！！\u003c/span\u003e\u003cbr\u003e\r\n\u003c/span\u003e\u003c/p\u003e\r\n\u003cp\u003e\u003cspan class=\"space\" style=\"white-space:pre; display:inline-block; text-indent:2em; line-height:inherit\"\u003e\u003cspan class=\"space\" style=\"white-space:pre; display:inline-block; text-indent:2em; line-height:inherit\"\u003e\u003cspan style=\"color:rgb(79,79,79); text-align:justify; text-indent:32px; white-space:pre\"\u003e\u0026nbsp;一定要做标记剪枝！！！\u003c/span\u003e\u003cbr\u003e\r\n\u003c/span\u003e\u003c/span\u003e\u003c/p\u003e\r\n\u003cp\u003e\u003cspan class=\"space\" style=\"white-space:pre; display:inline-block; text-indent:2em; line-height:inherit\"\u003e\u003cspan class=\"space\" style=\"white-space:pre; display:inline-block; text-indent:2em; line-height:inherit\"\u003e\u003cspan style=\"color:rgb(79,79,79); text-align:justify; text-indent:32px; white-space:pre\"\u003e\u003cspan style=\"color:rgb(79,79,79); text-align:justify; text-indent:32px; white-space:pre\"\u003e\u0026nbsp;一定要做标记剪枝！！！\u003c/span\u003e\u003cbr\u003e\r\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/p\u003e\r\n\u003cp\u003e\u003cspan class=\"space\" style=\"white-space:pre; display:inline-block; text-indent:2em; line-height:inherit\"\u003e\u0026nbsp;\u003c/span\u003e\u003cspan class=\"space\" style=\"white-space:pre; display:inline-block; text-indent:2em; line-height:inherit\"\u003e\u0026nbsp;后果如下\u003c/span\u003e\u003cbr\u003e\r\n\u003c/p\u003e\r\n\u003cp\u003e\u003cspan class=\"space\" style=\"white-space:pre; display:inline-block; text-indent:2em; line-height:inherit\"\u003e\u003cspan class=\"space\" style=\"white-space:pre; display:inline-block; text-indent:2em; line-height:inherit\"\u003e\u003cimg src=\"https://img-blog.csdn.net/20180202231658795?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQXBhbGVfOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\" style=\"text-indent:0px; white-space:normal\"\u003e\u003c/span\u003e\u003c/span\u003e\u003c/p\u003e\r\n\u003cp\u003e\u003cbr\u003e\r\n\u003c/p\u003e\r\n\u003cp\u003e\u003cbr\u003e\r\n\u003c/p\u003e\r\n\u003cp\u003e\u003cbr\u003e\r\n\u003c/p\u003e\r\n\u003cp\u003e\u003cbr\u003e\r\n\u003c/p\u003e\r\n\u003cp\u003e\u003cbr\u003e\r\n\u003c/p\u003e\r\n\u003cp\u003e\u003cbr\u003e\r\n\u003c/p\u003e\r\n\u003c/dd\u003e",
        "Title": "宽搜——Dungeon Master",
        "CreateTime": 1517584671000,
        "FormatTime": "2018.02.02",
        "Categories": "ACM水题",
        "Tags": [
            ""
        ],
        "EditorType": "富文本"
    },
    {
        "Content": "\r\n\u003cp style=\"text-indent:32px\"\u003e\u003cspan style=\"white-space:pre\"\u003e\u0026nbsp;\u003c/span\u003e开学后沉迷学习无法自拔(其实是懒)，忘记写博客来记录我的学习生涯，直至现在寒假了才想起，现决定解封我的CSDN。\u003c/p\u003e\r\n\u003cp\u003e刚刚看了下我的第一篇博客(我都差点忘记我写过博客。。。)，当时初学编程，那道题的思路完全是错的...... 最恐怖的是还有\u003c/p\u003e\r\n\u003cp\u003e几十个人看了那篇QAQ。 大一第一学期已经过去了，学了一个学期ACM，我越来越觉得师兄刚开始说的\u0026quot;人与人之间的差\u003c/p\u003e\r\n\u003cp\u003e距有时候可能比人比猪还大\u0026quot;这句话特别在理，同届生恐怖得像魔\u0026#39740;一样。。。 虽然我现在还不能望其项背，但我还是会坚持\u003c/p\u003e\r\n\u003cp\u003e下去。解封之际，先附上上篇博客中那道五个多月前难住我的题的实现代码。\u003c/p\u003e\r\n\u003cp\u003e先复述一遍题目\u003c/p\u003e\r\n\u003cp\u003e\u003cspan class=\"space\" style=\"white-space:pre; display:inline-block; text-indent:2em; line-height:inherit\"\u003e\u0026nbsp;输入一个n，输出一个螺旋向内递增的从1到n^2的n阶方阵（如下图）\u003c/span\u003e\u003c/p\u003e\r\n\u003cp\u003e\u003cspan class=\"space\" style=\"white-space:pre; display:inline-block; text-indent:2em; line-height:inherit\"\u003e\u003cbr\u003e\r\n\u003c/span\u003e\u003c/p\u003e\r\n\u003cp\u003e\u003cspan class=\"space\" style=\"white-space:pre; display:inline-block; text-indent:2em; line-height:inherit\"\u003e\u003cimg src=\"https://img-blog.csdn.net/20180202224445280?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQXBhbGVfOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"\u003e\u003c/span\u003e\u003c/p\u003e\r\n\u003cp\u003e\u003cspan class=\"space\" style=\"white-space:pre; display:inline-block; text-indent:2em; line-height:inherit\"\u003e\u003cspan style=\"text-indent:2em\"\u003e代码如下：\u003c/span\u003e\u003c/span\u003e\u003c/p\u003e\r\n\u003cp\u003e\u003cspan class=\"space\" style=\"white-space:pre; display:inline-block; text-indent:2em; line-height:inherit\"\u003e\u003c/span\u003e\u003cpre name=\"code\" class=\"cpp\"\u003e#include\u0026lt;iostream\u0026gt;\n#include\u0026lt;cstring\u0026gt;\nusing namespace std;\n\nint map[10][10];\nvoid build(int n)\n{ \n    int x = 0;\n    int y = 0;\n    int tot = map[x][y] = 1;\n    while(tot\u0026lt;n*n)\n    {\n        while(y\u0026lt;n-1\u0026amp;\u0026amp;!map[x][y+1])//最外面一层时遇到边界（-1或n）时停止循环，内层遇到下一个位置为非0(即外层数字已填入)时停止循环 \n        {\t\t\t\t\t\t   \n        \tmap[x][++y] = ++tot;\n\t\t}\n        while(x\u0026lt;n-1\u0026amp;\u0026amp;!map[x+1][y])\n            map[++x][y] = ++tot;\n        while(y\u0026gt;=1\u0026amp;\u0026amp;!map[x][y-1])\n            map[x][--y] = ++tot;\n        while(x\u0026gt;=1\u0026amp;\u0026amp;!map[x-1][y])\n            map[--x][y] = ++tot;\n    }\n}\n\n\nvoid show(int n)\n{\n    for(int i=0;i\u0026lt;n;i++)\n    {\n        for(int j=0;j\u0026lt;n;j++)\n        {\n            cout\u0026lt;\u0026lt;map[i][j];\n            if(j==n-1)\n                cout\u0026lt;\u0026lt;endl;\n            else\n                cout\u0026lt;\u0026lt;' ';\n            //PS：懒得打输出右对齐了，就这样了。。。 \n        }\n    }\n}\n\n\nint main()\n{\n    int n;\n    while(cin\u0026gt;\u0026gt;n)\n    {\n        memset(map,0,sizeof(map));//没填入的都清0，方便边界判断 \n        build(n);\n        show(n);\n        cout\u0026lt;\u0026lt;endl; \n    }\n}\u003c/pre\u003e\u003cbr\u003e\r\n\u003c/p\u003e\r\n\u003cp style=\"text-align:center; text-indent:32px\"\u003e\u003cspan style=\"white-space:pre\"\u003e\u003cbr\u003e\r\n\u003c/span\u003e\u003c/p\u003e\r\n\u003cp style=\"text-align:center; text-indent:32px\"\u003e\u003cspan style=\"white-space:pre\"\u003e\u003cbr\u003e\r\n\u003c/span\u003e\u003c/p\u003e\r\n\u003cp style=\"text-align:center; text-indent:32px\"\u003e\u003cspan style=\"white-space:pre\"\u003e\u003cbr\u003e\r\n\u003c/span\u003e\u003c/p\u003e\r\n\u003cbr\u003e\r\n\u003cbr\u003e\r\n\u003cp\u003e\u003c/p\u003e\r\n",
        "Title": "解封我的CSDN...",
        "CreateTime": 1517582360000,
        "FormatTime": "2018.02.02",
        "Categories": "ACM水题",
        "Tags": [
            ""
        ],
        "EditorType": "富文本"
    },
    {
        "Content": "\r\n\u003cp\u003e以发博客的形式记录我学习C的过程。\u003c/p\u003e\r\n\u003cp\u003e今天看到一道题，输入一个N然后输出如此类型的数阵：\u003c/p\u003e\r\n\u003cp\u003e5\u003c/p\u003e\r\n\u003cp\u003e1 \u0026nbsp; \u0026nbsp;2 \u0026nbsp; \u0026nbsp;3 \u0026nbsp; \u0026nbsp;4 \u0026nbsp; \u0026nbsp;5\u003cbr\u003e\r\n16 \u0026nbsp;17 18 \u0026nbsp;19 \u0026nbsp;6\u003c/p\u003e\r\n\u003cp\u003e15 \u0026nbsp; 24 \u0026nbsp;25 20 \u0026nbsp;7\u003c/p\u003e\r\n\u003cp\u003e14 \u0026nbsp; 23 \u0026nbsp;22 \u0026nbsp;21 \u0026nbsp;8\u003c/p\u003e\r\n\u003cp\u003e13 \u0026nbsp;12 \u0026nbsp; 11 \u0026nbsp;10 \u0026nbsp;9\u003c/p\u003e\r\n\u003cp\u003e一开始傻傻地在printf里面打空\u0026#26684;...\u003c/p\u003e\r\n\u003cp\u003e不过后来在百度上学到了水平制表符\\t和垂直制表符\\v，\u003c/p\u003e\r\n\u003cp\u003e本以为问题迎刃而解，\u003c/p\u003e\r\n\u003cp\u003e但不知为何\\v无法正常使用，看来还得多想想其他办法。\u003c/p\u003e\r\n",
        "Title": "C语言学习",
        "CreateTime": 1502268755000,
        "FormatTime": "2017.08.09",
        "Categories": "",
        "Tags": [
            ""
        ],
        "EditorType": "富文本"
    }
]